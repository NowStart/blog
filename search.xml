<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/05/12/%E6%9D%82%E8%B0%88/2023-05-12shandong/"/>
      <url>/2023/05/12/%E6%9D%82%E8%B0%88/2023-05-12shandong/</url>
      
        <content type="html"><![CDATA[<h2 id="day1-日照，05-13，晴，14°-25°"><a href="#day1-日照，05-13，晴，14°-25°" class="headerlink" title="day1(日照，05-13，晴，14°~25°):"></a>day1(日照，05-13，晴，14°~25°):</h2><p>上午10时开车从上海出发，午餐将就一下，大约17时到达日照；入住<code>蒙太奇园林酒店(日照万达广场东夷小镇店)</code>，然后到<code>外婆家疙瘩汤(舒斯贝尔花园店)</code>体验当地美食。</p><p>饭后19时30分左右去<code>东夷小镇</code>逛夜景，22时回酒店睡觉。</p><h2 id="day2-日照，05-14，阴，17°-26°"><a href="#day2-日照，05-14，阴，17°-26°" class="headerlink" title="day2(日照，05-14，阴，17°~26°):"></a>day2(日照，05-14，阴，17°~26°):</h2><p>8时起床，8时30分吃早餐；上午逛<code>日照万平口旅游区</code>；中午回到泰安路附近小饭店就餐；下午2时，离开酒店出发到<code>李家台赶海园</code>，预计17时潮水退到最低。（李家台赶海园潮汐表：<a href="https://www.1cxb.com/tides/274.html%EF%BC%89">https://www.1cxb.com/tides/274.html）</a></p><p>18时附近简单吃饭，驱车出发前往青岛，21时左右入住<code>斯维登度假公寓(青岛火车站栈桥店)</code>休息。</p><h2 id="day3-青岛-市区，05-15，晴，17°-22°"><a href="#day3-青岛-市区，05-15，晴，17°-22°" class="headerlink" title="day3(青岛-市区，05-15，晴，17°~22°):"></a>day3(青岛-市区，05-15，晴，17°~22°):</h2><p>上午9时，选择性游玩。</p><p>上午：青岛火车站出发，途径栈桥、圣弥厄尔大教堂-青岛德国建筑群、胶澳总督府旧址、观象山公园、信号山公园、老舍故居、青岛网红墙、梁秋实故居<br>下午：小青岛公园、海军博物馆、小鱼山公园、中山公园太平山观光索道、八大关景区、青岛第二海水浴场</p><p>18时到劈柴院吃饭，之后前往<code>xx酒店休息 崂山附近</code>休息。</p><h2 id="day4-青岛-崂山，05-16，晴，17°-22°"><a href="#day4-青岛-崂山，05-16，晴，17°-22°" class="headerlink" title="day4(青岛-崂山，05-16，晴，17°~22°):"></a>day4(青岛-崂山，05-16，晴，17°~22°):</h2><p>巨峰景区<br>18时到<code>xx</code>吃饭，20时前往<code>xx酒店休息 崂山附近</code>休息。</p><h2 id="day5-青岛-崂山，05-17，晴，17°-22°"><a href="#day5-青岛-崂山，05-17，晴，17°-22°" class="headerlink" title="day5(青岛-崂山，05-17，晴，17°~22°):"></a>day5(青岛-崂山，05-17，晴，17°~22°):</h2><p>仰口景区 或者 九水游览区<br>18时到<code>xx</code>吃饭，20时前往<code>xx酒店休息 烟台市</code>休息。</p><h2 id="day6-烟台，05-18，晴，17°-22°"><a href="#day6-烟台，05-18，晴，17°-22°" class="headerlink" title="day6(烟台，05-18，晴，17°~22°):"></a>day6(烟台，05-18，晴，17°~22°):</h2><p>烟台</p><h2 id="day7-上海，05-18，晴，17°-22°"><a href="#day7-上海，05-18，晴，17°-22°" class="headerlink" title="day7(上海，05-18，晴，17°~22°):"></a>day7(上海，05-18，晴，17°~22°):</h2><p>从烟台返回上海</p><p>崂山、八大关、信号山公园、小青岛（小鱼山）、栈桥、青岛奥林匹克帆船中心、青岛极地海洋世界、崂山区王哥镇庄雕龙嘴村、第三海水浴场、北九水</p><p>啤酒博物馆、八大关、小鱼山公园、、小麦岛公园、极地海洋公园</p><p>奥林匹克帆船中心、五四广场、情人坝</p><p>金沙滩、唐岛湾</p><p>崂山</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/05/08/%E7%9B%AE%E5%BD%95/"/>
      <url>/2023/05/08/%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>《记着玩》</p><p>随想<br>折腾的物件<br>    威联通NAS<br>    鼠标<br>    芝杜Z9X<br>    PT站<br>投资<br>游戏&amp;影音&amp;小说<br>旅行<br>锻炼<br>饮食<br>书籍<br>事业<br>专业技术<br>工具软件<br>保险</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL深入浅出索引（上）</title>
      <link href="/2021/12/29/db/mysql4/"/>
      <url>/2021/12/29/db/mysql4/</url>
      
        <content type="html"><![CDATA[<p>一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。</p><h2 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h2><p>可以用于提高读写效率的数据结构很多，这里我先给你介绍三种常见、也比较简单的数据结构，它们分别是<strong>哈希表、有序数组和搜索树</strong>。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><img src="https://ypk.myqnapcloud.com:8412/images/2022/04/24/0c62b601afda86fe5d0fe57346ace957.png" alt="哈希表示意图"></p><p>需要注意的是，图中四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。你可以设想下，如果你现在要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必须全部扫描一遍了。</p><p><strong>哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎</strong>。</p><h3 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h3><p>有序数组在等值查询和范围查询场景中的性能就都非常优秀。还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：</p><p><img src="https://ypk.myqnapcloud.com:8412/images/2022/04/24/bfc907a92f99cadf5493cf0afac9ca49.png" alt="有序数组示意图"></p><p>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查 ID_card_n2 对应的名字，用二分法就可以快速得到，这个时间复杂度是 O(log(N))。</p><p>同时很显然，这个索引结构支持范围查询。你要查身份证号在[ID_card_X, ID_card_Y]区间的 User，可以先用二分法找到 ID_card_X（如果不存在 ID_card_X，就找到大于 ID_card_X 的第一个 User），然后向右遍历，直到查到第一个大于 ID_card_Y 的身份证号，退出循环。</p><p>如果<strong>仅仅看查询效率，有序数组就是最好的数据结构了</strong>。但是，<strong>在需要更新数据的时候就麻烦了</strong>，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。</p><p>所以，<strong>有序数组索引只适用于静态存储引擎</strong>，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。</p><h3 id="搜索树"><a href="#搜索树" class="headerlink" title="搜索树"></a>搜索树</h3><p>二叉搜索树也是课本里的经典数据结构了。还是上面根据身份证号查名字的例子，如果我们用二叉搜索树来实现的话，示意图如下所示:</p><p><img src="https://ypk.myqnapcloud.com:8412/images/2022/04/24/04fb9d24065635a6a637c25ba9ddde68.png" alt="二叉搜索树示意图"></p><p>二叉搜索树的特点是：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&gt; UserC -&gt; UserF -&gt; User2 这个路径得到。这个时间复杂度是 O(log(N))。</p><p>当然为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 O(log(N))。</p><blockquote><p>二叉树也会畸变成单链表，所以才有了AVL树通过旋转的方式来维持树的平衡，但后来发现大量的旋转实在是性能不好，所以有了红黑树。都是二叉树，只是约束条件不一样。没有最好的方法只有更适合的方法，要维持某一方面的优势需要牺牲另一方面的优势，就看如何选择了。</p></blockquote><p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</p><p>你可以想象一下一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。</p><p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。</p><p>以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p><p>N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。</p><p>不管是哈希还是有序数组，或者 N 叉树，它们都是不断迭代、不断优化的产物或者解决方案。数据库技术发展到今天，跳表、LSM 树等数据结构也被用于引擎设计中，这里我就不再一一展开了。</p><p>你心里要有个概念，数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。</p><p>在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。由于 InnoDB 存储引擎在 MySQL 数据库中使用最为广泛，所以下面我就以 InnoDB 为例，和你分析一下其中的索引模型。</p><h2 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h2><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为<strong>索引组织表</strong>。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。</p><p>每一个索引在 InnoDB 里面对应一棵 B+ 树。</p><p>假设，我们有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引。这个表的建表语句是：</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">mysql&gt; create table T(id int primary key, k int not null, name varchar(16),index (k))engine&#x3D;InnoDB;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。</p><p><img src="https://ypk.myqnapcloud.com:8412/images/2022/04/24/dcda101051f28502bd5c4402b292e38d.png" alt="InnoDB 的索引组织结构"></p><p>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p><p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。</p><p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</p><p>根据上面的索引结构说明，我们来讨论一个问题：<strong>基于主键索引和普通索引的查询有什么区别？</strong></p><ol><li>如果语句是 select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</li><li>如果语句是 select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。<strong>这个过程称为回表。</strong></li></ol><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p><h2 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h2><p>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</p><p>而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。</p><p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。</p><p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p><p>基于上面的索引维护过程说明，我们来讨论一个案例：</p><blockquote><p>你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。</p></blockquote><p>插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。</p><p>也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p><p>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p><p>除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？</p><p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。</p><p><strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p><p>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p><p>有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p><ol><li>只有一个索引；</li><li>该索引必须是唯一索引。</li></ol><p>你一定看出来了，这就是典型的 KV 场景。</p><p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>分析了数据库引擎可用的数据结构，介绍了 InnoDB 采用的 B+ 树结构，以及为什么 InnoDB 要这么选择。B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。</p><p>由于 InnoDB 是索引组织表，一般情况下我会建议你创建一个自增主键，这样非主键索引占用的空间最小。但事无绝对，我也跟你讨论了使用业务逻辑字段做主键的应用场景。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务隔离</title>
      <link href="/2021/12/26/db/mysql3/"/>
      <url>/2021/12/26/db/mysql3/</url>
      
        <content type="html"><![CDATA[<p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。</p><h2 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h2><p>提到事务，你肯定会想到 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），今天我们就来说说其中 I，也就是“隔离性”。</p><p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。</p><p>在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐一为你解释：</p><p><strong>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。</strong></p><ol><li>在“可重复读”隔离级别下，这个<strong>视图是在事务启动时创建的，整个事务存在期间都用这个视图</strong>。</li><li>在“读提交”隔离级别下，这个<strong>视图是在每个 SQL 语句开始执行的时候创建</strong>的。这里需要注意的是;</li><li>“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；</li><li>而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</li></ol><p>我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle 数据库的默认隔离级别其实就是“读提交”，因此对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，你一定要记得将 MySQL 的隔离级别设置为“读提交”。</p><p>配置的方式是，将启动参数 <code>transaction-isolation</code> 的值设置成 <code>READ-COMMITTED</code>。你可以用 <code>show variables</code> 来查看当前的值。</p><p>假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p><p>这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</p><h2 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h2><p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。</p><p>在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p><p>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。</p><p><img src="https://ypk.myqnapcloud.com:8412/images/2022/04/24/d9c313809e5ac148fc39feff532f0fee.png"></p><p>当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。</p><p>同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。</p><p>你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p><p>什么时候才不需要了呢？<strong>就是当系统里没有比这个回滚日志更早的 read-view 的时候。</strong></p><p>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。</p><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><p>在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。</p><p>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。</p><h2 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h2><p>如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。MySQL 的事务启动方式有以下几种：</p><ol><li>显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。</li><li>set autocommit&#x3D;0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。</li></ol><p>因此，我会建议你总是使用 set autocommit&#x3D;1, 通过显式语句的方式来启动事务。</p><p>在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p><p>你可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span>innodb_trx <span class="token keyword">where</span> TIME_TO_SEC<span class="token punctuation">(</span>timediff<span class="token punctuation">(</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>trx_started<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">60</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章里面，我介绍了 MySQL 的事务隔离级别的现象和实现，根据实现原理分析了长事务存在的风险，以及如何用正确的方式避免长事务。</p><blockquote><p>事务隔离实现的相关概念: 事务隔离 &gt; RR&#x2F;RC &gt; read-view(读视图) &gt; 回滚段</p></blockquote><p>读未提交：别人改数据的事务尚未提交，我在我的事务中也能读到。<br>读已提交：别人改数据的事务已经提交，我在我的事务中才能读到。<br>可重复读：别人改数据的事务已经提交，我在我的事务中也不去读。<br>串行：我的事务尚未提交，别人就别想改数据。<br>这4种隔离级别，并行性能依次降低，安全性依次提高。</p><p>为该讲总结了几个问题, 大家复习的时候可以先尝试回答这些问题检查自己的掌握程度:</p><ol><li>事务的概念是什么?</li><li>mysql的事务隔离级别读未提交, 读已提交, 可重复读, 串行各是什么意思?</li><li>读已提交, 可重复读是怎么通过视图构建实现的?</li><li>可重复读的使用场景举例? 对账的时候应该很有用?</li><li>事务隔离是怎么通过read-view(读视图)实现的?</li><li>并发版本控制(MCVV)的概念是什么, 是怎么实现的?</li><li>使用长事务的弊病? 为什么使用常事务可能拖垮整个库?</li><li>事务的启动方式有哪几种?</li><li>commit work and chain的语法是做什么用的?</li><li>怎么查询各个表中的长事务?</li><li>如何避免长事务的出现?</li></ol>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL日志系统</title>
      <link href="/2021/12/26/db/mysql2/"/>
      <url>/2021/12/26/db/mysql2/</url>
      
        <content type="html"><![CDATA[<p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）。</p><h2 id="重要的日志模块：redo-log-（InnoDB中）"><a href="#重要的日志模块：redo-log-（InnoDB中）" class="headerlink" title="重要的日志模块：redo log （InnoDB中）"></a>重要的日志模块：redo log （InnoDB中）</h2><p>同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p><p>而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p><p>具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p><p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。</p><p>与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p><p><img src="https://ypk.myqnapcloud.com:8412/images/2022/04/24/OTY3bJ.png"></p><p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p><p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。</p><h2 id="重要的日志模块：binlog-（Server中）"><a href="#重要的日志模块：binlog-（Server中）" class="headerlink" title="重要的日志模块：binlog （Server中）"></a>重要的日志模块：binlog （Server中）</h2><p>前面我们讲过，MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。</p><p>我想你肯定会问，为什么会有两份日志呢？</p><p>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。</p><p>这两种日志有以下三点不同。</p><ol><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；</li><li>binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><p><img src="https://ypk.myqnapcloud.com:8412/images/2022/04/24/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="update 语句执行流程"></p><p>你可能注意到了，最后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是”两阶段提交”。</p><h2 id="redo-log两阶段提交"><a href="#redo-log两阶段提交" class="headerlink" title="redo log两阶段提交"></a>redo log两阶段提交</h2><p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：</p><ol><li>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；</li><li>然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。</li></ol><p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p><p>你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？</p><p>其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用 binlog 来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。</p><p>简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天，我介绍了 MySQL 里面最重要的两个日志，即物理日志 redo log 和逻辑日志 binlog。</p><p>redo log 用于保证 crash-safe 能力。<code>innodb_flush_log_at_trx_commit</code> 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。</p><p><code>sync_binlog</code> 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。</p><p>我还跟你介绍了与 MySQL 日志系统密切相关的“两阶段提交”。两阶段提交是跨系统维持数据逻辑一致性时常用的一个方案，即使你不做数据库内核开发，日常开发中也有可能会用到。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础架构</title>
      <link href="/2021/12/25/db/mysql1/"/>
      <url>/2021/12/25/db/mysql1/</url>
      
        <content type="html"><![CDATA[<p>MySQL 可以分为 Server 层和存储引擎层两部分。</p><span id="more"></span><p><img src="https://ypk.myqnapcloud.com:8412/images/2022/04/24/wXXF6Z.jpg" alt="MySQL的逻辑架构图"></p><p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql <span class="token operator">-</span>h$ip <span class="token operator">-</span>P$port <span class="token operator">-</span>u$<span class="token keyword">user</span> <span class="token operator">-</span>p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p></blockquote><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。文本中这个图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。</p><p>但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。定期断开长连接。</p><ol><li>使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</p><p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。</p><p>好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> SQL_CACHE <span class="token operator">*</span> <span class="token keyword">from</span> T <span class="token keyword">where</span> ID<span class="token operator">=</span><span class="token number">10</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。</p></blockquote><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。</p><p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。</p><p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">join</span> t2 <span class="token keyword">using</span><span class="token punctuation">(</span>ID<span class="token punctuation">)</span>  <span class="token keyword">where</span> t1<span class="token punctuation">.</span>c<span class="token operator">=</span><span class="token number">10</span> <span class="token operator">and</span> t2<span class="token punctuation">.</span>d<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误. (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> T <span class="token keyword">where</span> ID<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>ERROR <span class="token number">1142</span> <span class="token punctuation">(</span><span class="token number">42000</span><span class="token punctuation">)</span>: <span class="token keyword">SELECT</span> command denied <span class="token keyword">to</span> <span class="token keyword">user</span> <span class="token string">'b'</span><span class="token variable">@'localhost'</span> <span class="token keyword">for</span> <span class="token keyword">table</span> <span class="token string">'T'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p>比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p><ol><li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天介绍了 MySQL 的逻辑架构，希望对一个 SQL 语句完整执行流程的各个阶段有了一个初步的印象。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>api-doc 使用说明</title>
      <link href="/2020/07/18/project/api-doc-introduce/"/>
      <url>/2020/07/18/project/api-doc-introduce/</url>
      
        <content type="html"><![CDATA[<p>api-doc致力于减轻开发人员写接口文档的负担，希望可以以最小的代价，快速生成接口文档。</p><p>我们尽量规避复杂注解，以极简的方式，生成丰富的文档内容，即所谓<code>代码即文档</code>。</p><p>它有如下几个优点：</p><ol><li>配置足够少，上手简单，默认配置能满足大部分场景</li><li>非侵入式，极少的额外注解(非必须的)，使用常规功能时不用修改现有代码</li><li>多层次的字段翻译功能，减少不必要的重复劳动</li><li>除@Controller外，也支持@RpcService，以及以FunctionCode路由功能的web接口</li></ol><blockquote><p><strong>注意</strong><br/><br>对于请求参数、响应参数的解析，是依赖Javadoc的API进行的，它要求参数必须有明确的结构，因此api-doc不支持以Map作为参数的方法解析。</p></blockquote><p><img src="/images/2020/07/api-doc-process.png" alt="api-doc-process"></p><h2 id="一、三步完成api-doc的引入和使用"><a href="#一、三步完成api-doc的引入和使用" class="headerlink" title="一、三步完成api-doc的引入和使用"></a>一、三步完成api-doc的引入和使用</h2><h3 id="step-1-添加插件"><a href="#step-1-添加插件" class="headerlink" title="step 1. 添加插件"></a>step 1. 添加插件</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.ly.fn.biz.api-doc-maven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>api-doc-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>yapiToken</span><span class="token punctuation">></span></span>a7106c02912fff91858cf721175ea16b99bff8141c29aaa1da1d4020c5d7053f<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>yapiToken</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>yapiToken</code>是从Yapi平台的项目设置中得到的，插件通过它定位具体的Yapi项目。</p><h3 id="step-2-运行插件"><a href="#step-2-运行插件" class="headerlink" title="step 2. 运行插件"></a>step 2. 运行插件</h3><p>进入项目根目录，运行如下命令</p><p><code>mvn api-doc:api-doc</code></p><p>或者双击IDEA中的插件</p><p><img src="/images/2020/07/api-doc-rn.png" alt="api-doc-rn"></p><p>控制台中打印出类似内容，代表执行成功。默认情况下，插件不绑定maven的生命周期。</p><p><img src="/images/2020/07/succ-result.png" alt="succ-result"></p><h3 id="step-3-查看Yapi平台成果"><a href="#step-3-查看Yapi平台成果" class="headerlink" title="step 3. 查看Yapi平台成果"></a>step 3. 查看Yapi平台成果</h3><blockquote><p><strong>注意</strong><br/><br>接口方法注释将成为Yapi菜单的名称，注意为接口方法添加注释。<br>接口排列顺序，是按照首字母升序排列的，建议同一功能模块具有相同的前缀名称。</p></blockquote><p><img src="/images/2020/07/ypai-result.png" alt="ypai-result"></p><h2 id="二、关于请求、响应参数字段的翻译"><a href="#二、关于请求、响应参数字段的翻译" class="headerlink" title="二、关于请求、响应参数字段的翻译"></a>二、关于请求、响应参数字段的翻译</h2><p>为了避免翻译字段时的重复劳动，不停添加相同的注释，api-doc提供了多种获得注释的方式。</p><p><img src="/images/2020/07/translate.png" alt="translate"></p><p>当前一种方式无法获得中文注释时，会自动尝试下一种获取方式。点击<a href="http://gitserver/ypk15904/biz-lw-factory-web-api-doc/raw/master/biz-lw-factory-web.properties">链接</a>查看远程字典的示例。</p><p>同一个项目中的命名习惯，通常是有迹可循的，理想状况下，将远程字典调教好，代码中仅需个别的字段需要手动添加注释。</p><h2 id="三、更多配置说明"><a href="#三、更多配置说明" class="headerlink" title="三、更多配置说明"></a>三、更多配置说明</h2><p>除了<code>yapiToken</code>，插件还支持一些其它配置，完整版的配置示例如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>yapiUrl</span><span class="token punctuation">></span></span>http://yapi.itcjf.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>yapiUrl</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- yapi 平台地址，可以不填写，默认是公司的平台地址 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>yapiToken</span><span class="token punctuation">></span></span>a7106c02912fff91858cf721175ea16b99bff8141c29aaa1da1d4020c5d7053f<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>yapiToken</span><span class="token punctuation">></span></span> <span class="token comment">&lt;!-- 所属项目，必录 --></span>    <span class="token comment">&lt;!-- 可选的，远程的字典目录，可以用它翻译公共的字段，避免重复写注释 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dictionaryUrl</span><span class="token punctuation">></span></span>        http://gitserver/ypk15904/biz-lw-factory-web-api-doc/raw/master/biz-lw-factory-web.properties    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dictionaryUrl</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 可选的，免费的百度翻译API参数，需要自行注册使用，当代码注释、远程字典都翻译失败时，将使用它 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baiduTransAppId</span><span class="token punctuation">></span></span>20200712000517786<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baiduTransAppId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>baiduTransKey</span><span class="token punctuation">></span></span>6RoUOwrR86lK8X_kWYC3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>baiduTransKey</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 可选的，默认开启三种类型的扫描 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scanScope</span><span class="token punctuation">></span></span>spring-mvc,xpro-rpc,abstract-class<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scanScope</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 可选的，指定拥有共同父类的API接口 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>abstractMethod</span><span class="token punctuation">></span></span>com.ly.api.doc.maven.handler.AbstractHandler#handle<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>abstractMethod</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 可选的，指定想要排除的包，被排除后将不再生成该包下的API接口 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>excludePackages</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param</span><span class="token punctuation">></span></span>com.ly.api.doc.maven.excludepackage2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param</span><span class="token punctuation">></span></span>com.ly.api.doc.maven.excludepackage3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>excludePackages</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 可选的，指定想要排除的类，被排除后将不再生成该类下的API接口 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>excludeClassNames</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param</span><span class="token punctuation">></span></span>com.ly.api.doc.maven.handler.Sample2Handler<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>excludeClassNames</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 可选的，默认情况下插件仅解析当前项目中的源文件，通过该配置可以扩大参数的解析范围 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>extraParamsPackages</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param</span><span class="token punctuation">></span></span>com.ly.fn.biz.lw.linen.api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>extraParamsPackages</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="附：已知缺陷说明："><a href="#附：已知缺陷说明：" class="headerlink" title="附：已知缺陷说明："></a>附：已知缺陷说明：</h2><ol><li>对泛型支持有限，仅支持集合类(Collection、List、Set)中使用泛型； 不支持集合中嵌套集合，如List&lt;List<String>&gt;</li><li>对数组支持有限，推荐使用集合类(Collection、List、Set)</li><li>不支持单个文件的文档更新，每次都是全量更新，所以更新文档前需要保持本地代码是最新的</li></ol><h2 id="附：2-0版本展望："><a href="#附：2-0版本展望：" class="headerlink" title="附：2.0版本展望："></a>附：2.0版本展望：</h2><ol><li>maven插件只能批量操作，计划增加IDEA插件，以支持单文件操作</li><li>导入Yapi时，支持为接口分类、排序</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>文档自动化生成设计</title>
      <link href="/2020/06/18/project/auto-doc-design/"/>
      <url>/2020/06/18/project/auto-doc-design/</url>
      
        <content type="html"><![CDATA[<p>文档自动化生成组件，有如下几个设计目标：</p><ol><li><strong>配置足够少</strong>，上手简单，默认配置能满足大部分场景</li><li><strong>非侵入式</strong>，不用修改现有代码</li><li><strong>方式灵活</strong>，支持批量操作和单个操作</li><li><strong>代码即文档</strong>，将代码里所有的注释转化到文档里(<strong>即使是非文档注释</strong>)</li></ol><h2 id="1-支持的检测范围"><a href="#1-支持的检测范围" class="headerlink" title="1. 支持的检测范围"></a>1. 支持的检测范围</h2><p>基于对公司现状的了解，应该至少支持如下几种扫描范围的选择方式：</p><ol><li>对 <code>@Controller</code> <code>@RestController</code> 扫描</li><li>对 <code>@RpcService</code> 扫描</li><li>对 <code>XxxHandler</code> 扫描，真实场景是使用code对http请求进行转发，每个code对应一个接口，通常它们都有一个共同的父类</li></ol><p>因此检测范围的配置，需要非常灵活；maven插件的配置是写在pom.xml中；IDEA&#x2F;Eclipse插件配置是在软件配置界面中。</p><h2 id="2-组件划分"><a href="#2-组件划分" class="headerlink" title="2. 组件划分"></a>2. 组件划分</h2><p><img src="/images/2024/05/zjhf.png" alt="组件划分"></p><h2 id="3-技术实现"><a href="#3-技术实现" class="headerlink" title="3. 技术实现"></a>3. 技术实现</h2><p>接口解析：提供三种不同客户端，分别需要对接它们的API；虽然API不同，但应该保证最终的输出结果一致。</p><p>数据存储：异步将接口信息推送至远程服务进行存储。</p><p>数据输出：根据掌握的接口信息，尽可能全的向yapi写入信息；同时支持覆盖和合并两种策略。输出方式目前仅考虑yapi，markdown和json示例暂缓实现。</p><p><img src="/images/2024/05/sxfs.png" alt="技术实现"></p><h2 id="4-数据结构"><a href="#4-数据结构" class="headerlink" title="4.数据结构"></a>4.数据结构</h2><p>将扫描范围的类，及这些类关联的全部信息，存储到如下数据结构中。</p><p><img src="/images/2020/06/autodoc1.png" alt="数据结构"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>文档自动化生成需求(Java语言)</title>
      <link href="/2020/06/17/project/auto-doc-requirements/"/>
      <url>/2020/06/17/project/auto-doc-requirements/</url>
      
        <content type="html"><![CDATA[<p>一直以来，编写接口文档都是个体力活，市面上也有开源的很多文档自动生成工具，但用起来都不够顺心，社区也不活跃。</p><ol><li>大名鼎鼎的Swagger，需要引入依赖包，引入全新的一套注解，并且只支持http形式的接口。</li><li>非侵入式的，使用Javadoc作为解决方案的开源项目有很多，但都不活跃，支持的功能也各有侧重。</li></ol><span id="more"></span><p>所以，是时候重新造轮子了。我们期望的文档解析模型如下：</p><p><img src="/images/2020/06/autodoc1.png" alt="autodoc1"></p><p>整个过程被分为了两个独立部分：<strong>元数据采集，元数据呈现</strong>，无疑增强了扩展性。</p><p>首先，使用各类客户端插件，获得关注接口的元数据，这份元数据包含类的所有信息，包含类、方法、请求参数、相应参数、注解，注释(文档注释+单行多行注释)等，有了元数据，再为特定的输出方做适配。</p><p>元数据本身也具备一定价值，它不止可以用来生成文档，也可以做其它用途，比如支撑自动化测试等。</p><h2 id="1-元数据采集"><a href="#1-元数据采集" class="headerlink" title="1. 元数据采集"></a>1. 元数据采集</h2><p>对于元数据采集，希望用最简单的方式，采集到足够全的元数据，不同的采集方式罗列如下。</p><p>采集方式 | 范围锁定方式 | 原理 | 特点<br>– | – | –<br>Maven插件 | pom中参数配置 | Javadoc解析、硬解析行注释 | 适合批量更新文档，可以考虑与CICD集成<br>IDEA插件&#x2F;Eclipse插件 | 鼠标选中的类、方法 | IDE提供的API，硬解析行注释 | 适合单个文件处理，更灵活</p><blockquote><p><strong>扫描范围的确认</strong><br/><br>默认情况下，插件应自动扫描被<code>@Controller</code>或<code>@RestController</code>注解的类。<br>支持增加特定的注解，父类、父接口、包，以扩大扫描范围。<br>支持排除特定的注解、类&#x2F;接口、包，以减少扫描范围。</p></blockquote><blockquote><p><strong>注释获取</strong><br/><br>尝试收集所有文档注释、以及部分非文档注释。<br>对于没有注释的类、方法、属性，尝试调用<strong>在线翻译的api</strong>翻译为中文。</p></blockquote><h2 id="2-元数据持久化"><a href="#2-元数据持久化" class="headerlink" title="2. 元数据持久化"></a>2. 元数据持久化</h2><p>这是个可选项，没有数据库，可以让处理速度更快，也更加轻量级。</p><h2 id="3-根据元数据生成文档"><a href="#3-根据元数据生成文档" class="headerlink" title="3. 根据元数据生成文档"></a>3. 根据元数据生成文档</h2><p>生成文档时，增加对javax.validation的支持(支持扩展其它第三方注解)，即对<code>@NotNull</code>等注解的解析反应到文档上。</p><p>对接yapi上传文档时，可以选择覆盖或更新两种策略；通过接口名称前缀，确认当前yapi上是否已存在某个接口。</p><p>默认情况下，一个类对应对应yapi中的一个分类，若果该类中只有一个public方法，则不再增加分类，直接将接口添加到根目录。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>本文简单介绍了对于文档自动化的需求，满足该需求的文档生成工具，应当会比较好用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>宏观调控-金融周期</title>
      <link href="/2020/06/12/jr/jrzq/"/>
      <url>/2020/06/12/jr/jrzq/</url>
      
        <content type="html"><![CDATA[<p>经济周期是一直存在的，它包括复苏，过热，滞涨和衰退。为了对冲经济周期的波动，央行这只看的见得手就得进行宏观调控，而这个宏观调控所产生的周期波动，就叫做金融周期。</p><p>它也分为四个周期，分别是紧货币宽信用，宽货币宽信用，紧货币紧信用，宽货币紧信用。</p><span id="more"></span><h2 id="货币宽松"><a href="#货币宽松" class="headerlink" title="货币宽松"></a>货币宽松</h2><p>货币宽松 &#x3D;&#x3D;&gt; 降低重贴现率、降准备金、逆回购 &#x3D;&#x3D;&gt; 钱发到了银行体系 &#x3D;&#x3D;&gt; 市场钱多了，资金成本降低，市场利率(国债收益率)下行，债券价格上行。</p><h2 id="信用宽松"><a href="#信用宽松" class="headerlink" title="信用宽松"></a>信用宽松</h2><p>什么是信用呢？说白了就是让钱从银行体系中出去，推动社会融资增长。</p><p>信用宽松 &#x3D;&#x3D;&gt; 资金从银行体系流入到实体经济 &#x3D;&#x3D;&gt; 企业有钱了，推动股市、房市、商品上涨</p><p><img src="/images/2020/06/jrzq1.png" alt="jrzq1"></p><p><img src="/images/2020/06/jrzq2.png" alt="jrzq2"></p><p>宽货币有利于债券，宽信用有利于股市。所以往往显示宽货币，再宽信用，然后先紧货币，最后才是紧信用。货币会在信用之前。</p><p><img src="/images/2020/06/jrzq3.png" alt="jrzq3"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了对冲经济周期，央行的主动调整，会引发金融周期。金融周期也是投资的重要依据和指标。</p><p>货币和信用的处理方式，将引导资金的流向，资金流向的地方，也是投资者应该跟进的地方。</p><p><img src="/images/2020/06/jrzq4.png" alt="jrzq4"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jOOQ –通过java语言以最简单的形式写SQL</title>
      <link href="/2020/02/14/db/jooq/"/>
      <url>/2020/02/14/db/jooq/</url>
      
        <content type="html"><![CDATA[<p>当下我们使用的ORM框架中，Hibernate&#x2F;Mybatis占了半边天，它们都有各自的优势和使用场景。</p><p>最近发现了一个之前从来没用的ORM框架jOOQ，非常有意思，为数据处理提供了一种全新的方式。</p><span id="more"></span><h2 id="1-jOOQ是什么"><a href="#1-jOOQ是什么" class="headerlink" title="1. jOOQ是什么"></a>1. jOOQ是什么</h2><p><a href="https://www.jooq.org/">JOOQ(Java Object Oriented Query)</a>是一个开源框架，它可以把数据库模型的基本信息，比如表名，字段名自动生成相应的Java类；并在此基础上提供了一整套数据处理的API。</p><p>Hibernate致力于以面向对象的方式处理数据，隐藏了所有SQL相关处理；Mybatis则是在XML文件中写SQL。</p><p>jOOQ与它们都不同，它致力于通过java语言以最简单的形式写SQL。使用jOOQ DSL(Domain-Specific Language), SQL看起来几乎是由Java本地支持的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">原生<span class="token constant">SQL</span>如下：<span class="token constant">SELECT</span> <span class="token constant">TITLE</span><span class="token constant">FROM</span> <span class="token constant">BOOK</span><span class="token constant">WHERE</span> <span class="token constant">BOOK</span><span class="token punctuation">.</span><span class="token constant">PUBLISHED_IN</span> <span class="token operator">=</span> <span class="token number">2011</span><span class="token constant">ORDER</span> <span class="token constant">BY</span> <span class="token constant">BOOK</span><span class="token punctuation">.</span><span class="token constant">TITLE</span>使用jOOQ写<span class="token constant">SQL</span>的方式如下：create<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token constant">BOOK</span><span class="token punctuation">.</span><span class="token constant">TITLE</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token constant">BOOK</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span><span class="token constant">BOOK</span><span class="token punctuation">.</span><span class="token constant">PUBLISHED_IN</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">orderBy</span><span class="token punctuation">(</span><span class="token constant">BOOK</span><span class="token punctuation">.</span><span class="token constant">TITLE</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>从mvnrepository上查询jOOQ，发现它的第一个版本早在2011年，到现在已经有9个年头了，社区依然活跃。<br>jOOQ之所以诞生，大概是人们厌倦了直接写SQL，用java以流式的方式写SQL，上手成本并不算高，熟练以后应该很舒服。</p></blockquote><h2 id="2-jOOQ解决了什么问题"><a href="#2-jOOQ解决了什么问题" class="headerlink" title="2. jOOQ解决了什么问题"></a>2. jOOQ解决了什么问题</h2><p>jOOQ是将SQL语言集成到Java中的一种简单方法，它使开发人员可以直接用Java快速，安全地编写高质量的SQL，从而使他们可以专注于自己的业务。</p><p>绝大部分数据库函数，都转化为了java方法，使用起来自然方便，它还能进行必要的类型检查，规避了大多数语法错误。</p><p>它有下面这几个优势：</p><ul><li>数据库优先，它不提倡隐藏SQL；与Mybatis一样，以SQL优先，同时可以快速安全的编写SQL。</li><li>类型安全的SQL，它支持列类型检查、行值表达式检查、SQL语法检查。</li><li>代码自动生成，自动生成一份Model类，不需要再手动维护它们。</li><li>SQL标准化，各个数据库方言存在很多细微差别，jOOQ可以自动进行转换</li><li>支持区分不同环境，可以动态切换开发数据库、测试数据库等不同环境的数据库</li><li>查询生命周期，jOOQ不尝试隐藏SQL，围绕整个生命周期开放了接口，我们可以做日志自定义，事件触发，SQL转换等处理。</li><li>支持编写存储过程</li></ul><h2 id="3-更多的例子"><a href="#3-更多的例子" class="headerlink" title="3. 更多的例子"></a>3. 更多的例子</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**  一个复杂的查询SELECT AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME, COUNT(*)FROM AUTHORJOIN BOOK ON AUTHOR.ID = BOOK.AUTHOR_IDWHERE BOOK.LANGUAGE = 'DE'AND BOOK.PUBLISHED > DATE '2008-01-01'GROUP BY AUTHOR.FIRST_NAME, AUTHOR.LAST_NAMEHAVING COUNT(*) > 5ORDER BY AUTHOR.LAST_NAME ASC NULLS FIRSTLIMIT 2OFFSET 1**/</span>create<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token constant">AUTHOR</span><span class="token punctuation">.</span><span class="token constant">FIRST_NAME</span><span class="token punctuation">,</span> <span class="token constant">AUTHOR</span><span class="token punctuation">.</span><span class="token constant">LAST_NAME</span><span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token constant">AUTHOR</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token constant">BOOK</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token constant">AUTHOR</span><span class="token punctuation">.</span><span class="token constant">ID</span><span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token constant">BOOK</span><span class="token punctuation">.</span><span class="token constant">AUTHOR_ID</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span><span class="token constant">BOOK</span><span class="token punctuation">.</span><span class="token constant">LANGUAGE</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"DE"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token constant">BOOK</span><span class="token punctuation">.</span><span class="token constant">PUBLISHED</span><span class="token punctuation">.</span><span class="token function">gt</span><span class="token punctuation">(</span><span class="token function">date</span><span class="token punctuation">(</span><span class="token string">"2008-01-01"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">groupBy</span><span class="token punctuation">(</span><span class="token constant">AUTHOR</span><span class="token punctuation">.</span><span class="token constant">FIRST_NAME</span><span class="token punctuation">,</span> <span class="token constant">AUTHOR</span><span class="token punctuation">.</span><span class="token constant">LAST_NAME</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">having</span><span class="token punctuation">(</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">gt</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">orderBy</span><span class="token punctuation">(</span><span class="token constant">AUTHOR</span><span class="token punctuation">.</span><span class="token constant">LAST_NAME</span><span class="token punctuation">.</span><span class="token function">asc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nullsFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">offset</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//类型检查</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>a<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token function">select</span><span class="token punctuation">(</span>t2<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Type-check here: ---------------> ^^^^</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>a<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token function">select</span><span class="token punctuation">(</span>t2<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Type-check here: -------------------> ^^^^</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>a<span class="token punctuation">.</span><span class="token function">in</span><span class="token punctuation">(</span><span class="token function">select</span><span class="token punctuation">(</span>t2<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Type-check here: ---------------> ^^^^</span><span class="token comment">//表达式类型检查</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span><span class="token function">row</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>a<span class="token punctuation">,</span> t<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Type-check here: ----------------->  ^^^^</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span><span class="token function">row</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>a<span class="token punctuation">,</span> t<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">overlaps</span><span class="token punctuation">(</span>date1<span class="token punctuation">,</span> date2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Type-check here: ------------------------> ^^^^^^^^^^^^</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span><span class="token function">row</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>a<span class="token punctuation">,</span> t<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">in</span><span class="token punctuation">(</span><span class="token function">select</span><span class="token punctuation">(</span>t2<span class="token punctuation">.</span>x<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Type-check here: -------------------------> ^^^^^^^^^^</span><span class="token function">update</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token function">row</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>a<span class="token punctuation">,</span> t<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">select</span><span class="token punctuation">(</span>t2<span class="token punctuation">.</span>x<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Type-check here: --------------> ^^^^^^^^^^</span><span class="token function">insertInto</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> t<span class="token punctuation">.</span>a<span class="token punctuation">,</span> t<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Type-check here: ---------> ^^^^</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>本文简单介绍了JOOQ以及为什么要使用它，作为一个强力的ORM框架，其从一个新的方向尝试更快更好的编写SQL，很值得我们学习。</p><p>本文并没有一步一步的写出可运行的示例，因为这个过程本身很简单，没有必要占篇幅。</p><p>当然各位也可以参考这个项目<a href="https://gitee.com/ypk1226/jOOQ-spring-boot-example">jOOQ-spring-boot-example</a>，它是从官方示例中剥离出来的，导入IDEA后可以直接运行。</p>]]></content>
      
      
      <categories>
          
          <category> ORMS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>温故知新--深入理解List</title>
      <link href="/2019/12/13/java/list/"/>
      <url>/2019/12/13/java/list/</url>
      
        <content type="html"><![CDATA[<p>对于Java的集合认知一直以来都不够清晰，现在特地对<code>List</code>做一次总结，以加深印象。</p><span id="more"></span><p><code>Map</code>接口位于java.util包下，该包下一共提供了如下具体的实现类(基于JDK1.8)，java.util包中开放的实现类如下图所示：</p><p><img src="/images/2019/12/map2.png" alt="Map"></p><p>涉及的接口和抽象类有如下几个：</p><p>名称 | 说明<br>– | – | –<br>Map | 提供存放键值对的对象，要求key不能重复，包含get、put等方法<br>SortedMap | 提供有序的Map<br>NavigableMap | 在 SortedMap 基础上，支持快速搜索符合条件的最近的元素<br>ConcurrentMap | 提供线程安全和原子性的Map<br>ConcurrentNavigableMap | 继承自NavigableMap和ConcurrentMap，提供线程安全的同时，支持快速搜索<br>AbstractMap | 提供Map接口的框架实现</p><blockquote><p><strong><code>AbstractMap</code></strong><br>如果想要开发自定义的Map，建议扩展AbstractMap，其中提供了一些默认实现。除了 Hashtable 和 Properties，其它实现类都继承自AbstractMap。</p></blockquote><p>实现类供有10个，整理如下：</p><table><thead><tr><th>名称</th><th>数据结构</th><th>初始化容量</th><th>扩容方式</th><th>适用场景</th></tr></thead><tbody><tr><td>HashMap</td><td>数组 + 链表 + 红黑树</td><td>16</td><td>个数超过负载因子(默认0.75)指定值时，扩容2倍</td><td>不保证读取顺序与写入数据一致</td></tr><tr><td>LinkedHashMap</td><td>双向链表 +（数组 + 链表 + 红黑树）</td><td>同HashMap</td><td>同HashMap</td><td>继承自HashMap，保证读取顺序与写入数据一致</td></tr><tr><td>IdentityHashMap</td><td>数组</td><td>16</td><td>超出容量时，扩容2倍</td><td>不使用equals比较key，直接使用&#x3D;&#x3D;比较key，因此不存在哈希冲突的问题，key和value相邻存储，存储16个元素时数组长度为32</td></tr><tr><td>TreeMap</td><td>红黑树</td><td>0</td><td>无</td><td>自动以key做自然排序，要求key必须实现Comparable接口</td></tr><tr><td>WeakHashMap</td><td>数组 + 单向链表</td><td>16</td><td>个数超过负载因子(默认0.75)指定值时，扩容2倍</td><td>当某个”弱键”不再正常使用时，会从WeakHashMap中被自动移除</td></tr><tr><td>ConcurrentHashMap</td><td>同HashMap</td><td>同HashMap</td><td>同HashMap</td><td>并发场景下的Map</td></tr><tr><td>ConcurrentSkipListMap</td><td>跳表</td><td>0</td><td>无</td><td>并发场景下的有序Map</td></tr><tr><td>EnumMap</td><td>数组</td><td>与Enum个数相同</td><td>无</td><td>当key是枚举类型时，可以使用EnumMap，操作效率更高</td></tr><tr><td>Hashtable</td><td>数组 + 链表</td><td>11</td><td>个数超过负载因子(默认0.75)指定值时，扩容2倍+1</td><td>线程安全的Map，目前已废弃</td></tr><tr><td>Properties</td><td>同Hashtable</td><td>同Hashtable</td><td>同Hashtable</td><td>继承自Hashtable，用于加载属性配置文件</td></tr></tbody></table><p>尝试按照日常的使用频率，做如下分类：</p><table><thead><tr><th>名称</th><th>使用频率</th></tr></thead><tbody><tr><td>HashMap、ConcurrentHashMap</td><td>高</td></tr><tr><td>LinkedHashMap、TreeMap</td><td>中</td></tr><tr><td>IdentityHashMap、WeakHashMap、ConcurrentSkipListMap、EnumMap</td><td>低</td></tr><tr><td>Hashtable、Properties</td><td>极低</td></tr></tbody></table><p>HashMap无疑是最热门的类，本文将继续详细介绍这个类。</p><h2 id="1-hash相关的概念"><a href="#1-hash相关的概念" class="headerlink" title="1. hash相关的概念"></a>1. hash相关的概念</h2><p>为了更好的理解HashMap和ConcurrentHashMap，这里先介绍下hash相关的概念。</p><p><strong>哈希(hash)</strong></p><p>Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入通过<strong>散列算法</strong>变换成固定长度的输出，转换过程称为<strong>散列函数</strong>或<strong>哈希函数</strong>，转换结果就是散列值，也叫hash code或index。</p><p><strong>哈希表(hash table)</strong></p><p>哈希表（hash table，也叫散列表），是根据键（key）直接访问访问在内存储存位置的数据结构。 哈希表本质是一个数组，数组中的每一个元素成为一个箱子，箱子中存放的是键值对。</p><blockquote><p>哈希桶(hash bucket)，其中存储了hash code对应的所有数据；每个桶中包含了多个槽(slot)，即每个hash code可以对应多条数据。</p></blockquote><p>优点：哈希表可以提供快速的操作。</p><p>缺点：哈希表通常是基于数组的，数组创建后难于扩展。 也没有一种简便的方法可以以任何一种顺序〔例如从小到大）遍历表中的数据项。</p><p><strong>哈希冲突(hash collision)</strong></p><p>由于哈希算法被计算的数据是无限的，而计算后的结果范围有限，因此总会存在不同的数据经过计算后得到的值相同，这就是哈希冲突。</p><p>在Java语言中，体现为两个对象进行equals比较时不相等，但它们的hashCode相等。</p><p><strong>哈希拉链法</strong></p><p>由于存在哈希冲突，导致同一个hash code可能对应多条数据；为了解决该问题，将这些hash code相同的数据以链表的形式存储起来，以便正常查找。</p><p>这种处理方式的数据结构，形似一个拉链，因此称为拉链法。</p><p><img src="/images/2019/12/hash-zipper.png" alt="hash-zipper"></p><h2 id="2-HashMap"><a href="#2-HashMap" class="headerlink" title="2. HashMap"></a>2. HashMap</h2><p>HashMap基于哈希表(hash table)的Map接口的实现，它并允许空值和空键。（HashMap 类与Hashtable大致等效，不同之处在于它是不同步的，并且允许为null。）该类不保证映射的顺序，它不能保证顺序会随着时间的推移保持恒定。jdk1.8中的数据结构如下：</p><p><img src="/images/2019/12/map-data-structure.png" alt="map-data-structure"></p><p>数据table即哈希桶数组，数组中每个元素都是一个哈希桶，每个哈希桶中以链表或红黑树的方式存储多个数据。下面从介绍HashMap的哈希函数和扩容机制。</p><h3 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h3><p>HashMap外层结构是一个组数，数组的长度是固定的，需要考虑扩容问题。默认情况下，初始容量为16。</p><p>调用put方法添加元素时的流程如下：</p><p><img src="/images/2019/12/put.png" alt="put"></p><p>其中有几个需要重点关注的步骤：哈希函数、扩容机制。</p><p><strong>哈希函数</strong></p><p>HashMap通过哈希函数计算key的哈希值，达到快速定位数组下标的目的。对于哈希函数，总是希望计算后的结果可以均匀分布在数组中，从而提高存取性能。</p><p>一个优质的哈希函数对于HashMap的性能提升，是至关重要的。</p><p>HashMap中哈希函数的伪代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1. 获得key的哈希值</span><span class="token comment">// int hash ^= (h >>> 20) ^ (h >>> 12);</span><span class="token comment">// hash = h ^ (h >>> 7) ^ (h >>> 4); // 2. jdk1.7中的hash计算方式，对h进行多次右移、异或运算。</span><span class="token keyword">int</span> hash <span class="token operator">=</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2. jdk1.8中的hash计算方式，对h做右移、异或运算</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>table<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">;</span><span class="token comment">//3. 取模运算，获得数组下标</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/2019/12/%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B.png" alt="计算过程"></p><blockquote><p>注意：int类型是一个32位的二进制数。</p></blockquote><p>第一步计算hashCode，不再赘述。</p><p>第二步，jdk1.7的计算方式，保证了对象的hashCode的32位值只要有一位发生改变，整个hash返回值就会改变，高位的变化会反应到低位里。</p><p>第二步，jdk1.8的计算方式，保证了对象的hashCode的高16位的变化能反应到低16位中，相比较而言减少了过多的位运算，是一种折中的设计。</p><p>第三步，HashMap的容量长度固定为2的n次方，当length总是2的n次方时，该计算方式与<code>hash%length</code>相同，即对hash取模，但是&amp;比%效率更高。</p><blockquote><p>HashMap的容量长度固定为2的n次方，是为了用位运算替换%运算，提高效率。<br>另外，当数组长度为2的n次幂时，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀。</p></blockquote><p><strong>扩容机制</strong></p><p>HashMap的扩容需要满足两个条件：当前数据存储的数量（即size()）大小必须大于等于阈值；当前加入的数据是否发生了hash冲突。</p><p>1）创建一个新的Entry空数组，长度是原来的2倍。<br>2）遍历原Entry数组，把所有的Entry重新Hash到新数组里。为什么要重新Hash呢？因为长度扩大以后，Hash的规则也随之改变了。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>本文整理了java.util包下的Map相关类，充分理解他们的适用场景，以便在使用时合理挑选。后面又介绍了HashMap的哈希函数和扩容机制，对HashMap的深入理解，就是对相关数据结构及算法的深入理解。</p><h2 id="参考的文章"><a href="#参考的文章" class="headerlink" title="参考的文章"></a>参考的文章</h2><p><a href="https://zhuanlan.zhihu.com/p/21673805">Java 8系列之重新认识HashMap</a><br><a href="https://www.cnblogs.com/xiaoxi/p/6170590.html">Java集合之LinkedHashMap</a><br><a href="https://www.cnblogs.com/it-deepinmind/p/7309522.html">java中key值可以重复的map：IdentityHashMap</a><br><a href="https://baike.baidu.com/item/Hash/390310">Hash（散列函数）百度百科</a><br><a href="https://cloud.tencent.com/developer/article/1526646">夯实Java基础系列19</a><br><a href="https://juejin.im/post/5c6abfc86fb9a049c04396a7">搞iOS的，面试官问Hash干嘛？原因远比我下面要介绍的多</a><br><a href="https://www.cnblogs.com/tonyluis/p/5671873.html">Java中hashCode()方法以及HashMap()中hash()方法</a></p>]]></content>
      
      
      <categories>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>温故知新--深入理解Map</title>
      <link href="/2019/11/13/java/map/"/>
      <url>/2019/11/13/java/map/</url>
      
        <content type="html"><![CDATA[<p>对于Java的集合认知一直以来都不够清晰，现在特地对<code>Map</code>做一次总结，以加深印象。</p><span id="more"></span><p><code>Map</code>接口位于java.util包下，该包下一共提供了如下具体的实现类(基于JDK1.8)，java.util包中开放的实现类如下图所示：</p><p><img src="/images/2019/12/map2.png" alt="Map"></p><p>涉及的接口和抽象类有如下几个：</p><p>名称 | 说明<br>– | – | –<br>Map | 提供存放键值对的对象，要求key不能重复，包含get、put等方法<br>SortedMap | 提供有序的Map<br>NavigableMap | 在 SortedMap 基础上，支持快速搜索符合条件的最近的元素<br>ConcurrentMap | 提供线程安全和原子性的Map<br>ConcurrentNavigableMap | 继承自NavigableMap和ConcurrentMap，提供线程安全的同时，支持快速搜索<br>AbstractMap | 提供Map接口的框架实现</p><blockquote><p><strong><code>AbstractMap</code></strong><br>如果想要开发自定义的Map，建议扩展AbstractMap，其中提供了一些默认实现。除了 Hashtable 和 Properties，其它实现类都继承自AbstractMap。</p></blockquote><p>实现类供有10个，整理如下：</p><table><thead><tr><th>名称</th><th>数据结构</th><th>初始化容量</th><th>扩容方式</th><th>适用场景</th></tr></thead><tbody><tr><td>HashMap</td><td>数组 + 链表 + 红黑树</td><td>16</td><td>个数超过负载因子(默认0.75)指定值时，扩容2倍</td><td>不保证读取顺序与写入数据一致</td></tr><tr><td>LinkedHashMap</td><td>双向链表 +（数组 + 链表 + 红黑树）</td><td>同HashMap</td><td>同HashMap</td><td>继承自HashMap，保证读取顺序与写入数据一致</td></tr><tr><td>IdentityHashMap</td><td>数组</td><td>16</td><td>超出容量时，扩容2倍</td><td>不使用equals比较key，直接使用&#x3D;&#x3D;比较key，因此不存在哈希冲突的问题，key和value相邻存储，存储16个元素时数组长度为32</td></tr><tr><td>TreeMap</td><td>红黑树</td><td>0</td><td>无</td><td>自动以key做自然排序，要求key必须实现Comparable接口</td></tr><tr><td>WeakHashMap</td><td>数组 + 单向链表</td><td>16</td><td>个数超过负载因子(默认0.75)指定值时，扩容2倍</td><td>当某个”弱键”不再正常使用时，会从WeakHashMap中被自动移除</td></tr><tr><td>ConcurrentHashMap</td><td>同HashMap</td><td>同HashMap</td><td>同HashMap</td><td>并发场景下的Map</td></tr><tr><td>ConcurrentSkipListMap</td><td>跳表</td><td>0</td><td>无</td><td>并发场景下的有序Map</td></tr><tr><td>EnumMap</td><td>数组</td><td>与Enum个数相同</td><td>无</td><td>当key是枚举类型时，可以使用EnumMap，操作效率更高</td></tr><tr><td>Hashtable</td><td>数组 + 链表</td><td>11</td><td>个数超过负载因子(默认0.75)指定值时，扩容2倍+1</td><td>线程安全的Map，目前已废弃</td></tr><tr><td>Properties</td><td>同Hashtable</td><td>同Hashtable</td><td>同Hashtable</td><td>继承自Hashtable，用于加载属性配置文件</td></tr></tbody></table><p>尝试按照日常的使用频率，做如下分类：</p><table><thead><tr><th>名称</th><th>使用频率</th></tr></thead><tbody><tr><td>HashMap、ConcurrentHashMap</td><td>高</td></tr><tr><td>LinkedHashMap、TreeMap</td><td>中</td></tr><tr><td>IdentityHashMap、WeakHashMap、ConcurrentSkipListMap、EnumMap</td><td>低</td></tr><tr><td>Hashtable、Properties</td><td>极低</td></tr></tbody></table><p>HashMap无疑是最热门的类，本文将继续详细介绍这个类。</p><h2 id="1-hash相关的概念"><a href="#1-hash相关的概念" class="headerlink" title="1. hash相关的概念"></a>1. hash相关的概念</h2><p>为了更好的理解HashMap和ConcurrentHashMap，这里先介绍下hash相关的概念。</p><p><strong>哈希(hash)</strong></p><p>Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入通过<strong>散列算法</strong>变换成固定长度的输出，转换过程称为<strong>散列函数</strong>或<strong>哈希函数</strong>，转换结果就是散列值，也叫hash code或index。</p><p><strong>哈希表(hash table)</strong></p><p>哈希表（hash table，也叫散列表），是根据键（key）直接访问访问在内存储存位置的数据结构。 哈希表本质是一个数组，数组中的每一个元素成为一个箱子，箱子中存放的是键值对。</p><blockquote><p>哈希桶(hash bucket)，其中存储了hash code对应的所有数据；每个桶中包含了多个槽(slot)，即每个hash code可以对应多条数据。</p></blockquote><p>优点：哈希表可以提供快速的操作。</p><p>缺点：哈希表通常是基于数组的，数组创建后难于扩展。 也没有一种简便的方法可以以任何一种顺序〔例如从小到大）遍历表中的数据项。</p><p><strong>哈希冲突(hash collision)</strong></p><p>由于哈希算法被计算的数据是无限的，而计算后的结果范围有限，因此总会存在不同的数据经过计算后得到的值相同，这就是哈希冲突。</p><p>在Java语言中，体现为两个对象进行equals比较时不相等，但它们的hashCode相等。</p><p><strong>哈希拉链法</strong></p><p>由于存在哈希冲突，导致同一个hash code可能对应多条数据；为了解决该问题，将这些hash code相同的数据以链表的形式存储起来，以便正常查找。</p><p>这种处理方式的数据结构，形似一个拉链，因此称为拉链法。</p><p><img src="/images/2019/12/hash-zipper.png" alt="hash-zipper"></p><h2 id="2-HashMap"><a href="#2-HashMap" class="headerlink" title="2. HashMap"></a>2. HashMap</h2><p>HashMap基于哈希表(hash table)的Map接口的实现，它并允许空值和空键。（HashMap 类与Hashtable大致等效，不同之处在于它是不同步的，并且允许为null。）该类不保证映射的顺序，它不能保证顺序会随着时间的推移保持恒定。jdk1.8中的数据结构如下：</p><p><img src="/images/2019/12/map-data-structure.png" alt="map-data-structure"></p><p>数据table即哈希桶数组，数组中每个元素都是一个哈希桶，每个哈希桶中以链表或红黑树的方式存储多个数据。下面从介绍HashMap的哈希函数和扩容机制。</p><h3 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h3><p>HashMap外层结构是一个组数，数组的长度是固定的，需要考虑扩容问题。默认情况下，初始容量为16。</p><p>调用put方法添加元素时的流程如下：</p><p><img src="/images/2019/12/put.png" alt="put"></p><p>其中有几个需要重点关注的步骤：哈希函数、扩容机制。</p><p><strong>哈希函数</strong></p><p>HashMap通过哈希函数计算key的哈希值，达到快速定位数组下标的目的。对于哈希函数，总是希望计算后的结果可以均匀分布在数组中，从而提高存取性能。</p><p>一个优质的哈希函数对于HashMap的性能提升，是至关重要的。</p><p>HashMap中哈希函数的伪代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1. 获得key的哈希值</span><span class="token comment">// int hash ^= (h >>> 20) ^ (h >>> 12);</span><span class="token comment">// hash = h ^ (h >>> 7) ^ (h >>> 4); // 2. jdk1.7中的hash计算方式，对h进行多次右移、异或运算。</span><span class="token keyword">int</span> hash <span class="token operator">=</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2. jdk1.8中的hash计算方式，对h做右移、异或运算</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>table<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">;</span><span class="token comment">//3. 取模运算，获得数组下标</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/2019/12/%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B.png" alt="计算过程"></p><blockquote><p>注意：int类型是一个32位的二进制数。</p></blockquote><p>第一步计算hashCode，不再赘述。</p><p>第二步，jdk1.7的计算方式，保证了对象的hashCode的32位值只要有一位发生改变，整个hash返回值就会改变，高位的变化会反应到低位里。</p><p>第二步，jdk1.8的计算方式，保证了对象的hashCode的高16位的变化能反应到低16位中，相比较而言减少了过多的位运算，是一种折中的设计。</p><p>第三步，HashMap的容量长度固定为2的n次方，当length总是2的n次方时，该计算方式与<code>hash%length</code>相同，即对hash取模，但是&amp;比%效率更高。</p><blockquote><p>HashMap的容量长度固定为2的n次方，是为了用位运算替换%运算，提高效率。<br>另外，当数组长度为2的n次幂时，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀。</p></blockquote><p><strong>扩容机制</strong></p><p>HashMap的扩容需要满足两个条件：当前数据存储的数量（即size()）大小必须大于等于阈值；当前加入的数据是否发生了hash冲突。</p><p>1）创建一个新的Entry空数组，长度是原来的2倍。<br>2）遍历原Entry数组，把所有的Entry重新Hash到新数组里。为什么要重新Hash呢？因为长度扩大以后，Hash的规则也随之改变了。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>本文整理了java.util包下的Map相关类，充分理解他们的适用场景，以便在使用时合理挑选。后面又介绍了HashMap的哈希函数和扩容机制，对HashMap的深入理解，就是对相关数据结构及算法的深入理解。</p><h2 id="参考的文章"><a href="#参考的文章" class="headerlink" title="参考的文章"></a>参考的文章</h2><p><a href="https://zhuanlan.zhihu.com/p/21673805">Java 8系列之重新认识HashMap</a><br><a href="https://www.cnblogs.com/xiaoxi/p/6170590.html">Java集合之LinkedHashMap</a><br><a href="https://www.cnblogs.com/it-deepinmind/p/7309522.html">java中key值可以重复的map：IdentityHashMap</a><br><a href="https://baike.baidu.com/item/Hash/390310">Hash（散列函数）百度百科</a><br><a href="https://cloud.tencent.com/developer/article/1526646">夯实Java基础系列19</a><br><a href="https://juejin.im/post/5c6abfc86fb9a049c04396a7">搞iOS的，面试官问Hash干嘛？原因远比我下面要介绍的多</a><br><a href="https://www.cnblogs.com/tonyluis/p/5671873.html">Java中hashCode()方法以及HashMap()中hash()方法</a></p>]]></content>
      
      
      <categories>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java模块化开发通用设计指南</title>
      <link href="/2019/10/28/java/java9-module-design/"/>
      <url>/2019/10/28/java/java9-module-design/</url>
      
        <content type="html"><![CDATA[<p>模块化不仅仅是一个实现问题，也是一个设计和架构的问题。通过模块化，可以应对需求、环境、团队以及其他不可预见事件所带来的变化。</p><p>本章将讨论模块化开发通用设计指南，以提高使用模块所构建系统的可维护性、灵活性和可重用性，这些模式和设计实践中的大部分与技术无关。</p><span id="more"></span><h2 id="1-模块边界"><a href="#1-模块边界" class="headerlink" title="1. 模块边界"></a>1. 模块边界</h2><p>长久以来，将系统划分为小型的、可管理的模块已被认为是一项成功的策略。</p><p>根据D.L.Parnas在1972年的一篇论文中所述，他设计了一种称为Parnas分区（Parnaspartitioning）的模块化方法。通常，在设计模块时可以划分几个参考标准：</p><ul><li>可理解性</li><li>可变性</li><li>可重用性</li><li>团队合作</li></ul><p>当设计重用时，可以考虑以下两点：</p><ul><li>坚持UNIX哲学理念，只做一件事情，并且将其做好。</li><li>将模块本身的依赖关系数量减到最少。否则，所有重用的使用者都要承担可传递依赖关系所带来的负担。</li></ul><h2 id="2-精益化模块-大小"><a href="#2-精益化模块-大小" class="headerlink" title="2. 精益化模块(大小)"></a>2. 精益化模块(大小)</h2><p>需要考虑两个指标：模块公共区域面积（surfacearea）的大小以及内部实现的大小。</p><p>对于公共区域面积，应该使其最小化。而对于内部实现，精益化模块要尽可能独立，在可能的情况下避免依赖于其他模块。</p><p>开发精益化模块与围绕可重用微服务的最佳实践之间存在许多相似的地方：尽可能的小，与外界有定义良好的协议，同时尽可能保持独立。</p><p><strong>精益化模块和微服务</strong></p><p>模块和微服务是互补的概念，微服务很可能在内部使用Java模块来实现。</p><p>两者之间的一个重要区别是，使用模块及其描述符不仅可以明确描述所提供（导出）的内容，还可以明确地描述所需要的内容，因此可以非常安全可靠地解析和链接Java模块系统中的模块，但在大多数微服务环境中却不是这样的。</p><h2 id="3-API模块"><a href="#3-API模块" class="headerlink" title="3. API模块"></a>3. API模块</h2><p>接口是实现API提供者和消费者之间解耦的主要手段，因此尽可能的自包含，不依赖多余的内容。</p><h2 id="4-聚合器模块"><a href="#4-聚合器模块" class="headerlink" title="4. 聚合器模块"></a>4. 聚合器模块</h2><p>使用隐式可读性来构建聚合器模块，其本质上是通过现有的库模块构建一个外观（facade）。聚合器模块不包含代码，它只有一个模块描述符，为所有其他模块设置了隐式可读性。JDK中有两个很好的示例：</p><p><img src="/images/2019/10/jh-module.png" alt="jh-module"></p><h2 id="5-避免循环依赖"><a href="#5-避免循环依赖" class="headerlink" title="5. 避免循环依赖"></a>5. 避免循环依赖</h2><p>一个显而易见的解决方案是将这些JAR合并成一个模块。当两个组件之间存在如此紧密（循环）的关系时，就可以断定它们是一个模块的。当然，该解决方案的前提是循环关系是良性的。当循环是间接的并且涉及多个组件（而不仅仅是两个组件）时，该方案就行不通了，除非想要合并参与循环的所有组件，但这不太可能。</p><p>通常，存在循环说明设计是有问题的，这意味着需要进行一些重新设计来打破这个循环。常言道，计算机科学的一切问题都可以通过引入另一个间接层来解决（当然更多的间接层也会出现问题）。</p><p>该<a href="https://github.com/java9-modularity/examples/tree/master/chapter5/cyclic_dependencies">示例</a>中使用了一个中间层<code>Named</code>接口，解决了<code>Author</code>和<code>Book</code>的循环依赖问题。</p><blockquote><p>当循环是间接的，并且通过很多步骤产生时，它们可能很难被发现，此时可以使用工具（如SonarQube）帮助检测现有代码中的循环依赖。</p></blockquote><h2 id="6-可选的依赖关系"><a href="#6-可选的依赖关系" class="headerlink" title="6. 可选的依赖关系"></a>6. 可选的依赖关系</h2><p>模块化应用程序的标志之一是其显式的依赖关系图。但如果一个模块在运行时不是绝对需要的，那么又该怎么办呢？</p><p>一种方式是使用<code>static</code>关键字，指定该模块是编译时依赖关系，即该模块<strong>只能在编译时使用</strong>，无法在运行时使用；应用程序可以通过<code>try catch</code>和<code>Class.forName</code>的方式，对依赖的模块进行检测，以决定应该使用哪个模块。</p><p>这种依赖关系检测往往意味着大量的检测，使用起来比较痛苦，并不是解耦的最佳方式。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">module</span> <span class="token namespace">framework</span><span class="token punctuation">&#123;</span>  <span class="token keyword">requires</span> <span class="token keyword">static</span> fastjsonlib<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>另外一种方式是使用服务(Service)，为所有可选的实现制定一套通过的API，可以实现完美的解耦；缺点是必须要对现有代码改造。</p><h2 id="7-版本化"><a href="#7-版本化" class="headerlink" title="7. 版本化"></a>7. 版本化</h2><p>模块完全是由名称进行解析的，模块解析期间忽略版本，这是Java模块系统中一个慎重的设计选择。</p><p>版本配置一直以来是一个复杂的问题，不管采用什么策略，都会在模块系统中变得根深蒂固，因此也会深入到编译器、语言规范和JVM中。模块版本的选择权，仍然由构建工具决定，如Maven和Gradle。</p><p>在应用程序开发中，强烈建议找到一种统一依赖于单个模块版本的方法，避免同时使用多个版本。通常，运行同一模块的多个并发版本的原因是因为懒惰，而不是迫切需要。</p><h2 id="8-资源封装"><a href="#8-资源封装" class="headerlink" title="8. 资源封装"></a>8. 资源封装</h2><p>模块中除了Java代码，还有很多资源文件，比如包含翻译（本地化资源包）的文件、配置文件等；模块封装了这些资源的访问，限制了跨模块资源访问。</p><p>访问本模块资源的方式有如下几种，其中以<code>Module</code>的方式获取是新增的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">ResourcesInModule</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span class="token class-name">InputStream</span> cz_pkg <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"resource_in_package.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&lt;1></span><span class="token class-name">URL</span> cz_tl <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token string">"/top_level_resource.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&lt;2></span><span class="token class-name">Module</span> m <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getModule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&lt;3></span><span class="token class-name">InputStream</span> m_pkg <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span>  <span class="token string">"javamodularity/firstresourcemodule/resource_in_package.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&lt;4></span><span class="token class-name">InputStream</span> m_tl <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"top_level_resource.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&lt;5></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>跨模块强行访问资源，一些场景下虽然是允许的，但是并不推荐；如果确实需要来自其他模块的资源，可以考虑通过使用导出类中的方法或使用服务来公开资源的内容。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//跨模块访问获得Module</span><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Module</span><span class="token punctuation">></span></span> otherModule <span class="token operator">=</span> <span class="token class-name">ModuleLayer</span><span class="token punctuation">.</span><span class="token function">boot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findModule</span><span class="token punctuation">(</span><span class="token string">"secondresourcemodule"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&lt;1></span>otherModule<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>other <span class="token operator">-></span> <span class="token punctuation">&#123;</span>   <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//下面三种方式，可以正常获得资源，它分为三类：模块顶级目录中的资源、非包目录下的资源、所有的class文件</span>      <span class="token class-name">InputStream</span> m_tl <span class="token operator">=</span> other<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"top_level_resource2.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&lt;2></span>      <span class="token class-name">InputStream</span> m_class <span class="token operator">=</span> other<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span>              <span class="token string">"javamodularity/secondresourcemodule/A.class"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&lt;4></span>      <span class="token class-name">InputStream</span> m_meta <span class="token operator">=</span> other<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"META-INF/resource_in_metainf.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&lt;5></span>      <span class="token comment">//下面两种方式，都无法获得资源。模块对包路径中的资源时强封装的。</span>      <span class="token class-name">InputStream</span> m_pkg <span class="token operator">=</span> other<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span>          <span class="token string">"javamodularity/secondresourcemodule/resource_in_package2.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&lt;3></span>      <span class="token class-name">InputStream</span> cz_pkg <span class="token operator">=</span>        <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"javamodularity.secondresourcemodule.A"</span><span class="token punctuation">)</span>             <span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"resource_in_package2.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&lt;6></span>      <span class="token keyword">assert</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>m_tl<span class="token punctuation">,</span> m_class<span class="token punctuation">,</span> m_meta<span class="token punctuation">)</span>                   <span class="token punctuation">.</span><span class="token function">noneMatch</span><span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token operator">::</span><span class="token function">isNull</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">assert</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>m_pkg<span class="token punctuation">,</span> cz_pkg<span class="token punctuation">)</span>                   <span class="token punctuation">.</span><span class="token function">allMatch</span><span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token operator">::</span><span class="token function">isNull</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>也可以通过使用开放式模块（open module）或开放式包（open package），向其他模块公开包中封装的资源。</p></blockquote><h2 id="9-小结"><a href="#9-小结" class="headerlink" title="9. 小结"></a>9. 小结</h2><p>模块化可能是Java有史以来最大的Feature，它将自己长期依赖All-in-one&#x2F;Environment的结构，转变为以Module基础的组件。</p><p>其影响范围不仅仅是代码层面，它将影响设计、编译、打包、部署等过程；本文讨论的这些通用模式，是以模块为基础的系统在设计时常常要考虑的。</p><h2 id="参考的文章"><a href="#参考的文章" class="headerlink" title="参考的文章"></a>参考的文章</h2><p><a href="https://www.amazon.cn/dp/B07F6Y9L4K/ref=sr_1_2?__mk_zh_CN=%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%BD%91%E7%AB%99&keywords=java+9&qid=1571215579&sr=8-2">Java 9模块化开发：核心原则与实践 (O’Reilly精品图书系列)</a></p>]]></content>
      
      
      <categories>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java模块系统介绍</title>
      <link href="/2019/10/16/java/java9-module/"/>
      <url>/2019/10/16/java/java9-module/</url>
      
        <content type="html"><![CDATA[<p>上篇文章介绍了什么是模块化，以及Java模块化解决的问题。本文将介绍Java模块化的相关概念及具体写法。本文将从如下两个方面介绍模块化：</p><ol><li>模块描述符</li><li>服务</li></ol><span id="more"></span><h2 id="1-模块描述符"><a href="#1-模块描述符" class="headerlink" title="1. 模块描述符"></a>1. 模块描述符</h2><p>为了体现模块之间的关系，必须定义全新的模块描述文件，类似于Maven中的pom文件，Java9称之为模块描述符。</p><p>模块描述符是一个固定名称的java文件，所有的模块描述符文件名称固定位 <strong>module-info.java</strong>，其内部存在特定的结构。</p><p>下面是两个示例，其中<code>easytext.cli</code>模块依赖<code>easytext.analysis</code>模块。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">module</span> <span class="token namespace">easytext<span class="token punctuation">.</span>analysis</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">exports</span> <span class="token namespace">javamodularity<span class="token punctuation">.</span>easytext<span class="token punctuation">.</span>analysis</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">module</span> <span class="token namespace">easytext<span class="token punctuation">.</span>cli</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">requires</span> <span class="token namespace">easytext<span class="token punctuation">.</span>analysis</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面示例中一共有三个新增的关键字，这三个关键字也是模块化系统中最常用的关键字。</p><ol><li>module: 用来定义一个模块，后面紧跟模块名称，在同一个模块路径下，模块名称不允许相同。</li><li>exports: 用来指定开放那个包作为API供外部调用，没有开放的api不允许被调用。</li><li>requires: 用来执行依赖的模块，依赖必须显示指定。</li></ol><p>通过exports和requires的配合使用，达到模块化的目的，即强封装、显式依赖。</p><p>为了描述这种依赖关系，Java9新增了一个概念，名为<code>可读性（readability）</code>，<code>easytext.cli</code>模块依赖<code>easytext.analysis</code>模块，也可以说 <code>easytext.cli</code>模块可以读取<code>easytext.analysis</code>模块。</p><blockquote><p><strong>模块路径(module path) 和 类路径(class path)</strong><br/></p><p>类路径(class path)是指Java编译和运行的基础目录，类路径下所有文件都是平行的，不存在层级关系，一旦服务启动，所有类都可能会被加载。<br>模块路(module path)径是指存放Java模块的目录，并不是模块路径下的所有模块都会被加载，其以根模块(root module)为起点，使用模块描述符递归查找依赖的模块，它存在层级关系，是一个树状结构。</p></blockquote><blockquote><p><strong>可读性(readability) 和 可访问性(accessible)</strong><br/></p><p>可访问性(accessible)是指public、protected、(default)、private这四个级别，它们作用在类与类之间，提供访问控制。<br>可读性(readability)则提供模块与模块之间的访问控制，是对可访问性的功能补充。<br>可读性(readability)不止作用于运行阶段，与可访问性一样也作用于编译阶段，即未明确指定依赖的模块，编译将直接报错。</p></blockquote><p><strong>隐式可读性</strong></p><p>有时候简单的依赖关系不能满足一些特定场景，比如依赖传递特性。模块化系统通过<code>transitive</code>关系字，解决依赖的传递问题，这也称为<code>隐式可读性</code>。</p><p>如下所示，<code>java.se</code>模块中隐式依赖了一些模块，当其它模块依赖<code>java.se</code>时，会自动依赖这些模块。通过隐式可读性，我们可以聚合不同的模块，为模块分组，<code>java.se</code>就是一个最常用的模块组合。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">module</span> <span class="token namespace">java<span class="token punctuation">.</span>se</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">requires</span> <span class="token keyword">transitive</span> <span class="token namespace">java<span class="token punctuation">.</span>desktop</span><span class="token punctuation">;</span>  <span class="token keyword">requires</span> <span class="token keyword">transitive</span> <span class="token namespace">java<span class="token punctuation">.</span>sql</span><span class="token punctuation">;</span>  <span class="token keyword">requires</span> <span class="token keyword">transitive</span> <span class="token namespace">java<span class="token punctuation">.</span>xml</span><span class="token punctuation">;</span>  <span class="token comment">// 省略</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>限制导出</strong></p><p>在某些情况下，可能只需要将包暴露给特定的某些模块。此时，可以在模块描述符中使用限制导出。可以在java.xml模块中找到限制导出的示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">module</span> <span class="token namespace">java<span class="token punctuation">.</span>xml</span><span class="token punctuation">&#123;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">exports</span> <span class="token namespace">com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>writers</span> <span class="token keyword">to</span> <span class="token namespace">java<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>ws</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般来说，<strong>应该避免在模块之间使用限制导出</strong>。使用限制导出意味着在导出模块和允许的使用者之间建立了直接的联系。该特性最大的目的是为了处理历史问题，如对旧版本JDK模块化。</p><h2 id="2-服务-Service"><a href="#2-服务-Service" class="headerlink" title="2. 服务(Service)"></a>2. 服务(Service)</h2><p>应用程序模块化后，被exports的包，通常仅包含接口，不包含具体实现，且实现类的个数可能是一个或多个。</p><p>为了充分解耦，接口的实现类不能由客户端创建，仅能由服务端提供，即<code>Analyzer analyzer = ???</code>。对于这种情况，工厂模式是一个方案。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnalyzerFactory</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">getSupportedAnalyses</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">return</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token class-name">FleschKincaid</span><span class="token punctuation">.</span><span class="token constant">NAME</span><span class="token punctuation">,</span> <span class="token class-name">Coleman</span><span class="token punctuation">.</span><span class="token constant">NAME</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Analyzer</span> <span class="token function">getAnalyzer</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">switch</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">case</span> <span class="token class-name">FleschKincaid</span><span class="token punctuation">.</span><span class="token constant">NAME</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FleschKincaid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">case</span> <span class="token class-name">Coleman</span><span class="token punctuation">.</span><span class="token constant">NAME</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Coleman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">default</span><span class="token operator">:</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"No such analyzer!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过引入工厂模式，客户端只需获得服务名称列表后，根据名称选择使用哪个服务即可，而无需知道具体的实现类。</p><p>当我们想为<code>Analyzer</code>增加一个实现类时，必须要修改<code>AnalyzerFactory</code>才能实现，这违背了开闭原则。同时<code>AnalyzerFactory</code>自身也必须依赖所有的实现，这样exports的包中也包含了实现类。</p><p>为了解决这个问题，模块化系统提供了服务(Service)的功能。通过使用<code>ServiceLoader API</code>可在模块描述符和代码中表示服务。</p><p>服务提供者的模块描述符如下，通过<code>provides with</code>关键字，确定了接口的实现类。可以通过<code>ServiceLoader.load</code>的方式获得所有的<code>Analyzer</code>实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">module</span> <span class="token namespace">easytext<span class="token punctuation">.</span>analysis<span class="token punctuation">.</span>coleman</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">requires</span> <span class="token namespace">easytext<span class="token punctuation">.</span>analysis<span class="token punctuation">.</span>api</span><span class="token punctuation">;</span>  <span class="token keyword">provides</span> <span class="token namespace">javamodularity<span class="token punctuation">.</span>easytext<span class="token punctuation">.</span>analysis<span class="token punctuation">.</span>api<span class="token punctuation">.</span></span><span class="token class-name">Analyzer</span>      <span class="token keyword">with</span>        <span class="token namespace">javamodularity<span class="token punctuation">.</span>easytext<span class="token punctuation">.</span>analysis<span class="token punctuation">.</span>coleman<span class="token punctuation">.</span></span><span class="token class-name">ColemanAnalyzer</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Analyzer</span> <span class="token punctuation">&#123;</span>   <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">double</span> <span class="token function">analyze</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> text<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">static</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Analyzer</span><span class="token punctuation">></span></span> <span class="token function">getAnalyzers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">return</span> <span class="token class-name">ServiceLoader</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Analyzer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端的模块描述符如下，通过<code>uses</code>关键字，指定想要使用的接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">module</span> <span class="token namespace">easytext<span class="token punctuation">.</span>cli</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">requires</span> <span class="token namespace">easytext<span class="token punctuation">.</span>analysis<span class="token punctuation">.</span>api</span><span class="token punctuation">;</span>  <span class="token keyword">uses</span> <span class="token namespace">javamodularity<span class="token punctuation">.</span>easytext<span class="token punctuation">.</span>analysis<span class="token punctuation">.</span>api<span class="token punctuation">.</span></span><span class="token class-name">Analyzer</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Analyzer</span><span class="token punctuation">></span></span> analyzers <span class="token operator">=</span> <span class="token class-name">Analyzer</span><span class="token punctuation">.</span><span class="token function">getAnalyzers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果存在多个提供者，但只对“最好的”实现感兴趣，该怎么做呢？Java模块系统不可能知道哪个实现最合适，所以只能由应用程序自己决定。</p><blockquote><p><strong>服务绑定的模块解析</strong><br/></p><p>服务的<code>provides with</code>为解析过程添加了另一个维度。模块路径中使用<code>provides with</code>关键字的模块，将被自动加载，而无需再使用<code>requires</code>显示声明。</p></blockquote><blockquote><p><strong>服务(Service)是可选的</strong><br/></p><p>与<code>requires</code>和<code>exports</code>不同，服务(Service)是可选的，只有在需要的时候采用即可。</p></blockquote><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>本文介绍了Java模块化的基本使用方式，过程中涉及的关键字汇总如下。</p><table><thead><tr><th>关键字</th><th>描述</th></tr></thead><tbody><tr><td><code>module</code></td><td>声明模块名称，在模块路径下，模块名称必须是唯一的。</td></tr><tr><td><code>requires</code></td><td>声明依赖的模块，只有模块被依赖后才能正常使用。</td></tr><tr><td><code>transitive</code></td><td>跟随<code>requires</code>使用，时依赖可以传递。</td></tr><tr><td><code>exports</code></td><td>声明当前模块开放的package，只有被开放的package才能正常使用。</td></tr><tr><td><code>uses</code></td><td>声明要使用的服务，该关键字没有<code>requires</code>的功能，必须单独声明<code>requires</code>指定<code>uses</code>接口的所在的模块。</td></tr><tr><td><code>provides with</code></td><td>声明服务的提供者，模块解析过程中，将自动解析服务提供者所在的模块，类似服务提供者被<code>requires</code>了。</td></tr></tbody></table><h2 id="参考的文章"><a href="#参考的文章" class="headerlink" title="参考的文章"></a>参考的文章</h2><p><a href="https://www.amazon.cn/dp/B07F6Y9L4K/ref=sr_1_2?__mk_zh_CN=%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%BD%91%E7%AB%99&keywords=java+9&qid=1571215579&sr=8-2">Java 9模块化开发：核心原则与实践 (O’Reilly精品图书系列)</a><br><a href="https://github.com/java9-modularity/examples">java9-modularity&#x2F;examples</a></p>]]></content>
      
      
      <categories>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 9 新特性概述</title>
      <link href="/2019/09/14/java/java9/"/>
      <url>/2019/09/14/java/java9/</url>
      
        <content type="html"><![CDATA[<p>Java9正式发布于2017年9月21日，作为Java8之后3年半才发布的新版本，Java9带来了很多重大的变化，其中最重要的改动是Java模块化的引入。</p><p>本文对Java9中包含的新特性做了概括性的介绍，可以帮助你快速了解Java9。</p><span id="more"></span><h2 id="1-模块化概述"><a href="#1-模块化概述" class="headerlink" title="1. 模块化概述"></a>1. 模块化概述</h2><h3 id="1-1-什么是模块化"><a href="#1-1-什么是模块化" class="headerlink" title="1.1 什么是模块化"></a>1.1 什么是模块化</h3><p>模块化（modularization）是指将系统分解成独立且相互连接的模块的行为。模块化不仅仅是一个实现问题（该问题可通过引入新的语言特性来缓解），也是一个设计和架构的问题。应用模块化设计是一项长期的投资。通过模块化，可以应对需求、环境、团队以及其他不可预见事件所带来的变化。</p><p>模块（module）是包含代码的可识别工件，使用了元数据来描述模块及其与其他模块的关系。在理想情况下，这些工件从编译时到运行时都是可识别的。一个应用程序由多个模块协作组成。模块必须遵循以下三个核心原则：</p><p><strong>1. 强封装性</strong></p><p>一个模块必须能够对其他模块隐藏其部分代码。这样一来，就可以在可公开使用的代码和被视为内部实现细节的代码之间划定一条清晰的界限，从而防止模块之间发生意外或不必要的耦合，即无法使用被封装的内容。</p><p><strong>2. 定义良好的接口</strong></p><p>没有封装的代码是模块公共API的一部分。由于其他模块可以使用这些公共代码，因此必须非常小心地管理它们。未封装代码中任何一个重大更改都可能会破坏依赖该代码的其他模块。</p><p><strong>3. 显式依赖</strong></p><p>显式依赖会产生一个模块图：节点表示模块，而边缘表示模块之间的依赖关系。拥有模块图对于了解应用程序以及运行所有必要的模块是非常重要的，它为模块的可靠配置提供了基础。</p><h3 id="1-2-在Java9之前状况"><a href="#1-2-在Java9之前状况" class="headerlink" title="1.2 在Java9之前状况"></a>1.2 在Java9之前状况</h3><p>Java平台在Java9之前的模块化程度确实不尽如人意，下面针对模块化的三个重要特性进行具体分析：</p><p><strong>1 强封装性</strong></p><p>在Java9之前，通过组合使用包（package）和访问修饰符（比如private、protected或public），可以实现类型封装。但对于public类，无法再限制其它类的访问。</p><p><strong>2 定义良好的接口</strong></p><p>在定义良好接口方面，Java自诞生以来就一直做得很好，即Java中的interface关键字。</p><p><strong>3 显式依赖</strong></p><p>Java确实使用了显式的import语句。但从严格意义上讲，这些导入是编译时结构，一旦将代码打包到JAR中，就无法确定哪些JAR包含当前JAR运行所需的类型。</p><p>事实上，这个问题非常糟糕，许多外部工具与Java语言一起发展以解决这个问题：Maven和OSGi。</p><p>使用Maven构建工具所解决的一个问题是实现编译时依赖关系管理。Maven真正成功之处在于生成了一个名为MavenCentral的规范存储库。</p><p>Maven在编译时做了什么，OSGi在运行时就会做什么。它解决了运行时的依赖关系管理。</p><p>这两个工具的处理维度都在JAR这一层，一个jar内如果再细分，它们就无能为力了。</p><p><strong>4 类路径地狱(classpath hell)</strong></p><p>如果在类路径中没有找到所需的类时，会得到一个运行时异常。由于类可以延迟加载，因此只有首次运行应用程序并点击一个按钮时时，才会出现找不到类的情况。</p><p>而当类路径上有重复类时，则会出现更为隐蔽的问题。该类的任一版本都可能会被首先加载，此时就会导致运行时异常。一般来说，当类路径包含两个具有相同名称的类时，即使它们完全不相关，也只有一个会被加载。</p><h2 id="2-Java9的模块化"><a href="#2-Java9的模块化" class="headerlink" title="2. Java9的模块化"></a>2. Java9的模块化</h2><p>Java9之后，强封装性、定义良好的接口以及显式依赖已经成为Java平台的一部分。Java平台模块系统带来了如下最重要的好处：</p><ul><li>可靠的配置</li><li>强封装</li><li>可扩展开发</li><li>安全性</li></ul><p>JDK9模块化后，由如下这些平台模块组成，不再是一个整体库。</p><p><img src="/images/2019/10/java.se.ee-graph.png" alt="java.se.ee-graph"></p><p>上图中的模块都是JavaSE规范的一部分，它们的模块名都是以java.*作为前缀。</p><blockquote><p>通过运行 java –list-modules，可以获取平台模块的完整列表。</p></blockquote><p>将JDK分解成模块需要完成大量的工作。将一个错综复杂、有机发展且包含数以万计类的代码库分解成边界清晰且保持向后兼容性的定义良好的模块需要花费大量的时间，这也就是为什么花了如此长的时间才将模块系统植入到Java中的原因。</p><p>展望未来，这一努力将在JDK的快速发展以及更大灵活性方面得到丰厚的回报。</p><h2 id="3-Java9的其它特性列表"><a href="#3-Java9的其它特性列表" class="headerlink" title="3. Java9的其它特性列表"></a>3. Java9的其它特性列表</h2><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>增加Jshell命令</td><td>jshell为Java增加了类似 NodeJS 和 Python 中的读取-求值-打印循环（ Read-Evaluation-Print Loop ）。</td></tr><tr><td>集合、Stream 和 Optional</td><td>增加了新的方法，List.of()、Set.of()、Map.of() 和 M ap.ofEntries()等工厂方法。</td></tr><tr><td>新增ProcessHandle进程管理</td><td>可以对原生进程进行管理，尤其适合于管理长时间运行的进程。</td></tr><tr><td>改进日志API</td><td>JDK和应用支持配置同样的日志实现，即JDK内部的日志实现也支持配置了。</td></tr><tr><td>集成Reactive Streams</td><td>反应式流规范(Reactive Streams)的核心接口已经添加到了 Java9 中的java.util.concurrent.Flow 类中。</td></tr><tr><td>新增VarHandle变量句柄</td><td>可以对变量进行读取、写入、原子更新、数值原子更新和比特位原子操作等操作，与MethodHandle类似。</td></tr><tr><td>改进MethodHandle方法句柄</td><td>增加了更多的静态方法来创建不同类型的方法句柄。</td></tr><tr><td>改进CompletableFuture</td><td>CompletableFuture 中增加了几个新的方法。</td></tr><tr><td>升级Nashorn</td><td>已经实现了一些 ECMAScript 6 规范中的新特性，包括模板字符串、二进制和八进制字面量、迭代器 和 for..of 循环和箭头函数等。</td></tr><tr><td>改进I&#x2F;O API</td><td>InputStream增加了更加易用的方法。ObjectInputFilter 可以对 ObjectInputStream 中 包含的内容进行检查，来确保其中包含的数据是合法的。</td></tr><tr><td>增加哈希算法</td><td>新增了4个SHA- 3哈希算法，SHA3-224、SHA3-256、SHA3-384 和 S HA3-512。另外也增加了通过 java.security.SecureRandom 生成使用 DRBG 算法的强随机数。</td></tr><tr><td>统一JVM日志</td><td>JVM有了统一的日志记录系统，可以使用新的命令行选项-Xlog来控制JVM上所有组件的日志记录。</td></tr></tbody></table><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>Java9作为一次重大更新，其中的模块系统无疑是对Java影响最大的，它将影响设计、编译、打包、部署等过程。</p><p>本文简单列举了Java9的新特性，使读者对Java9有一个大致印象，以便在开发过程中可以及时联想到这些特性，如果想要查看更详细的内容，可以查阅官方文档。</p><h2 id="参考的文章"><a href="#参考的文章" class="headerlink" title="参考的文章"></a>参考的文章</h2><p><a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-9/index.html">Java 9 新特性概述</a><br><a href="https://zhuanlan.zhihu.com/p/24800180">Java 9的模块化–壮士断”腕”的涅槃</a><br><a href="https://www.amazon.cn/dp/B07F6Y9L4K/ref=sr_1_2?__mk_zh_CN=%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%BD%91%E7%AB%99&keywords=java+9&qid=1571215579&sr=8-2">Java 9模块化开发：核心原则与实践 (O’Reilly精品图书系列)</a></p>]]></content>
      
      
      <categories>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project Reactor介绍</title>
      <link href="/2019/08/02/reactive/project-reactor/"/>
      <url>/2019/08/02/reactive/project-reactor/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章中，我们介绍了Reactive Streams规范，现在学习一个Reactive Streams规范的流行实现：<code>Project Reactor</code>的核心项目<code>Reactor Core</code>。</p><span id="more"></span><h2 id="1-Project-Reactor-简介"><a href="#1-Project-Reactor-简介" class="headerlink" title="1. Project Reactor 简介"></a>1. Project Reactor 简介</h2><p><a href="https://projectreactor.io/">Project Reactor</a>是一个运行在JVM上的反应式编程基础库，以“背压”的形式管理数据处理，提供了可组合的异步序列API<code>Flux</code>和<code>Mono</code>。同时，它也实现了<a href="https://www.reactive-streams.org/">Reactive Streams</a> 规范。关于反应式编程以及Reactive Streams的相关内容，上篇文章已做过介绍，这里不再赘述。</p><blockquote><p><strong>所谓Spring Reactor</strong><br/></p><p><a href="https://projectreactor.io/">Project Reactor</a>主要是由<a href="https://pivotal.io/open-source">Pivotal公司</a>开发和维护的，Spring框架也是该公司在维护，而且Spring Framework 5中默认使用Reactor作为反应式编程的实现，由此虽然Reactor不是Spring的子项目，也有人称Reactor为Spring Reactor。</p></blockquote><p>众所周知，I&#x2F;O阻塞浪费了系统性能，只有纯异步处理才能发挥系统的全部性能，不作丝毫浪费；而JDK的异步API比较难用，成为异步编程的瓶颈，这就是Reactor等其它反应式框架诞生的原因。</p><p>Reactor大大降低了异步编码难度(尽管相比同步编码，复杂度仍然是上升的)，变得简单的根本原因，是编码思想的转变。</p><p>JDK的异步API使用的是传统的命令式编程，命令式编程是以控制流为核心，通过顺序、分支和循环三种控制结构来完成不同的行为。而Reactor使用反应式编程，应用程序从以逻辑为中心转换为了以数据为中心，这也是命令式到声明式的转换。</p><h3 id="1-1-从命令式到反应式编程"><a href="#1-1-从命令式到反应式编程" class="headerlink" title="1.1 从命令式到反应式编程"></a>1.1 从命令式到反应式编程</h3><p>Reactor反应库旨在解决JVM上“经典”异步方法的缺点，同时还拥有如下特点：</p><ol><li>可组合性和可读性，完美规避了<strong>Callback Hell</strong></li><li>以流的形式进行数据处理时，为流中每个节点提供了丰富的操作符</li><li>在Subscribe之前，不会有任何事情发生</li><li>支持背压，消费者可以向生产者发出信号表明排放率过高</li><li>支持两种反应序列：hot和cold</li></ol><h3 id="1-2-子项目列表"><a href="#1-2-子项目列表" class="headerlink" title="1.2 子项目列表"></a>1.2 子项目列表</h3><p><a href="https://projectreactor.io/">Project Reactor</a>试图提供反应式编程相关的各类基础库，它包含了如下子项目：</p><table><thead><tr><th>模块名称</th><th>最新正式版本</th><th>描述</th></tr></thead><tbody><tr><td>Reactor Core</td><td>3.2.11.RELEASE</td><td>一个实现了Reactive Streams规范的基础库</td></tr><tr><td>Reactor Test</td><td>3.2.11.RELEASE</td><td>测试套件</td></tr><tr><td>Reactor Extra &#x2F; Reactor Addons</td><td>3.2.3.RELEASE</td><td>扩展库，包含reactor-adapter和reactor-extra，增强了Reactor Core的功能</td></tr><tr><td>Reactor Netty</td><td>0.8.10.RELEASE</td><td>基于Netty，提供了非阻塞的、支持背压的TCP&#x2F;HTTP&#x2F;UDP客户端和服务端</td></tr><tr><td>Reactor Adapter</td><td>3.2.3.RELEASE</td><td>支持桥接到其它反应式库，如RxJava</td></tr><tr><td>Reactor Kafka</td><td>1.1.1.RELEASE</td><td>桥接到Apache Kafka</td></tr><tr><td>Reactor Kotlin Extensions</td><td>没有发布正式版</td><td>为Kotlin语言添加各种扩展和适配器</td></tr><tr><td>Reactor RabbitMQ</td><td>1.2.0.RELEASE</td><td>桥接到RabbitMQ</td></tr><tr><td>BlockHound</td><td>没有发布正式版</td><td>用于检测来自非阻塞线程的阻塞调用</td></tr><tr><td>Reactor Core .NET</td><td>0.6.1</td><td>为.NET孵化反应流基础库</td></tr><tr><td>Reactor Core JS</td><td>0.5.0</td><td>为Javascript孵化反应流基础库</td></tr></tbody></table><p>除了上述最后三个子项目，其它子项目都是构建于<code>Reactor Core</code>之上，这也是下面要介绍的主要内容。</p><blockquote><p>Reactor Core直接集成了Java 8相关的API，例如CompletableFuture、Stream、Duration，所以Java 8是使用Reactor的最低版本。</p></blockquote><blockquote><p>Reactive Streams规范诞生于Reactor之后，Reactor是在2.0.0.RC1版本时，支持了Reactive Streams规范，点击查看<a href="https://spring.io/blog/2015/02/18/reactor-2-0-0-rc1-with-native-reactive-streams-support-now-available">版本BLOG</a>。</p></blockquote><h2 id="2-Flux-Mono"><a href="#2-Flux-Mono" class="headerlink" title="2 Flux &amp; Mono"></a>2 Flux &amp; Mono</h2><p><code>Flux&lt;T&gt;</code>是一个标准的Reactive Streams规范中的<code>Publisher&lt;T&gt;</code>，它代表一个包含了[0…N]个元素的异步序列流。在Reactive Streams规范中，针对流中每个元素，订阅者将会监听这三个事件：<code>onNext</code>、<code>onComplete</code>、<code>onError</code>。</p><p><code>Mono&lt;T&gt;</code>是一个特殊的<code>Flux&lt;T&gt;</code>，它代表一个仅包含1个元素的异步序列流。因为只有一个元素，所以订阅者只需要监听<code>onComplete</code>、<code>onError</code>。</p><h3 id="2-1-创建并订阅Flux或Mono"><a href="#2-1-创建并订阅Flux或Mono" class="headerlink" title="2.1 创建并订阅Flux或Mono"></a>2.1 创建并订阅Flux或Mono</h3><p>创建Flux或Mono的最简单方法，是使用那些工厂方法，如<code>just</code>、<code>fromIterable</code>、<code>empty</code>、<code>range</code>。当需要订阅它们时，可以调用如下几个重载的方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//仅订阅并触发流，不做其它处理</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">></span></span> consumer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//处理流中的每个元素</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">></span></span> consumer<span class="token punctuation">,</span>          <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Throwable</span><span class="token punctuation">></span></span> errorConsumer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//处理流中的元素、处理相应的异常</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">></span></span> consumer<span class="token punctuation">,</span>          <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Throwable</span><span class="token punctuation">></span></span> errorConsumer<span class="token punctuation">,</span>          <span class="token class-name">Runnable</span> completeConsumer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//处理流中的元素、处理相应的异常；当流结束时，可以执行一些内容</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">></span></span> consumer<span class="token punctuation">,</span>          <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Throwable</span><span class="token punctuation">></span></span> errorConsumer<span class="token punctuation">,</span>          <span class="token class-name">Runnable</span> completeConsumer<span class="token punctuation">,</span>          <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Subscription</span><span class="token punctuation">></span></span> subscriptionConsumer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最后一个参数Subscription，代表处理一个元素的生命周期，也是Reactive Streams规范中定义的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-编程的方式创建Flux"><a href="#2-2-编程的方式创建Flux" class="headerlink" title="2.2 编程的方式创建Flux"></a>2.2 编程的方式创建Flux</h3><p><code>generate</code>、<code>create</code>、<code>push</code>、<code>handle</code>方法支持以编程的方式创建<code>Flux</code>，使创建方式更加灵活。</p><p><code>generate</code>方法创建的流是同步的，流内元素是有序的，依次被订阅者消费。</p><p><code>create</code>方法以异步、多线程的方式创建流。</p><p><code>push</code>方法以异步、单线程的方式创建流。</p><p><code>handle</code>方法是一个示例方法，它类似于<code>generate</code>，将一个已经存在的流，转换成同步的流。</p><p>以下是<code>generate</code>方法的一个简单示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Flux</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> flux <span class="token operator">=</span> <span class="token class-name">Flux</span><span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span>    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span>state<span class="token punctuation">,</span> sink<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>      sink<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">"3 x "</span> <span class="token operator">+</span> state <span class="token operator">+</span> <span class="token string">" = "</span> <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">*</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span> sink<span class="token punctuation">.</span><span class="token function">complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> state <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** 流中的元素依次是：3 x 0 = 03 x 1 = 33 x 2 = 63 x 3 = 93 x 4 = 123 x 5 = 15**/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-使用示例"><a href="#3-使用示例" class="headerlink" title="3. 使用示例"></a>3. 使用示例</h2><p>使用静态工厂方法<code>fromIterable</code>创建一个<code>Flux</code>对象，而<code>flatMap</code>、<code>filter</code>等非静态方法即所谓操作符，多种操作符组合使用，可以对数据流的元素进行复杂处理。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> words <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"th"</span><span class="token punctuation">,</span> <span class="token string">"qu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Flux</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> manyLetters <span class="token operator">=</span> <span class="token class-name">Flux</span>        <span class="token punctuation">.</span><span class="token function">fromIterable</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>word <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Step1="</span> <span class="token operator">+</span> word<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token class-name">Flux</span><span class="token punctuation">.</span><span class="token function">fromArray</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>s <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Step2="</span> <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>s <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Step3="</span> <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>manyLetters<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>s <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Result="</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** 输出结果：Step1=thStep2=tStep3=tResult=tStep2=hStep3=hResult=hStep1=quStep2=qStep3=qResult=qStep2=uStep3=uResult=u**/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>观察manyLetters变量的结构，Flux之所以支持对流中数据的链式调用，是因为每一步返回的Flux对象都被上一个Flux对象包含。</p><p><img src="/images/2019/08/manyletters.png" alt="manyLetters"></p><blockquote><p>组合的操作符(Operator)对流中数据进行处理，实际上是对<code>Publisher</code>发布消息前的功能增强，使元素可以在发布之前被加工处理好。</p></blockquote><p>如果仅看上面这种使用方式，看起来与Java 8的Stream差不多，并没有体现异步的特性，数据流在一开始就是确定的。假如不存在异步处理，使用Reactor就没有什么意义了。</p><p>与Java 8的Stream不同，Reactor支持以异步的方式创建<code>Flux</code>，看如下代码片段，MongoDB与Reactor结合使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">MongoCollection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Document</span><span class="token punctuation">></span></span> collection<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Flux</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Restaurant</span><span class="token punctuation">></span></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token class-name">Flux</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>collection<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">RestaurantTransfer</span><span class="token operator">::</span><span class="token function">toDomainObject</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token operator">::</span><span class="token function">isPresent</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token operator">::</span><span class="token function">get</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ReactiveRestaurantRepository</span> repository <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReactiveRestaurantRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Flux</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Restaurant</span><span class="token punctuation">></span></span> flux <span class="token operator">=</span> repository<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    flux<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>public static &lt;T&gt; Flux&lt;T&gt; from(Publisher&lt;? extends T&gt; source)</code>方法接收一个<code>org.reactivestreams.Publisher</code>参数，该对象是由MongoDB的Reactive客户端API创建的，MongoDB通过该对象，将DB中的数据，链接到Reactor的流中。</p><p>当调用subscribe方法后，一个发布-订阅的机制形成，只有当对象被从DB中取出并放入内存后，JVM才会占用线程资源，将消息发送给订阅者；从阻塞等待转变为了被动接收，因此节省了资源。</p><blockquote><p>由此可见，只有流中的数据全部是反应式的，Reactor才能发挥最大作用，一旦有节点被阻塞，就达不到节省资源的目的了。</p></blockquote><blockquote><p>正是由于MongoDB和Reactor Core都实现了Reactive Streams规范，它们才能相互沟通交互，Reactive Streams规范在反应式编程的推广过程中，起着至关重要的作用。<br/><br>当反应式编程的生态越来越完整，将会有更多的人考虑使用这种编程方式。</p></blockquote><h2 id="4-与Spring的关系"><a href="#4-与Spring的关系" class="headerlink" title="4. 与Spring的关系"></a>4. 与Spring的关系</h2><p>Reactor是Spring整个生态系统的基础，特别是Spring Framework 5和 Spring Data “kay”。</p><p>这两个项目的Reactive版本是非常有意义的，我们可以基于此开发出完全Reactive的Web应用：支持对请求的全链路异步处理，一直到数据库，最后异步地返回结果。</p><p>Spring项目因此可以更有效地利用资源，避免为每个请求单独分配一个线程，产生I&#x2F;O阻塞。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>本文对<code>Project Reactor</code>做了一个基本介绍，旨在使读者明白<code>Project Reactor</code>的意义和价值。</p><p>作为一名普通的程序员(专注业务开发)，我们接触最多的可能是<code>WebFlux</code>框架，以及<code>Flux</code>、<code>Mono</code>这些基础对象，在理解<code>Project Reactor</code>基本思想的基础上，再使用上层框架，将会更加得心应手。</p><h2 id="参考的文章："><a href="#参考的文章：" class="headerlink" title="参考的文章："></a>参考的文章：</h2><p><a href="https://projectreactor.io/docs/core/release/reference/">Reactor 3 Reference Guide</a><br><a href="https://github.com/emac/demo-reactor">emac&#x2F;demo-reactor</a><br><a href="https://www.infoq.cn/article/reactor-by-example/">Reactor 实例解析</a></p>]]></content>
      
      
      <categories>
          
          <category> reactive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reactive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reactive Streams 介绍</title>
      <link href="/2019/07/01/reactive/reactive-streams/"/>
      <url>/2019/07/01/reactive/reactive-streams/</url>
      
        <content type="html"><![CDATA[<p>JDK的异步处理，一直相对较弱，这方面也有很强的第三方框架。最近在学习这方面的内容，将学习过程记录在这里。</p><p>这篇文章里，主要了解Java中异步流处理的顶级概念：Reactive Streams。</p><span id="more"></span><h2 id="1-起源"><a href="#1-起源" class="headerlink" title="1. 起源"></a>1. 起源</h2><p>Reactive Streams，翻译为反应式流，从名字上完全无法理解它的意义，像是两个硬凑在一起的词汇。</p><p>事实上，它并不是一个全新的事物，异步编程大家都有了解，Java里典型的多线程处理就是异步编程。而异步编程时，存在很多难题，比如典型的<code>回调地狱(Callback Hell)</code>，一层套一层的回调函数简直是个灾难，这里列出几个异步编程常见的问题：</p><ol><li>超时、异常处理困难</li><li>难以重构</li><li>多个异步任务协同处理</li></ol><p>为了解决异步编程过程中出现的种种难题，人们提出了各种各样方法来规避这些问题，这些方法称为<code>反应式编程(Reactive Programming)</code>，就像面向对象编程，函数式编程一样，反应式编程也是另一种编程范式。</p><p>反应式编程，本质上是对数据流或某种变化所作出的<strong>反应</strong>，但是这个变化什么时候发生是未知的，所以他是一种基于异步、回调的方式在处理问题。</p><blockquote><p><strong>Tips</strong><br/><br>Reactive Programming &#x3D; Streams + Operations<br>Streams代表被处理的数据节点，Operations代表那些异步处理</p></blockquote><p>当越来越多的开发人员使用这种编程思想时，自然而然需要一套统一的规范。由此，2013年底Netflix，Pivotal和Lightbend中的工程师们，启动了<a href="http://www.reactive-streams.org/">Reactive Streams</a>项目，希望为异步流(包含背压)处理提供标准，它包括针对运行时环境（JVM和JavaScript）以及网络协议的工作。</p><h2 id="2-概念"><a href="#2-概念" class="headerlink" title="2. 概念"></a>2. 概念</h2><p>对于Java程序员，Reactive Streams是一个API。Reactive Streams为我们提供了Java中的Reactive Programming的通用API。</p><p>Reactive Streams非常类似于JPA或JDBC。两者都是API规范，实际使用时需要使用API​​对应的具体实现。例如，从JDBC规范中，有DataSource接口，而Oracle JDBC实现了DataSource接口。Microsoft的SQL Server JDBC实现也实现了DataSource接口。</p><p>就像JPA或JDBC一样，Reactive Streams为我们提供了一个我们可以编写代码的API接口，而无需担心底层实现，在GitHub上可以查看<a href="https://github.com/reactive-streams/reactive-streams-jvm">API的源码</a>。</p><p>Reactive Streams API的范围是找到一组最小的接口，方法和协议，这些接口，方法和协议将描述必要的操作和实体，<strong>从而实现具有非阻塞背压的异步数据流</strong>。</p><p>从代码结构上看，它主要包含两部分：<code>reactive-streams</code>和<code>reactive-streams-tck</code>。其中TCK意为技术兼容包（Technology Compatibility Kit ），为实现Reactive Streams接口提供帮助。</p><p><code>Reactive Streams API</code>中仅仅包含了如下四个接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//发布者</span><span class="token keyword">public</span>  <span class="token keyword">interface</span>  <span class="token class-name">Publisher</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">T</span> <span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span>  <span class="token keyword">void</span>  subscribe（<span class="token class-name">Subscriber</span> <span class="token operator">&lt;</span>？ <span class="token keyword">super</span>  <span class="token class-name">T</span> <span class="token operator">></span>  s）<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//订阅者</span><span class="token keyword">public</span>  <span class="token keyword">interface</span>  <span class="token class-name">Subscriber</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">T</span> <span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span>  <span class="token keyword">void</span>  onSubscribe（<span class="token class-name">Subscription</span>  s）<span class="token punctuation">;</span>    <span class="token keyword">public</span>  <span class="token keyword">void</span>  onNext（<span class="token class-name">T</span>  t）<span class="token punctuation">;</span>    <span class="token keyword">public</span>  <span class="token keyword">void</span>  onError（<span class="token class-name">Throwable</span>  t）<span class="token punctuation">;</span>    <span class="token keyword">public</span>  <span class="token keyword">void</span>  onComplete（）<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//表示Subscriber消费Publisher发布的一个消息的生命周期</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Subscription</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token keyword">long</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//处理器，表示一个处理阶段，它既是订阅者也是发布者，并且遵守两者的契约</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Processor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">Subscriber</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">Publisher</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">R</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-目标"><a href="#3-目标" class="headerlink" title="3. 目标"></a>3. 目标</h2><p>Reactive Streams的主要目标有这两个：</p><ol><li>管理跨异步边界的流数据交换 - 即将元素传递到另一个线程或线程池；</li><li>确保接收方不会强制缓冲任意数量的数据，为了使线程之间的队列有界，引入了回压(Back Pressure)。</li></ol><p>传统异步编程的写法，不同任务分别在不同的线程中执行，协调这些线程执行的先后顺序、线程间的依赖顺序是一件非常麻烦的事情，而Reactive Streams就是为了解决该问题。</p><p>另外，Reactive Streams规范引入了回压(Back Pressure)，可以动态控制线程间消息交换的速率，避免生产者产生过多的消息，消费者消费不完等类似问题。</p><h2 id="4-一些思考"><a href="#4-一些思考" class="headerlink" title="4. 一些思考"></a>4. 一些思考</h2><p>Reactive Streams，是一套非阻塞背压的异步数据流的API。这个概念看起来有点拗口，这里拆开分析下：</p><h3 id="4-1-Reactive"><a href="#4-1-Reactive" class="headerlink" title="4.1 Reactive"></a>4.1 Reactive</h3><blockquote><p>这是个形容词，翻译为<code>反应的</code>，这个词乍一看相当奇怪，这里尝试做一下解释。</p></blockquote><p>事实上，在某些语境下，reactive也会被翻译为<code>被动</code>，而<code>Reactive Streams</code>是基于消息驱动的（也可以说是事件驱动的），当消息产生时，系统被动接受消息，并作出反馈，而非主动处理。因此，我们也可以这样理解：被动地接收消息后，作出相应的反应动作，这个行为称之为<code>反应式</code>。</p><h3 id="4-2-Streams"><a href="#4-2-Streams" class="headerlink" title="4.2 Streams"></a>4.2 Streams</h3><blockquote><p>这是个名词，翻译为<code>数据流</code>，反应式编程的核心思想，体现在了这个单词上。</p></blockquote><p>流的定义：随着时间顺序排列的一组序列。一切皆是流(Everything is a stream)。我们可以把一组数据抽象为流(可以想象流是一个数组)，把对流中节点的逻辑处理，抽象成对节点的一步一步的处理，围绕该节点做加工处理，最终获得结果。</p><p>这跟工厂车间的流水线非常相似，发布者将半成品放到传送带上，经过层层处理后，得到成品送到订阅者手中。</p><p>而异步特性，是体现在每一步的处理过程中的，每一步处理都是消息驱动的，不阻塞应用程序，被动获得结果后继续进行下一步。</p><blockquote><p><strong>Tips</strong> <br/><br>响应式编程，在处理流中节点时，各个步骤都使用异步的、消息驱动的方式处理任务，才会节省性能。</p></blockquote><blockquote><p><strong>Tips</strong> <br/><br>传统的命令式编程范式以控制流为核心，通过顺序、分支和循环三种控制结构来完成不同的行为。<br>在反应式编程中，应用程序从以逻辑为中心转换为了以数据为中心，这也是命令式到声明式的转换。</p></blockquote><h3 id="4-3-非阻塞、异步"><a href="#4-3-非阻塞、异步" class="headerlink" title="4.3 非阻塞、异步"></a>4.3 非阻塞、异步</h3><p>反义词是阻塞、同步，目前在Java中，大多数应用程序是同步的，即暴力创建线程，线程阻塞时，一直等待直到有结果返回。</p><p>异步最吸引人的地方在于资源的充分利用，不把资源浪费在等待的时间上，代价是增加了程序的复杂度，而Reactive Streams封装了这些复杂性，使其变得简单。</p><h3 id="4-4-背压-back-pressure"><a href="#4-4-背压-back-pressure" class="headerlink" title="4.4 背压(back-pressure)"></a>4.4 背压(back-pressure)</h3><p>背压是从流体动力学中借用的类比, 在维基百科的定义是：抵抗所需流体通过管道的阻力或力。在软件环境中，可以调整定义：通过软件抵抗所需数据流的阻力或力量。</p><p>背压是为了解决这个问题的： 上游组件了过量的消息，导致下游组件无法及时处理，从而导致程序崩溃。</p><p><img src="/images/2019/07/back-pressure.png" alt="back-pressure"></p><p>对于正遭受压力的组件来说，无论是灾难性地失败，还是不受控地丢弃消息，都是不可接受的。既然它既不能应对压力，又不能直接做失败处理，那么它就应该向其上游组件传达其正在遭受压力的事实，并让它们降低负载。</p><p>这种背压（back-pressure）是一种重要的反馈机制，使得系统得以优雅地响应负载，而不是在负载下崩溃。相反，如果下游组件比较空闲，则可以向上游组件发出信号，请求获得更多的调用。</p><h2 id="5-与Java1-8、Java1-9的关系"><a href="#5-与Java1-8、Java1-9的关系" class="headerlink" title="5. 与Java1.8、Java1.9的关系"></a>5. 与Java1.8、Java1.9的关系</h2><p>Reactive Streams不要求必须使用Java8，Reactive Streams也不是Java API的一部分。</p><p>但是使用Java8中lambda表达式的存在，可以发挥Reactive Streams规范的强大特性，比如Reactive Streams的实现<code>Project Reactor</code>项目的当前版本，就要求最低使用Java1.8。</p><blockquote><p>Java8中的<code>Stream</code>和<code>Reactive Streams</code><br/><br>它们都使用了流式处理的思想，围绕数据流处理数据，即完成了从命令式到声明式的转换，使数据处理更方便。<br>不同的地方在于，Java8中的<code>Stream</code>是同步的、阻塞的，<code>Reactive Streams</code>是异步的、非阻塞的。</p></blockquote><p>当使用Java1.9时， Reactive Streams已成为官方<a href="https://community.oracle.com/docs/DOC-1006738">Java 9 API的一部分</a>，Java9中Flow类下的内容与Reactive Streams完全一致。</p><h2 id="6-具体实现框架"><a href="#6-具体实现框架" class="headerlink" title="6. 具体实现框架"></a>6. 具体实现框架</h2><p>Reactive Streams的实现现在比较多了，David Karnok在<a href="https://akarnokd.blogspot.com/2016/03/operator-fusion-part-1.html">Advanced Reactive Java</a>这边文章中，将这些实现分解成几代，也可以侧面了解反应式编程的发展史。</p><p><strong>RxJava</strong></p><p>RxJava是ReactiveX项目中的Java实现。ReactiveX项目实现了很多语言，比如JavaScript，.NET（C＃），Scala，Clojure，C ++，Ruby，Python，PHP，Swift等。</p><p>RxJava早于Reactive Streams规范。虽然RxJava 2.0+确实实现了Reactive Streams API规范，单使用的术语略有不同。</p><p><strong>Reactor</strong></p><p>Reactor是Pivotal提供的Java实现，它作为Spring Framework 5的重要组成部分，是WebFlux采用的默认反应式框架。</p><p><strong>Akka Streams</strong></p><p>Akka Streams完全实现了Reactive Streams规范，但Akka Streams API与Reactive Streams API完全分离。</p><p><strong>Ratpack</strong></p><p>Ratpack是一组用于构建现代高性能HTTP应用程序的Java库。Ratpack使用Java 8，Netty和Reactive原则。可以将RxJava或Reactor与Ratpack一起使用。</p><p><strong>Vert.x</strong></p><p>Vert.x是一个Eclipse Foundation项目，它是JVM的多语言事件驱动的应用程序框架。Vert.x中的反应支持与Ratpack类似。Vert.x允许我们使用RxJava或其Reactive Streams API的实现。</p><h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a>7. 小结</h2><p>在Reactive Streams之前，各种反应库无法实现互操作性。早期版本的<code>RxJava</code>与<code>Project Reactor</code>的早期版本不兼容。</p><p>另外，反应式编程无法大规模普及，一个很重要的原因是并不是所有库都支持反应式编程，当一些类库只能同步调用时，就无法达到节约性能的作用了。</p><p>Reactive Streams的推出统一了反应式编程的规范，并且已经被Java9集成。由此，不同的库可以互操作了，互操作性是一个重要的多米诺骨牌。</p><p>例如，MongoDB实现了<a href="https://mongodb.github.io/mongo-java-driver-reactivestreams/">Reactive Streams驱动程序</a>后，我们可以使用Reactor或RxJava来使用MongoDB中的数据。</p><h2 id="参考的文章："><a href="#参考的文章：" class="headerlink" title="参考的文章："></a>参考的文章：</h2><p><a href="https://www.reactive-streams.org/">Reactive Streams</a><br><a href="https://www.reactivemanifesto.org/">The Reactive Manifesto</a><br><a href="https://en.wikipedia.org/wiki/Reactive_Streams">Reactive Streams - Wikipedia</a><br><a href="https://dzone.com/articles/what-are-reactive-streams-in-java">What Are Reactive Streams in Java?</a><br><a href="https://cloud.tencent.com/developer/article/1073888">Java 平台反应式编程（Reactive Programming）入门</a><br><a href="https://codecraft.tv/courses/angular/reactive-programming-with-rxjs/streams-and-reactive-programming/">Streams &amp; Reactive Programming</a><br><a href="https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7">Backpressure explained — the resisted flow of data through software</a><br><a href="https://www.codingame.com/playgrounds/929/reactive-programming-with-reactor-3/Intro">Introduction to Reactive Programming</a></p>]]></content>
      
      
      <categories>
          
          <category> reactive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reactive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 日常脚本记录(不定期更新)</title>
      <link href="/2019/06/08/db/mysql-common-sql/"/>
      <url>/2019/06/08/db/mysql-common-sql/</url>
      
        <content type="html"><![CDATA[<p>写一些Mysql脚本时，总会忘记部分具体语法，此时不得不面向浏览器编程，这个体验很糟糕。鉴于此，这里做一个简要的记录，以便快速查看。</p><span id="more"></span><h2 id="查询相邻的两条数据"><a href="#查询相邻的两条数据" class="headerlink" title="查询相邻的两条数据"></a>查询相邻的两条数据</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> s1<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span> s2<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">from</span><span class="token punctuation">(</span><span class="token keyword">select</span> t<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token variable">@rownum1</span> :<span class="token operator">=</span> <span class="token variable">@rownum2</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">AS</span> rank1<span class="token punctuation">,</span>id_<span class="token punctuation">,</span> name_  <span class="token keyword">FROM</span><span class="token punctuation">(</span> <span class="token keyword">SELECT</span> <span class="token variable">@rownum2</span> :<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> r<span class="token punctuation">,</span>ACT_HI_TASKINST<span class="token punctuation">)</span> t<span class="token keyword">where</span> t<span class="token punctuation">.</span>name_ <span class="token operator">=</span> <span class="token string">'补充材料'</span><span class="token punctuation">)</span> s1<span class="token keyword">join</span><span class="token punctuation">(</span><span class="token keyword">select</span> t<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token variable">@rownum2</span> :<span class="token operator">=</span> <span class="token variable">@rownum2</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">AS</span> rank2<span class="token punctuation">,</span>id_<span class="token punctuation">,</span> name_  <span class="token keyword">FROM</span><span class="token punctuation">(</span> <span class="token keyword">SELECT</span> <span class="token variable">@rownum2</span> :<span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> r<span class="token punctuation">,</span>ACT_HI_TASKINST<span class="token punctuation">)</span> t<span class="token punctuation">)</span> s2<span class="token keyword">on</span> s1<span class="token punctuation">.</span>rank1 <span class="token operator">=</span> s2<span class="token punctuation">.</span>rank2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> curdate<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 逗号隔开，列转行</span><span class="token keyword">select</span> group_concat<span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">from</span> Test<span class="token punctuation">;</span><span class="token comment">-- 计算时间差、格式化日期</span>TIMESTAMPDIFF<span class="token punctuation">(</span><span class="token keyword">DAY</span><span class="token punctuation">,</span> DATE_FORMAT<span class="token punctuation">(</span>t1<span class="token punctuation">.</span>START_TIME_<span class="token punctuation">,</span><span class="token string">'%y-%m-%d'</span><span class="token punctuation">)</span>  <span class="token punctuation">,</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">-- 60分钟内的数据</span>updateTime <span class="token operator">></span> date_add<span class="token punctuation">(</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">interval</span> <span class="token operator">-</span><span class="token number">60</span> <span class="token keyword">minute</span><span class="token punctuation">)</span><span class="token comment">-- if函数</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">boolean</span><span class="token punctuation">,</span> str2<span class="token punctuation">,</span> str3<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="操作字段"><a href="#操作字段" class="headerlink" title="操作字段"></a>操作字段</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 修改表名</span><span class="token keyword">alter</span> <span class="token keyword">table</span> Test <span class="token keyword">rename</span> <span class="token keyword">to</span> Test1<span class="token punctuation">;</span><span class="token comment">-- 增加列</span><span class="token keyword">alter</span> <span class="token keyword">table</span> Test <span class="token keyword">add</span> <span class="token keyword">column</span> username <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">comment</span> <span class="token string">'ID'</span> <span class="token keyword">after</span> id<span class="token punctuation">;</span><span class="token comment">-- 修改列属性</span><span class="token keyword">alter</span> <span class="token keyword">table</span> Test <span class="token keyword">modify</span> <span class="token keyword">column</span> username <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span> <span class="token keyword">comment</span> <span class="token string">'ID'</span><span class="token punctuation">;</span><span class="token comment">-- 修改列名和属性</span><span class="token keyword">alter</span> <span class="token keyword">table</span> Test change <span class="token keyword">column</span> username username1 <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 删除列</span><span class="token keyword">alter</span> <span class="token keyword">table</span> Test <span class="token keyword">drop</span> <span class="token keyword">column</span> username<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="操作索引"><a href="#操作索引" class="headerlink" title="操作索引"></a>操作索引</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 创建索引</span><span class="token keyword">alter</span> <span class="token keyword">table</span> Test <span class="token keyword">add</span> <span class="token keyword">index</span> index_id <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">alter</span> <span class="token keyword">table</span> Test <span class="token keyword">add</span> <span class="token keyword">unique</span> <span class="token keyword">index</span> index_id <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">alter</span> <span class="token keyword">table</span> Test <span class="token keyword">add</span> fulltext <span class="token keyword">index</span> index_id <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">index</span> index_id <span class="token keyword">on</span> Test <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">unique</span> <span class="token keyword">index</span> index_id <span class="token keyword">on</span> Test <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">create</span> fulltext <span class="token keyword">index</span> index_id <span class="token keyword">on</span> Test <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 删除索引</span><span class="token keyword">alter</span> <span class="token keyword">table</span> Test <span class="token keyword">drop</span> <span class="token keyword">index</span> index_id <span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">index</span> index_id <span class="token keyword">on</span> Test <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 笔记（三、类和接口）</title>
      <link href="/2019/06/03/javascript/typescript-3/"/>
      <url>/2019/06/03/javascript/typescript-3/</url>
      
        <content type="html"><![CDATA[<p>作为一个面向对象的语言，类和接口不可或缺，相比现行的JavaScript，这两个概念都是新引入的，本文将对这两个概念进行详细介绍。</p><span id="more"></span><h2 id="1-什么是类"><a href="#1-什么是类" class="headerlink" title="1. 什么是类"></a>1. 什么是类</h2><p>传统方法中，JavaScript通过构造函数实现类的概念，通过原型链实现继承。而在ES6中，我们终于迎来了class。</p><ul><li>类(Class)：定义了一件事物的抽象特点，包含它的属性和方法</li><li>对象（Object）：类的实例，通过 new 生成</li><li>面向对象（OOP）的三大特性：封装、继承、多态</li><li>封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</li><li>继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li><li>多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 Cat 还是 Dog，就可以直接调用 eat 方法，程序会自动判断出来应该如何执行 eat</li><li>存取器（getter &amp; setter）：用以改变属性的读取和赋值行为</li><li>修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法</li><li>抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li><li>接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口</li></ul><blockquote><p>TypeScript中的<code>class</code>和Java中的<code>class</code>极其相似，学习起来没有任何瓶颈，理解会很快。</p></blockquote><h2 id="2-类的典型示例及说明"><a href="#2-类的典型示例及说明" class="headerlink" title="2. 类的典型示例及说明"></a>2. 类的典型示例及说明</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> _name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">// 1</span>    <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span><span class="token comment">// 2</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">set</span> <span class="token function">name</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 2</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>_name <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span><span class="token comment">// 3</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">readonly</span> id<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"001"</span><span class="token punctuation">;</span><span class="token comment">// 4</span>    <span class="token keyword">private</span> department<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> department<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 5</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>department <span class="token operator">=</span> department<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token function">getElevatorPitch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, my name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> and I work in </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>department<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> employee<span class="token operator">:</span> Employee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token string">"总办"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 6</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>employee<span class="token punctuation">.</span><span class="token function">getElevatorPitch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Employee<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对上述代码说明如下：</p><ol><li>使用<code>constructor</code>关键字声明构造方法，创建对象时将自动调用该方法。</li><li>使用<code>get</code>、<code>set</code>关键字声明存取器，封装对属性的访问</li><li>使用<code>extends</code>关键字指定继承关系</li><li>使用<code>static readonly</code>组合创建一个不可变的常量</li><li>子类必须显式调用<code>super</code>方法，指向父类构造方法</li><li>使用<code>new</code>关键字创建类对象</li></ol><h2 id="3-接口"><a href="#3-接口" class="headerlink" title="3. 接口"></a>3. 接口</h2><p>TypeScript中的接口是一个非常灵活的概念，大体上它有如下四种使用方式：</p><ol><li>描述实体，即所谓对「对象的形状（Shape）」进行描述</li><li>描述函数类型</li><li>描述那些能够“通过索引得到”的类型</li><li>类类型，是行为的抽象（Java语言中只有这个用法）</li></ol><h3 id="3-1-描述对象的形状（Shape）"><a href="#3-1-描述对象的形状（Shape）" class="headerlink" title="3.1 描述对象的形状（Shape）"></a>3.1 描述对象的形状（Shape）</h3><blockquote><p>Java语言中，这个概念通常叫做<code>实体</code>，对应的文件叫<code>实体类</code>。</p></blockquote><p>声明形状接口时，可以通过<code>?</code>设置属性为可选；使用<code>readonly</code>设置属性为只读；使用<code>[propName: string]: any;</code>设置属性为任意类型。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>    age<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>    <span class="token keyword">readonly</span> id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> tom<span class="token operator">:</span> Person <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token string">'Tom'</span><span class="token punctuation">,</span>    id<span class="token operator">:</span> <span class="token number">25</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>接口可以继承类</strong></p><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。<br>接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p></blockquote><h3 id="3-2-描述函数类型"><a href="#3-2-描述函数类型" class="headerlink" title="3.2 描述函数类型"></a>3.2 描述函数类型</h3><p>使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">//声明，就像一个没有方法体的匿名函数</span><span class="token keyword">interface</span> <span class="token class-name">SearchFunc</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">(</span>source<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> subString<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//使用声明的接口</span><span class="token keyword">let</span> mySearch<span class="token operator">:</span> SearchFunc<span class="token punctuation">;</span><span class="token function-variable function">mySearch</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>source<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> subString<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> result <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>subString<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> result <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-描述那些能够“通过索引得到”的类型"><a href="#3-3-描述那些能够“通过索引得到”的类型" class="headerlink" title="3.3 描述那些能够“通过索引得到”的类型"></a>3.3 描述那些能够“通过索引得到”的类型</h3><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[“daniel”]。</p><p>可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型；共有支持两种索引签名：字符串和数字。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">//数字索引</span><span class="token keyword">interface</span> <span class="token class-name">StringArray</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span>index<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> myArray<span class="token operator">:</span> StringArray<span class="token punctuation">;</span>myArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token string">"Fred"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> myStr<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> myArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">//字符串索引</span><span class="token keyword">interface</span> <span class="token class-name">StringArray</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">[</span>index<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">any</span>    <span class="token punctuation">[</span>index<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">any</span>    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> myArray<span class="token operator">:</span> StringArray<span class="token punctuation">;</span>myArray <span class="token operator">=</span> <span class="token punctuation">&#123;</span>name<span class="token operator">:</span><span class="token string">"测试"</span><span class="token punctuation">,</span>aa<span class="token operator">:</span><span class="token string">"aaaa的值"</span><span class="token punctuation">,</span>bb<span class="token operator">:</span><span class="token string">"bbbb的值"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">:</span><span class="token number">11</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> myStr<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> myArray<span class="token punctuation">[</span><span class="token string">"bb"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> myName<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> myArray<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> myName3<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> myArray<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myStr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myName3<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>接口描述索引类型时，其作用有点像固定了key类型、value类型的Map，与Java中的Map<?,?>类似。</p></blockquote><blockquote><p>同时使用number和string类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。</p></blockquote><h3 id="3-4-类类型-实现接口"><a href="#3-4-类类型-实现接口" class="headerlink" title="3.4 类类型-实现接口"></a>3.4 类类型-实现接口</h3><p>与C#或Java里接口的基本作用一样，TypeScript也能够用接口来明确的强制一个类去符合某种契约。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">ClockInterface</span> <span class="token punctuation">&#123;</span>    currentTime<span class="token operator">:</span> Date<span class="token punctuation">;</span>    <span class="token function">setTime</span><span class="token punctuation">(</span>d<span class="token operator">:</span> Date<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Clock</span> <span class="token keyword">implements</span> <span class="token class-name">ClockInterface</span> <span class="token punctuation">&#123;</span>    currentTime<span class="token operator">:</span> Date<span class="token punctuation">;</span>    <span class="token function">setTime</span><span class="token punctuation">(</span>d<span class="token operator">:</span> Date<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>currentTime <span class="token operator">=</span> d<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>h<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> m<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>本文介绍了接口和类的概念，并列举了使用方式。对于类来说，与Java语言非常类似，因此学过Java语言再来看TypeScript中类，会发现基本一模一样。</p><p>接口的使用方式列举如下，它与Java语言差异较大，主要是增加了三种新的使用方式(前三种)。</p><ol><li>描述实体，即所谓对「对象的形状（Shape）」进行描述</li><li>描述函数类型</li><li>描述那些能够“通过索引得到”的类型</li><li>类类型，是行为的抽象（Java语言中只有这个用法）</li></ol><h2 id="参考的文章"><a href="#参考的文章" class="headerlink" title="参考的文章"></a>参考的文章</h2><p><a href="https://typescript.bootcss.com/classes.html">TypeScript 中文手册-类(class)</a><br><a href="https://typescript.bootcss.com/interfaces.html">TypeScript 中文手册-接口(interface)</a><br><a href="https://ts.xcatliu.com/advanced/class">类 - TypeScript 入门教程</a><br><a href="https://ts.xcatliu.com/basics/type-of-object-interfaces">对象的类型——接口 - TypeScript 入门教程</a><br><a href="https://ts.xcatliu.com/advanced/class-and-interfaces#%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3">类与接口 - TypeScript 入门教程</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 笔记（二、函数）</title>
      <link href="/2019/05/23/javascript/typescript-2/"/>
      <url>/2019/05/23/javascript/typescript-2/</url>
      
        <content type="html"><![CDATA[<p>函数是JavaScript应用程序的基础，用于定义行为。TypeScript为JavaScript函数添加了额外的功能，让我们可以更容易地使用。</p><p>本文将从如下几个方面，介绍TypeScript中的函数。</p><ul><li>函数定义</li><li>函数的参数</li><li>函数重载</li><li>this关键字</li></ul><span id="more"></span><h2 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1. 函数定义"></a>1. 函数定义</h2><blockquote><p>函数是JavaScript中的一等公民。<br>可以像对待任何其他数据类型一样对待它们——把它们存在数组里，当作参数传递，赋值给变量…等等。</p></blockquote><p>函数定义方式可以分为两大类：函数声明（有名字的函数）、函数表达式（匿名函数）。如下列举了已知的函数定义方式：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">//1. 函数声明</span><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">//2. 函数表达式(完整写法)</span><span class="token keyword">let</span> <span class="token function-variable function">myAdd1</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function-variable function">number</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//3. 函数表达式(简写)</span><span class="token keyword">let</span> <span class="token function-variable function">myAdd2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//4. 函数表达式(ES6中的箭头函数)</span><span class="token keyword">let</span> <span class="token function-variable function">myAdd3</span> <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token function-variable function">myAdd4</span> <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> myAdd5 <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token builtin">number</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token function-variable function">myAdd6</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token builtin">number</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面对上述代码进行说明：</p><ol><li>函数声明：这种方式固定了函数名称，Typescript使用冒号指定了参数类型和返回值类型，很容易理解。</li><li>函数表达式(完整写法)：等号左边的<code>(x:number, y:number) =&gt; number</code>用来描述函数的类型，类似<code>myAdd1:string</code>代表定义了一个字符串。等号右边则是一个普通的匿名函数。</li><li>函数表达式(简写)：这种写法省略了<code>(x:number, y:number) =&gt; number</code>，省略的部分会被Typescript自动推断出来。</li><li>函数表达式(ES6中的箭头函数)：利用ES6中新增的<a href="https://es6.ruanyifeng.com/#docs/function#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">箭头函数</a>，可以省略匿名函数的function关键字，当只有一行处理代码时，可以再省略大括号。</li></ol><blockquote><p><strong>注意</strong><br/></p><p>在上述<code>函数表达式(完整写法)</code>部分的<code>(x:number, y:number) =&gt; number</code>代码中，&#x3D;&gt;用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。可以这样理解：描述字符串使用：<code>let myAdd2:string</code>，描述函数时把<code>string</code>替换为上述代码。<br>而在<code>函数表达式(ES6中的箭头函数)</code>部分的<code>(x:number, y:number):number =&gt; &#123; return x + y; &#125;;</code>代码中，则是ES6规范的实现，&#x3D;&gt;叫做箭头函数。</p></blockquote><h2 id="2-函数的参数"><a href="#2-函数的参数" class="headerlink" title="2. 函数的参数"></a>2. 函数的参数</h2><p>JavaScript里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是undefined。 而TypeScript里的每个函数参数都是必须的，传递给一个函数的参数个数必须与函数期望的参数个数一致。</p><p>为了保持TypeScript的灵活性，TypeScript也提供了相对灵活参数传递功能，一共有如下三种：</p><ol><li>可选参数：如<code>lastName?: string</code></li><li>指定参数默认值（ES6规范）：如<code>lastName = &quot;Smith&quot;</code></li><li>剩余参数（ES6规范）：参数个数不确定，如<code>...restOfName: string[]</code></li></ol><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">//lastName为可选参数，可选参数必须跟在必须参数后面。</span><span class="token keyword">function</span> <span class="token function">buildName1</span><span class="token punctuation">(</span>firstName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> lastName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lastName<span class="token punctuation">)</span>        <span class="token keyword">return</span> firstName <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> lastName<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> firstName<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//为lastName指定默认值， 如果lastName参数在firstName之前，则需要传入undefined来获得默认值</span><span class="token keyword">function</span> <span class="token function">buildName2</span><span class="token punctuation">(</span>firstName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> lastName <span class="token operator">=</span> <span class="token string">"Smith"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> firstName <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> lastName<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//指定剩余参数</span><span class="token keyword">function</span> <span class="token function">buildName3</span><span class="token punctuation">(</span>firstName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token operator">...</span>restOfName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> firstName <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> restOfName<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> employeeName <span class="token operator">=</span> <span class="token function">buildName3</span><span class="token punctuation">(</span><span class="token string">"Joseph"</span><span class="token punctuation">,</span> <span class="token string">"Samuel"</span><span class="token punctuation">,</span> <span class="token string">"Lucas"</span><span class="token punctuation">,</span> <span class="token string">"MacKinzie"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-函数重载"><a href="#3-函数重载" class="headerlink" title="3. 函数重载"></a>3. 函数重载</h2><p>JavaScript中是不允许方法重载的，原因是即使参数不同，也会被认为是同一个方法进而提示方法重复。</p><p>为此，Typescript提供了语法糖式的解决方案，允许声明同名、但参数类型不同的函数，但不能提供具体实现；在最终的实现代码中继续用原始的方式对参数进行判断，从而实现了方法重载。</p><p>此时，只允许调用没有具体实现的重载函数，不允许调用重载的真正实现的函数。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">let</span> suits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"hearts"</span><span class="token punctuation">,</span> <span class="token string">"spades"</span><span class="token punctuation">,</span> <span class="token string">"clubs"</span><span class="token punctuation">,</span> <span class="token string">"diamonds"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//声明两个重载函数</span><span class="token keyword">function</span> <span class="token function">pickCard</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token punctuation">&#123;</span>suit<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> card<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">pickCard</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>suit<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> card<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//重载函数的具体实现</span><span class="token keyword">function</span> <span class="token function">pickCard</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Check to see if we're working with an object/array</span>    <span class="token comment">// if so, they gave us the deck and we'll pick the card</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">==</span> <span class="token string">"object"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> pickedCard <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> x<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> pickedCard<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Otherwise just let them pick the card</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">==</span> <span class="token string">"number"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> pickedSuit <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>x <span class="token operator">/</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> suit<span class="token operator">:</span> suits<span class="token punctuation">[</span>pickedSuit<span class="token punctuation">]</span><span class="token punctuation">,</span> card<span class="token operator">:</span> x <span class="token operator">%</span> <span class="token number">13</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> myDeck <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span> suit<span class="token operator">:</span> <span class="token string">"diamonds"</span><span class="token punctuation">,</span> card<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> suit<span class="token operator">:</span> <span class="token string">"spades"</span><span class="token punctuation">,</span> card<span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> suit<span class="token operator">:</span> <span class="token string">"hearts"</span><span class="token punctuation">,</span> card<span class="token operator">:</span> <span class="token number">4</span> <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> pickedCard1 <span class="token operator">=</span> myDeck<span class="token punctuation">[</span><span class="token function">pickCard</span><span class="token punctuation">(</span>myDeck<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"card: "</span> <span class="token operator">+</span> pickedCard1<span class="token punctuation">.</span>card <span class="token operator">+</span> <span class="token string">" of "</span> <span class="token operator">+</span> pickedCard1<span class="token punctuation">.</span>suit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> pickedCard2 <span class="token operator">=</span> <span class="token function">pickCard</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"card: "</span> <span class="token operator">+</span> pickedCard2<span class="token punctuation">.</span>card <span class="token operator">+</span> <span class="token string">" of "</span> <span class="token operator">+</span> pickedCard2<span class="token punctuation">.</span>suit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pickCard</span><span class="token punctuation">(</span><span class="token string">"ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//提示错误信息，不允许直接调用 pickCard(x): any</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-this关键字"><a href="#4-this关键字" class="headerlink" title="4. this关键字"></a>4. this关键字</h2><p>JavaScript中，this的值在函数被调用的时候才会指定。这是个既强大又灵活的特点，当返回一个函数或函数作为参数传递时，弄清楚上下文不是一件容易的事情。</p><p>为此，ES6的<code>箭头函数</code>新增了<code>保存函数创建时的this值</code>的能力，使this值的获得时机从<code>函数调用时</code>变成了<code>函数创建时</code>, 使用示例如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Card</span> <span class="token punctuation">&#123;</span>    suit<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>    card<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> <span class="token class-name">Deck</span> <span class="token punctuation">&#123;</span>    suits<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    cards<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">createCardPicker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">:</span> Deck<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Card<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> deck<span class="token operator">:</span> Deck <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    suits<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"hearts"</span><span class="token punctuation">,</span> <span class="token string">"spades"</span><span class="token punctuation">,</span> <span class="token string">"clubs"</span><span class="token punctuation">,</span> <span class="token string">"diamonds"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    cards<span class="token operator">:</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">52</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// NOTE: The function now explicitly specifies that its callee must be of type Deck</span>    <span class="token function-variable function">createCardPicker</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">:</span> Deck<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">let</span> pickedCard <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">52</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">let</span> pickedSuit <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>pickedCard <span class="token operator">/</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>suit<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>suits<span class="token punctuation">[</span>pickedSuit<span class="token punctuation">]</span><span class="token punctuation">,</span> card<span class="token operator">:</span> pickedCard <span class="token operator">%</span> <span class="token number">13</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> cardPicker <span class="token operator">=</span> deck<span class="token punctuation">.</span><span class="token function">createCardPicker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> pickedCard <span class="token operator">=</span> <span class="token function">cardPicker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"card: "</span> <span class="token operator">+</span> pickedCard<span class="token punctuation">.</span>card <span class="token operator">+</span> <span class="token string">" of "</span> <span class="token operator">+</span> pickedCard<span class="token punctuation">.</span>suit<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>本文介绍了TypeScript中的函数，相比JavaScript中的函数，TypeScript为函数增加了更多的约束：参数类型和返回值类型的静态化，不匹配时不允许调用。静态化参数类型后，使得函数的重载成为可能。</p><p>另一方面，对ES6中箭头函数的实现，使得<code>this</code>关键字代表的意义可以在<code>函数调用时</code>和<code>函数创建时</code>自由切换。</p><h2 id="参考的文章"><a href="#参考的文章" class="headerlink" title="参考的文章"></a>参考的文章</h2><p><a href="https://typescript.bootcss.com/functions.html">TypeScript 中文手册-函数(function)</a><br><a href="https://www.runoob.com/typescript/ts-function.html">TypeScript 函数 | 菜鸟教程</a><br><a href="https://ts.xcatliu.com/basics/type-of-function">函数的类型 - TypeScript 入门教程</a><br><a href="https://es6.ruanyifeng.com/#docs/function#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">ECMAScript 6入门</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 笔记（一、简介）</title>
      <link href="/2019/05/17/javascript/typescript-1/"/>
      <url>/2019/05/17/javascript/typescript-1/</url>
      
        <content type="html"><![CDATA[<p>由于近期时常会写一些前端页面和相关的js，每次写复杂js的时候都是一阵烦躁，对于没有语法检查、动态类型、难封装这些特点深恶痛绝。跟前端的同事了解了下他们用的技术栈，得知了一个前端利器：<strong>TypeScript</strong>。</p><p>本文将从如下几个方面，介绍TypeScript。</p><ul><li>为什么要使用TypeScript</li><li>TypeScript简介</li><li>基础类型</li></ul><span id="more"></span><h2 id="1-为什么要使用TypeScript"><a href="#1-为什么要使用TypeScript" class="headerlink" title="1. 为什么要使用TypeScript"></a>1. 为什么要使用TypeScript</h2><p>换句话说，为什么不使用JavaScript？</p><p>JavaScript存在一些明显的缺点，如动态类型、难封装等，总有很多争论，有人认为这不是缺点，反而是优点。本人的观点是，对于小而美的应用程序，这些确实是优点，但是对于复杂的大型程序，这些无疑是缺点，难于维护是最大的问题。</p><blockquote><p><a href="https://www.sitepoint.com/10-languages-compile-javascript/">《10 Languages That Compile to JavaScript》</a><br/></p><p>会有这么多替代(或补充)JavaScript的语言，正说明了JavaScript存在缺陷。</p></blockquote><p>而TypeScript具备以下优点：</p><ol><li>完全的面向对象，类和对象。基于此，TypeScript将成为提高开发人员开发效率的利器，它很容易理解和接受。</li><li>静态类型，在编写代码的阶段，TypeScript就能够找到大部分的错误。</li><li>IDE支持良好，便于安全地重构。</li></ol><h2 id="2-TypeScript简介"><a href="#2-TypeScript简介" class="headerlink" title="2 TypeScript简介"></a>2 TypeScript简介</h2><p><a href="https://www.typescriptlang.org/index.html">TypeScript</a>是一个开源编程语言，由Microsoft主导研发，它的语法更严格，增加了静态类型的特性，从而使开发者在编写代码的时候就能够发现大部分错误。</p><p>TypeScript旨在开发大型应用程序并转换为JavaScript。由于TypeScript是JavaScript的超集，现有的JavaScript程序也是有效的TypeScript程序。</p><p>TypeScript编译器本身是用TypeScript编写的，并编译为JavaScript，它是根据Apache 2.0许可证授权的。</p><p>C#的首席架构师，Delphi和Turbo Pascal的创建者Anders Hejlsberg一直致力于TypeScript的开发。</p><blockquote><p><strong>ECMAScript 和 TypeScript</strong><br/></p><p><a href="https://www.typescriptlang.org/index.html">TypeScript</a>支持<a href="https://www.ecma-international.org/ecma-262/6.0/index.html">ECMAScript6</a>标准（实际上相当于是对ECMAScript6的提前实现），并且能将代码根据需求转换为 ES3&#x2F;5&#x2F;6。这意味着开发者可以通过TypeScript使用最新的ECMAScript特性，无需再考虑兼容性的问题。</p></blockquote><h2 id="3-基础类型"><a href="#3-基础类型" class="headerlink" title="3. 基础类型"></a>3. 基础类型</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//布尔值</span><span class="token keyword">let</span> <span class="token literal-property property">isDone</span><span class="token operator">:</span> boolean <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//数字</span><span class="token keyword">let</span> <span class="token literal-property property">decLiteral</span><span class="token operator">:</span> number <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token comment">//字符串</span><span class="token keyword">let</span> <span class="token literal-property property">name</span><span class="token operator">:</span> string <span class="token operator">=</span> <span class="token string">"bob"</span><span class="token punctuation">;</span><span class="token comment">//数组</span><span class="token keyword">let</span> <span class="token literal-property property">list</span><span class="token operator">:</span> number<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token literal-property property">list</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span>number<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//元组</span><span class="token keyword">let</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token punctuation">[</span>string<span class="token punctuation">,</span> number<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// Declare a tuple type</span>x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'hello'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Initialize it OK</span>x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Initialize it incorrectly Error</span><span class="token comment">//枚举 enum</span><span class="token keyword">enum</span> Color <span class="token punctuation">&#123;</span>Red<span class="token punctuation">,</span> Green<span class="token punctuation">,</span> Blue<span class="token punctuation">&#125;</span><span class="token keyword">let</span> <span class="token literal-property property">c</span><span class="token operator">:</span> Color <span class="token operator">=</span> Color<span class="token punctuation">.</span>Green<span class="token punctuation">;</span><span class="token comment">//任意值 any</span><span class="token keyword">let</span> <span class="token literal-property property">notSure</span><span class="token operator">:</span> any <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>notSure<span class="token punctuation">.</span><span class="token function">ifItExists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// okay, ifItExists might exist at runtime</span>notSure<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// okay, toFixed exists (but the compiler doesn't check)</span><span class="token keyword">let</span> <span class="token literal-property property">prettySure</span><span class="token operator">:</span> Object <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>prettySure<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: Property 'toFixed' doesn't exist on type 'Object'.</span><span class="token comment">//空值 void</span><span class="token keyword">function</span> <span class="token function">warnUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">&#123;</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"This is my warning message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Null 和 Undefined</span><span class="token keyword">let</span> <span class="token literal-property property">u</span><span class="token operator">:</span> <span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span><span class="token comment">// Not much else we can assign to these variables!</span><span class="token keyword">let</span> <span class="token literal-property property">n</span><span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//Never</span><span class="token keyword">function</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">message</span><span class="token operator">:</span> string</span><span class="token punctuation">)</span><span class="token operator">:</span> never <span class="token punctuation">&#123;</span><span class="token comment">// 返回never的函数必须存在无法达到的终点</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">fail</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 推断的返回值类型为never</span>    <span class="token keyword">return</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Something failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">infiniteLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> never <span class="token punctuation">&#123;</span><span class="token comment">// 返回never的函数必须存在无法达到的终点</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//类型断言</span><span class="token keyword">let</span> <span class="token literal-property property">someValue</span><span class="token operator">:</span> any <span class="token operator">=</span> <span class="token string">"this is a string"</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token literal-property property">strLength</span><span class="token operator">:</span> number <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>string<span class="token operator">></span>someValue<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token literal-property property">someValue</span><span class="token operator">:</span> any <span class="token operator">=</span> <span class="token string">"this is a string"</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token literal-property property">strLength</span><span class="token operator">:</span> number <span class="token operator">=</span> <span class="token punctuation">(</span>someValue <span class="token keyword">as</span> string<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：我们鼓励尽可能地使用–strictNullChecks</p></blockquote><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>本文介绍了TypeScript的基础概念，以及它相比JavaScript的优点。作为静态类型语言，它提供了如下11种类型：</p><ol><li>布尔值 boolean</li><li>数字 number</li><li>字符串 string</li><li>数组 []或 Array&lt;元素类型&gt;</li><li>元组</li><li>枚举 enum</li><li>任意值 any</li><li>空值 void</li><li>Null null</li><li>Undefined undefined</li><li>Never never</li></ol><h2 id="参考的文章"><a href="#参考的文章" class="headerlink" title="参考的文章"></a>参考的文章</h2><p><a href="https://en.wikipedia.org/wiki/Microsoft_TypeScript">Microsoft TypeScript</a><br><a href="https://www.jianshu.com/p/9bc987ebb85c">解惑ECMAScript&#x2F;JavaScript&#x2F;TypeScript和CoffeeScript等概念</a><br><a href="https://typescript.bootcss.com/basic-types.html">TypeScript 中文手册</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识CPU</title>
      <link href="/2019/04/17/java/cpu-usage/"/>
      <url>/2019/04/17/java/cpu-usage/</url>
      
        <content type="html"><![CDATA[<p>以前听说过一个面试题：如何使CPU使用率达到100%的JAVA代码应该如何编写？笔者心想开几个死循环的线程也就差不多了，启动6个死循环线程，在mac系统中使用top查看，发现cpu达到了600%+，机器CPU是4核的，跑到400%还能接受，600%就真的不懂了。</p><p><img src="/images/2019/05/cpu-rate.png" alt="cpu-rate"></p><p>由此，笔者发现围绕CPU，自身有一些知识盲点，曾经那些计算机基础课程全部还给老师了^_^，所以就有了这篇文章。</p><span id="more"></span><h2 id="1-什么是CPU"><a href="#1-什么是CPU" class="headerlink" title="1. 什么是CPU"></a>1. 什么是CPU</h2><p>中央处理器（英文Central Processing Unit，CPU）是一台计算机的运算核心和控制核心，其功能主要是解释计算机指令以及处理计算机软件中的数据。</p><p>CPU的根本任务就是执行指令，对计算机来说最终都是一串由 0 和 1 组成的序列。CPU从逻辑上可以划分成3个模块，分别是控制单元、运算单元和存储单元。其内部架构如下：</p><p><img src="/images/2019/05/cpu-principle.png" alt="cpu-principle"></p><p>差不多所有的CPU的运作原理可分为四个阶段：提取（Fetch）、解码（Decode）、执行（Execute）和写回（Writeback）。CPU从存储器或高速缓冲存储器中取出指令，放入指令寄存器，并对指令译码，并执行指令。</p><h2 id="2-描述CPU的关键参数"><a href="#2-描述CPU的关键参数" class="headerlink" title="2. 描述CPU的关键参数"></a>2. 描述CPU的关键参数</h2><p>这一节着重介绍几个描述CPU的关键概念：主频、缓存、核心数、线程数、负载和使用率。</p><h2 id="2-1-主频"><a href="#2-1-主频" class="headerlink" title="2.1 主频"></a>2.1 主频</h2><p>CPU的主频，即CPU内核工作的时钟频率（CPU ClockSpeed）。通常所说的某某CPU是多少兆赫的，而这个多少兆赫就是“CPU的主频”。</p><p>以Intel Core i3-8350k为例，它的默频是4GHz，意味着它内部时钟频率为4GHz，一秒钟可以产生40亿个脉冲信号，换句话说每一个脉冲信号仅仅用时0.25ns（时钟周期）。时钟周期作为CPU操作的最小时间单位，内部的所有操作都是以这个时钟周期作为基准。一般来说CPU都是以时钟脉冲的上升沿作为执行指令的基准，频率越高，CPU执行的指令数越多，工作速度越快。</p><p>很多人认为CPU的主频就是其运行速度，其实不然。CPU的主频表示在CPU内数字脉冲信号震荡的速度，与CPU实际的运算能力并没有直接关系。主频和实际的运算速度存在一定的关系，但目前还没有一个确定的公式能够定量两者的数值关系，因为CPU的运算速度还要看CPU的流水线的各方面的性能指标（缓存、指令集，CPU的位数等等）。</p><h2 id="2-3-缓存"><a href="#2-3-缓存" class="headerlink" title="2.3 缓存"></a>2.3 缓存</h2><p>在计算机系统中，CPU高速缓存（英语：CPU Cache，在本文中简称缓存）是用于减少处理器访问内存所需平均时间的部件。在金字塔式存储体系中它位于自顶向下的第二层，仅次于CPU寄存器。其容量远小于内存，但速度却可以接近处理器的频率。</p><h2 id="2-4-核心数"><a href="#2-4-核心数" class="headerlink" title="2.4 核心数"></a>2.4 核心数</h2><p>CPU的核心数是指物理上，也就是硬件上存在着几个核心。比如，双核就是包括2个相对独立的CPU核心单元组，四核就包含4个相对独立的CPU核心单元组。</p><h2 id="2-5-线程数-对应逻辑CPU"><a href="#2-5-线程数-对应逻辑CPU" class="headerlink" title="2.5 线程数(对应逻辑CPU)"></a>2.5 线程数(对应逻辑CPU)</h2><p>CPU 的线程数概念仅仅只针对 Intel 的 CPU 才有用，因为它是通过 Intel 超线程技术来实现的，最早应用在 Pentium4 上。如果没有超线程技术，一个 CPU 核心对应一个线程（因此对于一个CPU，线程数总是大于或等于核心数的）。所以，对于 AMD 的 CPU 来说，只有核心数的概念，没有线程数的概念。</p><p>CPU 之所以要增加线程数，是源于多任务处理的需要：线程数越多，越有利于同时运行多个程序，因为线程数等同于在某个瞬间 CPU 能同时并行处理的任务数。因此，线程数是一种逻辑的概念，简单地说，就是模拟出的 CPU 核心数。一个核心最少对应一个线程，但英特尔有个超线程技术可以把一个物理线程模拟出两个线程来用，充分发挥 CPU 性能，即一个核心可以有两个到多个线程。</p><blockquote><p>正是因为逻辑CPU的存在，才会导致本文一开始产生的问题，4核cpu的使用率可以达到400%以上。</p></blockquote><p>linux 中查看cpu核数和线程数：</p><pre class="line-numbers language-none"><code class="language-none"># 查看 cpu 型号sudo dmidecode -s processor-version# 查看 cpu 个数grep &#39;physical id&#39; &#x2F;proc&#x2F;cpuinfo | sort -u | wc -l# 查看核心数grep &#39;core id&#39; &#x2F;proc&#x2F;cpuinfo | sort -u | wc -l# 查看线程数grep &#39;processor&#39; &#x2F;proc&#x2F;cpuinfo | sort -u | wc -l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mac中查看cpu核数和线程数：</p><pre class="line-numbers language-none"><code class="language-none"># 查看核心数sysctl hw.physicalcpu# 查看线程数sysctl hw.logicalcpu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-6-负载核-vs-使用率"><a href="#2-6-负载核-vs-使用率" class="headerlink" title="2.6 负载核 vs 使用率"></a>2.6 负载核 vs 使用率</h2><p>这两个从一定程度上都可以反映一台机器的繁忙程度.</p><p>cpu使用率反映的是当前cpu的繁忙程度，忽高忽低的原因在于占用cpu处理时间的进程可能处于io等待状态但却还未释放进入wait。</p><p>平均负载（load average）是指某段时间内占用cpu时间的进程和等待cpu时间的进程数，这里等待cpu时间的进程是指等待被唤醒的进程，不包括处于wait状态进程。</p><p>以上分析可以看出，一台机器很有可能处于低cpu使用率高负载的情况，因此看机器的繁忙程度应该结合两者，从实际的使用情况观察，自己的一台双核志强2.8GHZ，2G内存的机器在平均负载到50左右，cpu使用率才接近100%（应用有不少io操作），这种情况下应用还算流畅，实际访问延迟不是很高。因此在cpu还空闲的情况下，如何提高io响应是减少负载的关键，很多人认为负载到几十了机器就非常繁忙了，我倒觉得如果这个时候cpu使用率比较低，则负载高可能不能很好说明问题，一旦cpu处理的进程处理完后，那些等待的进程也能立刻得到响应，这种情况下应该优化io读写速度。真到cpu使用率一直90%以上，即使平均负载只有个位数（比如某一个进程一直在运算），那机器其实也已经繁忙了。</p><blockquote><p><strong>系统负荷的经验法则</strong><br/></p><p>1.0是系统负荷的理想值吗？<br>不一定，系统管理员往往会留一点余地，当这个值达到0.7，就应当引起注意了。经验法则是这样的：<br>当系统负荷持续大于0.7，你必须开始调查了，问题出在哪里，防止情况恶化。<br>当系统负荷持续大于1.0，你必须动手寻找解决办法，把这个值降下来。<br>当系统负荷达到5.0，就表明你的系统有很严重的问题，长时间没有响应，或者接近死机了。你不应该让系统达到这个值。</p></blockquote><h2 id="3-使用top命令进行性能分析"><a href="#3-使用top命令进行性能分析" class="headerlink" title="3. 使用top命令进行性能分析"></a>3. 使用top命令进行性能分析</h2><p>top命令能够实时显示系统中各个进程的资源占用情况，默认5秒刷新一次进程列表。以mac系统为例，对top命令的结果说明如下：</p><table><thead><tr><th>实例</th><th>说明</th></tr></thead><tbody><tr><td>Processes: 315 total, 2 running, 313 sleeping,1728 threads</td><td>进程数</td></tr><tr><td>Load Avg: 2.42, 2.41, 2.19</td><td>平均负载，1分钟系统负载、5分钟系统负载，15分钟系统负载</td></tr><tr><td>CPU usage: 6.45% user, 9.67% sys, 83.87% idle</td><td>cpu使用率，用户使用率、系统使用率、空闲</td></tr><tr><td>SharedLibs: 146M resident, 51M data, 31M linkedit.</td><td>共享库</td></tr><tr><td>MemRegions: 53139 total, 4178M resident, 143M private, 766M shared.</td><td>内存区域的数量和总大小</td></tr><tr><td>PhysMem: 8156M used (1589M wired), 33M unused.</td><td>物理内存使用</td></tr><tr><td>VM: 1422G vsize, 1110M framework vsize, 0(0) swapins, 0(0) swapouts.</td><td></td></tr><tr><td>Networks: packets: 541527&#x2F;741M in, 107642&#x2F;129M out.</td><td>输入和输出网络数据包的数量和总大小</td></tr><tr><td>Disks: 122972&#x2F;3663M read, 28637&#x2F;519M written.</td><td>磁盘读写的数量和总大小</td></tr></tbody></table><table><thead><tr><th>表头</th><th>说明</th></tr></thead><tbody><tr><td>PID</td><td>进程 id</td></tr><tr><td>COMMAND</td><td>命令</td></tr><tr><td>%CPU</td><td>cup 占比</td></tr><tr><td>TIME</td><td>运行时间</td></tr><tr><td>#TH</td><td>线程数量</td></tr><tr><td>#WQ</td><td></td></tr><tr><td>#PORT</td><td></td></tr><tr><td>MEM</td><td>内存</td></tr><tr><td>PURG</td><td></td></tr><tr><td>CMPRS</td><td>表示属于您的进程的压缩数据的字节数（不是位）。</td></tr><tr><td>PGRP</td><td></td></tr><tr><td>PPID</td><td></td></tr><tr><td>STATE</td><td></td></tr><tr><td>BOOSTS</td><td></td></tr><tr><td>%CPU_ME</td><td></td></tr><tr><td>%CPU_OTHRS</td><td></td></tr><tr><td>UID</td><td></td></tr></tbody></table><p>命令示例：</p><pre class="line-numbers language-none"><code class="language-none"># 查看文档man top# 帮助信息top -h# 根据CPU使用量(降序)和驻留内存大小(升序)对进程进行排序，每隔5秒对显示进行采样和更新，并将显示限制为20个进程。top -o cpu -O +rsize -s 5 -n 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>top排序</strong><br/></p><p>在linux机器上使用top命令。常用的快键键是:</p><ul><li>p键 - 按 cpu 使用率排序</li><li>m键 - 按内存使用量排序<br>这2个快捷键在mac上不一样。对应的是，先输入o，然后输入cpu则按cpu使用量排序，输入rsize则按内存使用量排序。</li></ul></blockquote><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>本文简单介绍了CPU相关的基础概念、关键参数、top命令分析。作为软件开发工程师，了解这些知识后面对一些性能问题或性能瓶颈时，可以处理得更加得心应手。</p><h2 id="参考的文章"><a href="#参考的文章" class="headerlink" title="参考的文章"></a>参考的文章</h2><p><a href="https://www.cnblogs.com/onepixel/p/8724526.html">简单介绍 CPU 的工作原理</a><br><a href="https://blog.csdn.net/he_jian1/article/details/41208915">8核、6核、4核、双核CPU是什么意思</a><br><a href="https://www.expreview.com/57334.html">超能课堂(111)：讲了这么多年的CPU频率，到底是什么？</a><br><a href="https://segmentfault.com/a/1190000008094866">mac获取cpu信息</a><br><a href="http://ju.outofmemory.cn/entry/173285">“Physical CPU”还是“logic CPU”？</a><br><a href="https://durant35.github.io/2017/05/16/hsw_CPUWipeoutIlliteracy/">CPU 扫盲（核心数&#x2F;线程数）</a><br><a href="https://www.cnblogs.com/muahao/p/6492665.html">理解Linux CPU负载和 CPU使用率</a><br><a href="https://www.cnblogs.com/cq90/p/8082311.html">CPU使用率和负载，物理CPU个数，核数，线程数</a></p>]]></content>
      
      
      <categories>
          
          <category> system </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Batch 快速入门</title>
      <link href="/2019/03/12/spring-batch/spring-batch-1/"/>
      <url>/2019/03/12/spring-batch/spring-batch-1/</url>
      
        <content type="html"><![CDATA[<p>这篇文章中，我们将从如下四个方面对Spring Batch进行简要介绍， 旨在使读者清楚什么是Spring Batch，以及如何使用它。</p><ul><li>Spring Batch简介</li><li>批处理中的基础概念</li><li>简单示例</li><li>并行处理</li></ul><span id="more"></span><h2 id="1-Spring-Batch简介"><a href="#1-Spring-Batch简介" class="headerlink" title="1. Spring Batch简介"></a>1. Spring Batch简介</h2><p>Spring Batch是一个轻量级的、完善的批处理框架，旨在帮助企业建立健壮、高效的批处理应用。Spring Batch提供了大量可重用的组件，包括了日志、追踪、事务、任务作业统计、任务重启、跳过、重试、资源管理。</p><p>对于数据量大、需要较高处理性能的批处理任务，Spring Batch同样提供了高级功能和特性来支持，比如远程分区、远程分块功能。</p><p>Spring Batch是一个批处理应用框架，不是调度框架，需要和调度框架(如 Quartz、Tivoli、Control-M、Cron 等)合作来构建完成的批处理任务。</p><h3 id="1-1-为什么要使用Spring-Batch"><a href="#1-1-为什么要使用Spring-Batch" class="headerlink" title="1.1 为什么要使用Spring Batch"></a>1.1 为什么要使用Spring Batch</h3><p>假设我们有这样一个批处理需求：它需要处理大量的数据，处理较多的步骤，同时希望处理时长越短越好；第一期需求做完，第二期需求很可能就是：支持重试、事务、监控等功能。</p><p>通常，批处理的需求都是类似的，在没有Spring Batch之前，由于没有统一的标准，大量企业重复开发类似的功能。而<a href="https://www.accenture.com/">Accenture</a>和SpringSource紧密合作后诞生的Spring Batch，使批处理框架和工具更加标准化了。</p><blockquote><p><strong>注意</strong><br/></p><p>只有当场景足够复杂、数据量足够大时，使用Spring Batch才有意义；如果仅仅是简单业务处理，数据量也不大，就没有必要使用Spring Batch了。</p></blockquote><h3 id="1-2-架构分层及常见策略"><a href="#1-2-架构分层及常见策略" class="headerlink" title="1.2 架构分层及常见策略"></a>1.2 架构分层及常见策略</h3><p>下图是Spring Batch分层体系结构的草图:</p><p><img src="/images/2019/05/architecture.png" alt="architecture"></p><ul><li>Application部分是开发人员根据特定业务逻辑编写的。</li><li>Batch Core包含启动和控制批处理作业所需的核心运行时类，它包含JobLauncher，Job和Step实现。</li><li>Batch Infrastructure提供一些基础的通用功能，Application和Batch Core都建立在Batch Infrastructure之上。</li></ul><p>开发人员设计批处理的Application时，业务逻辑应该可以拆分为一系列步骤，这些步骤可以使用如下标准模型实现：</p><table><thead><tr><th>策略名称</th><th>说明</th></tr></thead><tbody><tr><td>转换程序(Conversion Applications)</td><td>对于外部系统提供的文件(如Excel)，必须创建转换程序，用来转换这些文件。</td></tr><tr><td>验证程序(Validation Applications)</td><td>对数据做正确性、一致性的验证，验证通常发生开头或结尾。</td></tr><tr><td>提取程序(Extract Applications)</td><td>从数据库或输入文件中读取一组记录，按照既定规则选择记录，然后将其写入到输出文件中。</td></tr><tr><td>提取&#x2F;更新程序(Extract&#x2F;Update Applications)</td><td>从数据库或输入文件中读取一组记录，根据每条记录的特点，对数据进行更改，然后将其写入到输出文件中。</td></tr><tr><td>处理和更新程序(Processing and Updating Applications)</td><td>对来自验证程序或提取程序的输入事务，执行相应的处理，通常包括读取所需数据，再更新处理结果。</td></tr><tr><td>输出&#x2F;格式化程序(Output&#x2F;Format Applications)</td><td>应用程序读取输入文件，根据标准格式从该记录中重组数据，并生成输出文件以便打印或传输到另一个程序或系统。</td></tr></tbody></table><p>每个Application可以使一些实用工具，例如排序、拆分、合并。</p><h2 id="2-批处理中的基础概念"><a href="#2-批处理中的基础概念" class="headerlink" title="2. 批处理中的基础概念"></a>2. 批处理中的基础概念</h2><p>下图是使用了几十年的批处理参考体系结构的简化版本，它包含了批处理中涉及的概念。</p><p><img src="/images/2019/04/batch-stereotypes.png" alt="Batch Stereotypes"></p><table><thead><tr><th>概念</th><th>子类型</th><th>说明</th></tr></thead><tbody><tr><td>JobRepository</td><td></td><td>为JobLauncher、Job和Step实现提供CRUD操作</td></tr><tr><td>JobLauncher</td><td></td><td>运行Job的入口</td></tr><tr><td>Job</td><td></td><td>封装整个批处理过程的实体</td></tr></tbody></table><pre><code>| JobInstance |  代表一个Job的运行实例，不同的运行实例，其关联的JobParameters不相同的，例如日期不同| JobParameters |  获得一个JobInstance时，必须指定对应的JobParameters| JobExecution  |  代表Job的一次实际执行情况，它可能执行成功或失败</code></pre><p>Step | | 封装了批处理作业的一个独立的、顺序的阶段，多个Step按顺序构成了一个Job<br>  | StepExecution  |  代表Step的一次实际执行情况<br>Item Reader | | Step中使用Item Reader输入数据<br>Item Writer | | Step中使用Item Writer输出数据<br>Item Processor | | Step中使用Item Processor处理数据</p><p>其中Job和Step之间的关系如下：</p><p><img src="/images/2019/05/step.png" alt="Step"></p><p>除了上述的7个基础概念，还有个名为<code>ExecutionContext</code>的封装类，<code>ExecutionContext</code>是一个key&#x2F;value形式的数据存储，开发人员可以向其中放入自定义的运行时数据；它有两个作用域StepExecution和JobExecution，相互之间是隔离的。</p><h2 id="3-简单示例"><a href="#3-简单示例" class="headerlink" title="3. 简单示例"></a>3. 简单示例</h2><p>使用Spring Boot配置一个批处理Job比较简单，添加pom依赖后，再新增一个<code>BatchConfiguration</code>类即可，其内容如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableBatchProcessing</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BatchConfiguration</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">public</span> <span class="token class-name">JobBuilderFactory</span> jobBuilderFactory<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">public</span> <span class="token class-name">StepBuilderFactory</span> stepBuilderFactory<span class="token punctuation">;</span>    <span class="token comment">// tag::readerwriterprocessor[]</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">FlatFileItemReader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">></span></span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FlatFileItemReaderBuilder</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token string">"personItemReader"</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">resource</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ClassPathResource</span><span class="token punctuation">(</span><span class="token string">"sample-data.csv"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">delimited</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">names</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">"firstName"</span><span class="token punctuation">,</span> <span class="token string">"lastName"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">fieldSetMapper</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BeanWrapperFieldSetMapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>                <span class="token function">setTargetType</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">PersonItemProcessor</span> <span class="token function">processor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PersonItemProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">JdbcBatchItemWriter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">></span></span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token class-name">DataSource</span> dataSource<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JdbcBatchItemWriterBuilder</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">itemSqlParameterSourceProvider</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BeanPropertyItemSqlParameterSourceProvider</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">sql</span><span class="token punctuation">(</span><span class="token string">"INSERT INTO people (first_name, last_name) VALUES (:firstName, :lastName)"</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">dataSource</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// end::readerwriterprocessor[]</span>    <span class="token comment">// tag::jobstep[]</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Job</span> <span class="token function">importUserJob</span><span class="token punctuation">(</span><span class="token class-name">JobCompletionNotificationListener</span> listener<span class="token punctuation">,</span> <span class="token class-name">Step</span> step1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> jobBuilderFactory<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"importUserJob"</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">incrementer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RunIdIncrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">listener</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">flow</span><span class="token punctuation">(</span>step1<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Step</span> <span class="token function">step1</span><span class="token punctuation">(</span><span class="token class-name">JdbcBatchItemWriter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">></span></span> writer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> stepBuilderFactory<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"step1"</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">,</span> <span class="token class-name">Person</span><span class="token punctuation">></span></span> <span class="token function">chunk</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">reader</span><span class="token punctuation">(</span><span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">processor</span><span class="token punctuation">(</span><span class="token function">processor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">writer</span><span class="token punctuation">(</span>writer<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// end::jobstep[]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不难看出，配置一个简单的批处理任务需要的创建的Bean依次是：<code>ItemReader</code>、<code>ItemProcessor</code>、<code>ItemWriter</code>、<code>Step</code>、<code>Job</code>，这与上文提到概念大体相符(<a href="https://gitee.com/ypk1226/sample-spring-batch/tree/master/simple">查看完整示例</a>)。</p><p>以<code>SpringApplication.run(Application.class, args)</code>的方式启动服务后，Job将通过<code>JobLauncherCommandLineRunner</code>自动运行已配置的Job，因此不需要再使用<code>JobLauncher</code>显式启动任务。</p><h3 id="3-1-分片处理-Chunk-oriented-Processing"><a href="#3-1-分片处理-Chunk-oriented-Processing" class="headerlink" title="3.1 分片处理(Chunk-oriented Processing)"></a>3.1 分片处理(Chunk-oriented Processing)</h3><p>Spring batch在配置Step时采用的是面向Chunk处理的机制，即每次读取一条数据，再处理一条数据，累积到一定数量后再一次性交给writer进行写入操作。这样可以最大化的优化写入效率，整个事务也是基于Chunk来进行。其流程如下:</p><p><img src="/images/2019/05/chunk-oriented.png" alt="chunk-oriented"></p><h3 id="3-2-监听-Listener"><a href="#3-2-监听-Listener" class="headerlink" title="3.2 监听(Listener)"></a>3.2 监听(Listener)</h3><p>可以实现Spring Batch提供的Listener接口(位于<code>org.springframework.batch.core.listener</code>包内)，监听任务的运行情况。上述示例中使用了<code>JobExecutionListenerSupport</code>，它用于监听Job的开始与结束。</p><h2 id="4-并行处理"><a href="#4-并行处理" class="headerlink" title="4. 并行处理"></a>4. 并行处理</h2><p>为了加快处理速度，批处理任务通常需要并行处理，一般情况下，这也是在设计批处理任务时最复杂的地方。 Spring Batch为任务的并行处理提供了强有力的支持。</p><p>并行处理在顶层可以分为以下两类：</p><ul><li>单进程，多线程</li><li>多进程</li></ul><p>这两类可以继续细分为如下四类：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>多线程Step(单进程)</td><td>在一个Step内部，使用多线程并行执行。</td></tr><tr><td>并行Step(单进程)</td><td>在多个Step之间，使用多线程并行执行。</td></tr><tr><td>远程分块(多进程)</td><td>分割一个Step，使其在多个进程中同时运行。</td></tr><tr><td>远程分区(多进程)</td><td>为Step分区，每个区是一个单独的进程，各个分区内都包含ItemReader、ItemWriter、ItemProcessor。</td></tr></tbody></table><h3 id="4-1-多线程Step-单进程"><a href="#4-1-多线程Step-单进程" class="headerlink" title="4.1 多线程Step(单进程)"></a>4.1 多线程Step(单进程)</h3><p>在一个Step内部使用多线程的方式运行，通过指定<code>TaskExecutor</code>开启多线程处理。另外，使用Spring Batch提供的ItemWriter和ItemReader的一些实现时，需要留意是否是线程安全的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">TaskExecutor</span> <span class="token function">taskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SimpleAsyncTaskExecutor</span><span class="token punctuation">(</span><span class="token string">"spring_batch"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">Step</span> <span class="token function">sampleStep</span><span class="token punctuation">(</span><span class="token class-name">TaskExecutor</span> taskExecutor<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stepBuilderFactory<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"sampleStep"</span><span class="token punctuation">)</span>                                <span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token function">chunk</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>                                <span class="token punctuation">.</span><span class="token function">reader</span><span class="token punctuation">(</span><span class="token function">itemReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                <span class="token punctuation">.</span><span class="token function">writer</span><span class="token punctuation">(</span><span class="token function">itemWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                <span class="token punctuation">.</span><span class="token function">taskExecutor</span><span class="token punctuation">(</span>taskExecutor<span class="token punctuation">)</span>                                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-并行Step-单进程"><a href="#4-2-并行Step-单进程" class="headerlink" title="4.2 并行Step(单进程)"></a>4.2 并行Step(单进程)</h3><p>通过<code>Flow</code>提供的机制，开发人员可以方便地组合Step，使多个Step并行执行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">Job</span> <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> jobBuilderFactory<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"job"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token function">splitFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token function">step4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">//builds FlowJobBuilder instance</span>        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//builds Job instance</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">Flow</span> <span class="token function">splitFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FlowBuilder</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SimpleFlow</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token string">"splitFlow"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token function">taskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">flow1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">flow2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">Flow</span> <span class="token function">flow1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FlowBuilder</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SimpleFlow</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token string">"flow1"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token function">step1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token function">step2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">Flow</span> <span class="token function">flow2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FlowBuilder</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SimpleFlow</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token string">"flow2"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token function">step3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">TaskExecutor</span> <span class="token function">taskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SimpleAsyncTaskExecutor</span><span class="token punctuation">(</span><span class="token string">"spring_batch"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-远程分块-多进程"><a href="#4-3-远程分块-多进程" class="headerlink" title="4.3 远程分块(多进程)"></a>4.3 远程分块(多进程)</h3><p>有时单进程并不能满足性能需求，尤其是ItemProcessor处理耗时较长时，Spring Batch提供了所谓“远程分块”的功能，即将Step处理分割为多个进程，通过一些中间件相互通信。</p><p><img src="/images/2019/05/remote-chunk.png" alt="remote-chunk"></p><h3 id="4-4-远程分区-多进程"><a href="#4-4-远程分区-多进程" class="headerlink" title="4.4 远程分区(多进程)"></a>4.4 远程分区(多进程)</h3><p>当ItemProcessor不是导致瓶颈的相关I&#x2F;O时，可以使用远程分区，它将Step拆分到了不同的进程中。</p><p><img src="/images/2019/05/remote-chunk2.png" alt="remote-chunk2"></p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>本文介绍了Spring Batch的基本概念、基础使用方式以及Spring Batch对并行处理的支持。除此之外，Spring Batch还有很多其它功能，例如事务管理、重启、重试、跳过、日志等功能。</p><p>希望通过阅读本文，读者可以对Spring Batch有一个整体的印象，以便在需要解决复杂批处理问题时，能够联想到该框架。</p><h2 id="参考的文章"><a href="#参考的文章" class="headerlink" title="参考的文章"></a>参考的文章</h2><p><a href="https://baike.baidu.com/item/Spring%20Batch/7914867?fr=aladdin">Spring Batch_百度百科</a><br><a href="https://docs.spring.io/spring-batch/4.1.x/reference/html/index-single.html">Spring Batch - Reference Documentation</a></p>]]></content>
      
      
      <categories>
          
          <category> spring-batch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作流引擎Activiti快速入门</title>
      <link href="/2019/02/24/workflow/activiti-1/"/>
      <url>/2019/02/24/workflow/activiti-1/</url>
      
        <content type="html"><![CDATA[<p>Activiti是一个用Java编写的开源工作流引擎，可以执行BPMN 2.0中描述的业务流程。Activiti是Alfresco的Alfresco Process Services (APS)的基础，而Alfresco是Activiti项目的主要赞助商。</p><span id="more"></span><p>本文旨在帮助读者理解Activiti的工作机制，使其可以迅速上手该框架。本文将从这几个方面简单介绍了Activiti工作流引擎：</p><p>1、为什么要使用工作流引擎<br>2、BPMN2.0规范简介<br>3、开源BPMN项目对比<br>4、Activiti核心API<br>5、常见API调用步骤</p><h1 id="1-为什么要使用工作流引擎"><a href="#1-为什么要使用工作流引擎" class="headerlink" title="1. 为什么要使用工作流引擎"></a>1. 为什么要使用工作流引擎</h1><p>假定我们有一个支付订单状态需要维护，它的状态图如下：</p><p><img src="/images/2019/03/simple-state.png" alt="simple-state"></p><p>它的状态跃迁自左向右，清晰名了，而且没有<strong>处理角色</strong>的概念，此时我们使用代码控制好状态流转即可，无需使用框架。</p><p>再来看另外一个场景，假定我们有一个企业内部采购订单，它的状态图如下：</p><p><img src="/images/2019/03/stock-state.png" alt="stock-state"></p><p>这个采购订单的状态复杂多变，状态的转换不稳定性很强，随时有可能增加新的状态；而且不同状态的处理人也是不同的，存在权限管理功能，若此时我们仍然使用一个状态字段来维持状态变更，无疑会困难重重。</p><p>工作流引擎就是为了解决这类问题而生的，我们可以观察当前实体(如支付订单、采购订单)是否具有如下特性，由此来确定是否需要引入工作流引擎。</p><ol><li>状态的个数及其稳定性，个数多且不稳定，适合使用工作流引擎。</li><li>每个状态的处理人，处理人角色多且不稳定，适合使用工作流引擎。</li></ol><p><strong>工作流引擎</strong>实际上是放大了状态管理的功能，它根据既有流程图（基于BPMN2规范）的指示，指定每一次状态跃迁的处理角色，在状态变更时持久化评论、表单、附件等数据，保存了完整处理轨迹。</p><blockquote><p><strong>工作流引擎 vs 规则引擎</strong><br/></p><ol><li>工作流更像是管理状态跃迁的，规则引擎不关心状态跃迁，它关注的是处理过程中复杂条件的组合。</li><li>工作流引擎中包含“人”的任务，天生包含处理人角色控制；规则引擎不关心“人”的任务，不做特殊区分。</li><li>工作流引擎是宏观控制、规则引擎是微观控制。<br>常有人拿这两块内容做对比，笔者理解他们的侧重完全不同，没有太大的可比性。</li></ol></blockquote><h1 id="2-BPMN2-0规范简介"><a href="#2-BPMN2-0规范简介" class="headerlink" title="2. BPMN2.0规范简介"></a>2. BPMN2.0规范简介</h1><p>业务流程模型和标记法（BPMN, Business Process Model and Notation）是一套图形化表示法，用于以图形的方式详细说明各种业务流程。</p><p>它最初由业务流程管理倡议组织（BPMI, Business Process Management Initiative）开发，名称为”Business Process Modeling Notation”，即“业务流程建模标记法”。BPMI于2005年与对象管理组织（OMG, Object Management Group）合并。2011年1月OMG发布2.0版本（时至今日，没人会用1.0版本了），同时改为现在的名称。</p><p>BPMN2.0规范的实现，实质上是一个按照特定规范编写的XML文件，使用特定的BPMN设计器，即可以图形化的形式查看和编辑该文件。Activiti以代码的形式实现了这套图形化表示法，使任务的流转依赖图形，而非具体的实现代码。</p><blockquote><p><strong>UML vs BPMN</strong><br>UML和BPMN之间唯一的正式关系是OMG维护两个开放标准。<br>UML(统一建模语言)作为一种可视化的建模语言，其中的活动图也适用于流程建模，但其支持深度不够。<br>BPMN诞生时间晚于UML，据称从某种意义上讲，UML Activity Diagrams是BPMN的一个子集，也是BPMN的历史前身。</p></blockquote><p><img src="/images/2019/03/bpmn-structure.png" alt="bpmn-structure"></p><p>如上图所示，BPMN2.0规范包含了三个部分Gateway(网关)、Event(事件)、Activities(活动)。</p><p>下面我们通过一个简单的流程定义文件来理解BPMN2.0规范。读者也可以访问这个<a href="https://demo.bpmn.io/">在线设计站点</a>来加速理解。</p><p><img src="/images/2019/03/simple-bpmn-case2.png" alt="simple-bpmn-case2"></p><p>上图是通过BPMN设计器设计出来的简单流程，使用文本编辑器打开这个后缀为bpmn的文件，得到如下内容（<a href="/images/2019/03/diagram.bpmn">点击链接查看完整文件</a>）。可以发现BPMN2.0规范包含了三个部分在文件中都有体现：</p><ol><li>**Gateway(网关)**：exclusiveGateway-排他网关，在做判断时使用，除了排他网关还有几个其它类型的网关。</li><li>**Event(事件)**：startEvent-开始事件、endEvent-结束事件，规范要求一个完整流程图必须包含这两个部分。</li><li>**Activities(活动)**：task-任务、sequenceFlow-连接线，活动是流程的主体部分，内部包含的类型相对较多。</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>definitions</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>bpmn</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.omg.org/spec/BPMN/20100524/MODEL<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>bpmndi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.omg.org/spec/BPMN/20100524/DI<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>dc</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.omg.org/spec/DD/20100524/DC<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>di</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.omg.org/spec/DD/20100524/DI<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Definitions_0pbqtyh<span class="token punctuation">"</span></span> <span class="token attr-name">targetNamespace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://bpmn.io/schema/bpmn<span class="token punctuation">"</span></span> <span class="token attr-name">exporter</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bpmn-js (https://demo.bpmn.io)<span class="token punctuation">"</span></span> <span class="token attr-name">exporterVersion</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>3.2.1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>process</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Process_0dechmy<span class="token punctuation">"</span></span> <span class="token attr-name">isExecutable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>startEvent</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>StartEvent_1jlefdo<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>开始<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>outgoing</span><span class="token punctuation">></span></span>SequenceFlow_10f0wz2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">bpmn:</span>outgoing</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">bpmn:</span>startEvent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>sequenceFlow</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>SequenceFlow_10f0wz2<span class="token punctuation">"</span></span> <span class="token attr-name">sourceRef</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>StartEvent_1jlefdo<span class="token punctuation">"</span></span> <span class="token attr-name">targetRef</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Task_19nyecg<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>sequenceFlow</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>SequenceFlow_0jyecs7<span class="token punctuation">"</span></span> <span class="token attr-name">sourceRef</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Task_19nyecg<span class="token punctuation">"</span></span> <span class="token attr-name">targetRef</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Task_144tinh<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>exclusiveGateway</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ExclusiveGateway_0etavhv<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>incoming</span><span class="token punctuation">></span></span>SequenceFlow_14jzbq9<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">bpmn:</span>incoming</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>outgoing</span><span class="token punctuation">></span></span>SequenceFlow_1kxhbdq<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">bpmn:</span>outgoing</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>outgoing</span><span class="token punctuation">></span></span>SequenceFlow_18w6f66<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">bpmn:</span>outgoing</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">bpmn:</span>exclusiveGateway</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>sequenceFlow</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>SequenceFlow_14jzbq9<span class="token punctuation">"</span></span> <span class="token attr-name">sourceRef</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Task_144tinh<span class="token punctuation">"</span></span> <span class="token attr-name">targetRef</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ExclusiveGateway_0etavhv<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>sequenceFlow</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>SequenceFlow_1kxhbdq<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>通过<span class="token punctuation">"</span></span> <span class="token attr-name">sourceRef</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ExclusiveGateway_0etavhv<span class="token punctuation">"</span></span> <span class="token attr-name">targetRef</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Task_1m6ft2w<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>endEvent</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>EndEvent_1xqrowc<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>结束<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>incoming</span><span class="token punctuation">></span></span>SequenceFlow_1i6l681<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">bpmn:</span>incoming</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>incoming</span><span class="token punctuation">></span></span>SequenceFlow_18w6f66<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">bpmn:</span>incoming</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">bpmn:</span>endEvent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>sequenceFlow</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>SequenceFlow_1i6l681<span class="token punctuation">"</span></span> <span class="token attr-name">sourceRef</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Task_1m6ft2w<span class="token punctuation">"</span></span> <span class="token attr-name">targetRef</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>EndEvent_1xqrowc<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>sequenceFlow</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>SequenceFlow_18w6f66<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>拒绝<span class="token punctuation">"</span></span> <span class="token attr-name">sourceRef</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ExclusiveGateway_0etavhv<span class="token punctuation">"</span></span> <span class="token attr-name">targetRef</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>EndEvent_1xqrowc<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>userTask</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Task_19nyecg<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>申请请假<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>incoming</span><span class="token punctuation">></span></span>SequenceFlow_10f0wz2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">bpmn:</span>incoming</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>outgoing</span><span class="token punctuation">></span></span>SequenceFlow_0jyecs7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">bpmn:</span>outgoing</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">bpmn:</span>userTask</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>userTask</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Task_144tinh<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>领导审批<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>incoming</span><span class="token punctuation">></span></span>SequenceFlow_0jyecs7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">bpmn:</span>incoming</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>outgoing</span><span class="token punctuation">></span></span>SequenceFlow_14jzbq9<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">bpmn:</span>outgoing</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">bpmn:</span>userTask</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>userTask</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Task_1m6ft2w<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>休假<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>incoming</span><span class="token punctuation">></span></span>SequenceFlow_1kxhbdq<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">bpmn:</span>incoming</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmn:</span>outgoing</span><span class="token punctuation">></span></span>SequenceFlow_1i6l681<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">bpmn:</span>outgoing</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">bpmn:</span>userTask</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">bpmn:</span>process</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">bpmndi:</span>BPMNDiagram</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>BPMNDiagram_1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 篇幅问题，省略了图形坐标相关的内容 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">bpmndi:</span>BPMNDiagram</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">bpmn:</span>definitions</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-开源BPMN项目对比"><a href="#3-开源BPMN项目对比" class="headerlink" title="3. 开源BPMN项目对比"></a>3. 开源BPMN项目对比</h1><p>BPMN2.0规范目前已成为流程处理事实上的标准，实现该规范的常见开源项目有这三个：jBPM，Activiti，Camunda。</p><p>他们实现的功能比较相似，源头上它们存在递进关系：jBPM –&gt; Activiti –&gt; Camunda。jBPM是最早诞生的，Activiti的发起人是从jBPM项目中脱离出来的，Camunda BPM的发起人是从Activiti项目中脱离出来的。之所以存在三个同源项目，是由于开发者们对工作流引擎的期望存在分歧。</p><p>从技术组成来看，Activiti最大的优势是采用了PVM（流程虚拟机），支持除了BPMN2.0规范之外的流程格式，与外部服务有良好的集成能力，延续了jBPM3、jBPM4良好的社区支持，服务接口清晰，链式API更为优雅；劣势是持久化层没有遵循JPA规范。</p><p>jBPM最大的优势是采用了Apache Mina异步通信技术，采用JPA&#x2F;JTA持久化方面的标准，以功能齐全的Guvnor作为流程仓库，有RedHat的专业化支持；但其劣势也很明显，对自身技术依赖过紧且目前仅支持BPMN2。</p><p>至于Camunda BPM 7战略目标是“开发者友好”，jBPM则致力于“零代码”的思想，而Camunda BPM与Activiti的区别零碎且不明显。</p><p>项目名称 | 企业 | 开始时间 | 开源方式 | 部署方式<br>– | – | – | – | – | –<br>jBPM | Red Hat | 2006 | 社区版和企业版相同 | 支持嵌入式和独立部署<br>Activiti | Alfresco | 2010 | 社区版和企业版不同 | 支持嵌入式和独立部署<br>Camunda BPM| Camunda | 2012 | 社区版和企业版不同 | 支持嵌入式和独立部署</p><p>事实上三者的区别非常多，但随时时间的推移和版本迅速迭代，很多功能存在重叠，现在很难说哪个项目更强一些。当然，Camunda BPM出现时间最晚，社区也比较有活力，有文章(<a href="http://www.bpm-guide.de/2016/10/19/5-reasons-to-switch-from-activiti-to-camunda/">5 Reasons to switch from Activiti to Camunda</a>)声称其比Activiti更具优势。</p><p>Activiti的发展历史：</p><p>2010年3月，jBPM的两位主要开发人员Tom Baeyens和Joram Barrez 离开了Red Hat，并成为了Alfresco员工的Activiti 。Activiti基于他们使用jBPM的工作流程经验，但它是一个新的代码库，不基于任何以前的jBPM 代码。</p><p>Activiti的第一个版本是5.0，表明该产品是他们通过jBPM 1到4获得的经验的延续。</p><p>2016年10月，Barrez，Rademakers（Activiti in Action的作者）和其他贡献者离开了Alfresco。离职的开发人员分叉了Activiti代码，开始了一个名为<a href="https://en.wikipedia.org/wiki/Flowable">Flowable</a>的新项目。</p><p>2017年2月，Activiti的新商业版本发布并更名为Alfresco Process Services。</p><p>2017年5月，Activiti发布了6.0.0版本，对ad-hoc子流程和新的应用程序用户界面提供了新的支持。</p><p>2017年7月，Activiti发布了7.x版本, 向微服务架构迈进，进行大规模设计升级；可以与Spring Cloud生态轻松集成。</p><h1 id="4-Activiti核心API"><a href="#4-Activiti核心API" class="headerlink" title="4. Activiti核心API"></a>4. Activiti核心API</h1><p>Activiti中包含了几个核心的Service接口，它们是开发者调用Activiti API的入口。</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><code>ProcessEngine</code></td><td>流程引擎，可以获得其他所有的Service。</td></tr><tr><td><code>RepositoryService</code></td><td>Repository中存储了流程定义文件、部署和支持数据等信息；RepositoryService提供了对repository的存取服务。</td></tr><tr><td><code>RuntimeService</code></td><td>提供启动流程、查询流程实例、设置获取流程实例变量等功能。</td></tr><tr><td><code>TaskService</code></td><td>提供运行时任务查询、领取、完成、删除以及变量设置等功能。</td></tr><tr><td><code>HistoryService</code></td><td>用于获取正在运行或已经完成的流程实例的信息。</td></tr><tr><td><code>FormService</code></td><td>提供定制任务表单和存储表单数据的功能，注意存储表单数据可选的功能，也可以向自建数据表中提交数据。</td></tr><tr><td><code>IdentityService</code></td><td>提供对内建账户体系的管理功能，注意它是可选的服务，可以是用外部账户体系。</td></tr><tr><td><code>ManagementService</code></td><td>较少使用，与流程管理无关，主要用于Activiti系统的日常维护。</td></tr></tbody></table><p>完成一次流程的处理，常见步骤以及他们使用的Service如下图所示：</p><p><img src="/images/2019/03/activiti-flow.png" alt="activiti-flow"></p><p>现在再来介绍一些常见概念，在这些概念共同配合协作下，工作流引擎得以发挥出巨大威力：</p><h3 id="4-1-流程-流程实例"><a href="#4-1-流程-流程实例" class="headerlink" title="4.1 流程 &amp; 流程实例"></a>4.1 流程 &amp; 流程实例</h3><p>流程由遵守BPMN2.0规范的xml文件指定，定义流程即完成流程文件的设计。</p><p>流程发布后，使用RuntimeService可以开启一个流程实例，每个流程可以开启N次流程实例，且实例之间的数据相互隔离。</p><h3 id="4-2-用户任务"><a href="#4-2-用户任务" class="headerlink" title="4.2 用户任务"></a>4.2 用户任务</h3><p>用户任务是BPMN2.0规范中Activities(活动)组件下的重要组成部分，在Activiti中对应Task类；区别于其他类型的任务，用户任务需要进行领取操作，不会自动执行，且领取从待处理任务列表中移除，其他候选人不可见。</p><h3 id="4-3-用户-角色"><a href="#4-3-用户-角色" class="headerlink" title="4.3 用户 &amp; 角色"></a>4.3 用户 &amp; 角色</h3><p>Activiti中内建了一个简单的账户体系，用户和角色是多对多的关系；IdentityService中提供了对用户、角色操作的API。</p><p>另外，用户、角色与任务的联系，仅仅通过userId或groupId，不要求必须使用内建账户体系；由于内建的过于简单，开发者完全可以使用自有的账户体系。</p><h3 id="4-4-受让人、候选人、候选组"><a href="#4-4-受让人、候选人、候选组" class="headerlink" title="4.4 受让人、候选人、候选组"></a>4.4 受让人、候选人、候选组</h3><p>对用户任务做领取操作(claim)，即指定了该任务的受让人，每个任务只能有一个受让人，不能多次领取（但可以再次转让）。</p><p>任务的候选人和候选组支持配置多个，目的是指定处理该任务的人，不在候选列表中的人不允许处理该任务。另外，候选人、候选组可以流程文件中指定，也可以在监听事件中动态指定。</p><h3 id="4-5-变量"><a href="#4-5-变量" class="headerlink" title="4.5 变量"></a>4.5 变量</h3><p>Activiti支持以key&#x2F;value的形式，对变量做持久化处理。变量通常有两个重要作用：</p><p>1、存储一些跟流程相关的业务数据，例如处理任务时提交的表单数据<br>2、流程定义文件中，可以通过UEL表达式获取存储的变量，例如，在互斥网关中选择正确的传出顺序流。</p><blockquote><p><strong>UEL表达式</strong><br/><br>UEL是java EE6规范的一部分，UEL（Unified Expression Language）即统一表达式语言，Activiti支持两个UEL表达式：UEL-value和UEL-method。</p></blockquote><p>从类别上讲，变量可以分为三类：</p><table><thead><tr><th>名称</th><th>是否持久化</th><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>流程变量</td><td>是</td><td>setVariable</td><td>跟随流程实例，当前流程实例共享流程变量。</td></tr><tr><td>本地变量</td><td>是</td><td>setVariableLocal</td><td>跟随活动节点，不同节点之间不共享变量。</td></tr><tr><td>流程瞬时变量</td><td>否</td><td>setTransientVariable</td><td>跟随流程实例，只能在下一个“等待状态”之前访问它，“等待状态”表示当前流程实例中数据持久化的点。</td></tr><tr><td>流程本地变量</td><td>否</td><td>setTransientVariableLocal</td><td>跟随活动节点，只能在下一个“等待状态”之前访问它，“等待状态”表示当前流程实例中数据持久化的点。</td></tr></tbody></table><blockquote><p><strong>注意</strong><br/><br>TaskService的setVariableLocal方法签名如下<br><code>void setVariable(String executionId, String variableName, Object value)</code><br>该方法传入了任务的executionId作为参数，但它存储的仍然是<strong>流程变量</strong>；流程变量还是本地变量是通过方法名称确定的，与使用RuntimeService还是TaskService没有关系。</p></blockquote><h3 id="4-6-表单"><a href="#4-6-表单" class="headerlink" title="4.6 表单"></a>4.6 表单</h3><p>用户处理任务时，通常需要填写备注说明等表单数据，Activiti的FormService对此提供了支持，表单实现如下三种可选的方式：</p><table><thead><tr><th>名称</th><th>开启方式</th><th>数据存储位置</th></tr></thead><tbody><tr><td>动态表单</td><td>流程定义文件中的activiti:formProperty属性</td><td>与变量一样，以key&#x2F;value的形式存储在变量表</td></tr><tr><td>外置表单</td><td>流程定义文件中的activiti:formkey属性</td><td>与变量一样，以key&#x2F;value的形式存储在变量表</td></tr><tr><td>普通表单</td><td>脱离Activiti掌控，开发人员自行创建表单和数据表，并使表单和任务关联即可</td><td>任意位置</td></tr></tbody></table><p>三种方式中，<strong>动态表单</strong>由于无法指定样式，使用场景不多；<strong>外置表单</strong>的赋值和提交都依托Activiti引擎。</p><p>在此，笔者建议使用第三种方式<strong>普通表单</strong>，它的页面渲染赋值都由个人掌控，Activiti仅负责流程流转相关工作，页面渲染部分保持独立会使结构更清晰。</p><h3 id="4-7-监听器"><a href="#4-7-监听器" class="headerlink" title="4.7 监听器"></a>4.7 监听器</h3><p>任务执行时，开发者常常需要触发一些自定义的动作，如动态分配候选人、任务结束时发送通知等；Activiti为开发者提供了两种方式来满足此类需求。</p><h4 id="4-7-1-执行监听器（Execution-listener）"><a href="#4-7-1-执行监听器（Execution-listener）" class="headerlink" title="4.7.1 执行监听器（Execution listener）"></a>4.7.1 执行监听器（Execution listener）</h4><p>执行侦听器意味着侦听一组有限的流程执行操作，如start、end和take，开发者可以在启动或结束之前添加一些特定的业务逻辑。执行监听器需要实现<code>ExecutionListener</code>或<code>TaskListener</code>。</p><p>在流程文件中使用activiti:executionListener标签，指定具体的监听类，如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 1. 执行监听器的三种指定方式 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">activiti:</span>executionListener</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.activiti.examples.bpmn.executionlistener.ExampleExecutionListenerOne<span class="token punctuation">"</span></span> <span class="token attr-name">event</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>start<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">activiti:</span>executionListener</span> <span class="token attr-name">expression</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;myPojo.myMethod(execution.event)&#125;<span class="token punctuation">"</span></span> <span class="token attr-name">event</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>start<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">activiti:</span>executionListener</span> <span class="token attr-name">delegateExpression</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;testExecutionListener&#125;<span class="token punctuation">"</span></span> <span class="token attr-name">event</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>start<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 2. 任务监听器的三种指定方式 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">activiti:</span>taskListener</span> <span class="token attr-name">event</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>create<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.activiti.MyTaskCreateListener<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">activiti:</span>taskListener</span> <span class="token attr-name">event</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>create<span class="token punctuation">"</span></span> <span class="token attr-name">expression</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;myObject.callMethod(task, task.eventName)&#125;<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">activiti:</span>taskListener</span> <span class="token attr-name">event</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>create<span class="token punctuation">"</span></span> <span class="token attr-name">delegateExpression</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;myTaskListenerBean&#125;<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-7-2-事件监听器（Event-Listener）"><a href="#4-7-2-事件监听器（Event-Listener）" class="headerlink" title="4.7.2 事件监听器（Event Listener）"></a>4.7.2 事件监听器（Event Listener）</h4><p>事件监听器可以监听Activiti引擎抛出的一组大型事件，这些事件级别较低，类型非常丰富，触发次数也较多。</p><p>创建ProcessEngine时，可以通过eventListeners属性指定事件监听器（也可以运行时通过RuntimeService.addEventListener的方式添加），事件监听器需要实现ActivitiEventListener接口；每当流程实例产生变化时，监听器都能得到通知消息，点击<a href="https://www.activiti.org/userguide/#eventDispatcherEventTypes">事件类型列表</a>查看所有通知类型。</p><p>使用这种方式引入的监听器，可以与流程定义文件解耦，是流程文件不再依赖Java代码。另外，事件监听器也支持在流程定义文件中声明，格式如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">activiti:</span>eventListener</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.activiti.engine.test.MyEventListener<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">activiti:</span>eventListener</span> <span class="token attr-name">delegateExpression</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;testEventListener&#125;<span class="token punctuation">"</span></span> <span class="token attr-name">events</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>JOB_EXECUTION_SUCCESS,JOB_EXECUTION_FAILURE<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><strong>执行监听器 vs 事件监听器</strong><br/><br>二者都可以对活动节点进行监听，执行监听器粒度较大，事件监听器粒度较小。出于便于维护的目的，笔者建议使用事件监听器，将事件监听和流程文件分开管理。</p></blockquote><h1 id="5-常见API调用步骤"><a href="#5-常见API调用步骤" class="headerlink" title="5. 常见API调用步骤"></a>5. 常见API调用步骤</h1><blockquote><p><strong>注意</strong><br> 本节示例代码，全部是基于Activiti 6.0.0版本的。</p></blockquote><h2 id="5-1-画流程图"><a href="#5-1-画流程图" class="headerlink" title="5.1 画流程图"></a>5.1 画流程图</h2><p>流程图本质是一个符合BPMN2.0规范的xml文件，由拖拽式的设计软件完成，这里推荐几个：</p><p><a href="https://www.eclipse.org/bpmn2-modeler/">BPMN2 Modeler</a>:Eclipse插件。<br><a href="https://demo.bpmn.io/">BPMN diagram</a>:一个在线编辑器。<br><a href="https://sourceforge.net/projects/bpmn/">Yaoqiang BPMN Editor</a>:Java编写的客户端。</p><h2 id="5-2-部署流程"><a href="#5-2-部署流程" class="headerlink" title="5.2 部署流程"></a>5.2 部署流程</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Deployment</span> deployment <span class="token operator">=</span> repositoryService<span class="token punctuation">.</span><span class="token function">createDeployment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addZipInputStream</span><span class="token punctuation">(</span>zip<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">deploy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果Activiti和Spring集成后，<code>activiti-spring</code>提供了启动服务时自动部署流程的功能，它将在启动时检查流程文件是否有更新，以此决定是否再次部署。</p><h2 id="5-3-开启流程"><a href="#5-3-开启流程" class="headerlink" title="5.3 开启流程"></a>5.3 开启流程</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ProcessInstance</span> processInstance <span class="token operator">=</span> runtimeService<span class="token punctuation">.</span><span class="token function">startProcessInstanceByKey</span><span class="token punctuation">(</span>processDefinitionKey<span class="token punctuation">,</span> businessKey<span class="token punctuation">,</span> variables<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>processDefinitionKey</code>：流程定义文件中定义的文件唯一标识。<br><code>businessKey</code>：参数为外部业务实体的唯一标识，比如采购订单的订单编号。<br><code>variables</code>：以Map的形式传入一组流程实例。</p><h2 id="5-3-查询待办任务"><a href="#5-3-查询待办任务" class="headerlink" title="5.3 查询待办任务"></a>5.3 查询待办任务</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Task</span><span class="token punctuation">></span></span> list1 <span class="token operator">=</span> taskService<span class="token punctuation">.</span><span class="token function">createTaskQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">taskCandidateOrAssigned</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Task</span><span class="token punctuation">></span></span> list2 <span class="token operator">=</span> taskService<span class="token punctuation">.</span><span class="token function">createTaskQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">taskCandidateGroup</span><span class="token punctuation">(</span>groupId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Task</span><span class="token punctuation">></span></span> list3 <span class="token operator">=</span> taskService<span class="token punctuation">.</span><span class="token function">createTaskQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">or</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">taskCandidateOrAssigned</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">taskCandidateGroup</span><span class="token punctuation">(</span>groupId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">endOr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>taskCandidateOrAssigned</code>: 查询候选人或受让人是指定userId的任务<br><code>taskCandidateGroup</code>：查询候选组是指定groupId的任务<br><code>or和endOr</code>：查询候选人或受让人是指定userId、或选组是指定groupId的任务；在or和endOr之间的条件，将被“或”分割。</p><p>注意使用taskService查询得到的Task，都是未完成的，任务一旦完成就不能再通过taskService查询了，应改用<code>HistoryService</code>。</p><h2 id="5-3-认领并处理任务"><a href="#5-3-认领并处理任务" class="headerlink" title="5.3 认领并处理任务"></a>5.3 认领并处理任务</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">taskService<span class="token punctuation">.</span><span class="token function">claim</span><span class="token punctuation">(</span>taskId<span class="token punctuation">,</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指定用户认领指定任务，即指定了该任务的受让人(Assignee）。</p><p>认领后该任务再使用taskService的<code>taskCandidateUser</code>查询就查询不到了，只能根据<code>taskAssignee</code>进行查询；这就是所谓对受让人之外的其他人不可见。</p><h2 id="5-3-查询历史数据"><a href="#5-3-查询历史数据" class="headerlink" title="5.3 查询历史数据"></a>5.3 查询历史数据</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HistoricActivityInstance</span><span class="token punctuation">></span></span> list1 <span class="token operator">=</span> historyService<span class="token punctuation">.</span><span class="token function">createHistoricActivityInstanceQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">processInstanceId</span><span class="token punctuation">(</span>processInstanceId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orderByHistoricActivityInstanceId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HistoricTaskInstance</span><span class="token punctuation">></span></span> list2  <span class="token operator">=</span> historyService<span class="token punctuation">.</span><span class="token function">createHistoricTaskInstanceQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">processInstanceId</span><span class="token punctuation">(</span>processInstanceId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orderByHistoricActivityInstanceId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>createHistoricActivityInstanceQuery</code>: 查询流程下所有的活动，可以在这个查询中获得一个流程实例的完整轨迹。有别于BPMN2.0规范中的Activities，它既包含了任务(Task)、也包含了网关(Gateway)。<br><code>createHistoricTaskInstanceQuery</code>: 查询流程下所有的任务，可以在这个查询中获得一个流程实例中所有的任务。</p><h1 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h1><p>笔者在刚刚学习Activiti时，在一些基础原理上困惑了一段时间，事实上只要理解了工作流引擎的大致工作流程，再回过头来熟悉Activiti提供的API，无疑会容易理解许多，这也是笔者写这篇入门贴的初衷。</p><p>另外，本文示例代码片段大多摘自官方示例，对于想要直接看Example的读者，可以查看前辈<strong>咖啡兔</strong>的<a href="https://github.com/henryyan/kft-activiti-demo">kft-activiti-demo</a>或<a href="https://github.com/Activiti/activiti-examples">官方示例</a>。</p><h1 id="参考的文章"><a href="#参考的文章" class="headerlink" title="参考的文章"></a>参考的文章</h1><p><a href="https://www.activiti.org/userguide/">Activiti User Guide</a><br><a href="https://docs.awspaas.com/reference-guide/aws-paas-process-reference-guide/index.html">AWS BPMN2 Process参考指南</a><br><a href="http://blog.goodelearning.com/subject-areas/bpmn/bpmn-faq-relationship-bpmn-uml/">BPMN FAQ – What Is the Relationship Between BPMN and UML?</a><br><a href="https://stackoverflow.com/questions/25471548/bpmn-business-process-modeling-and-notation-vs-uml">BPMN (Business process modeling and notation) vs UML</a><br><a href="https://medium.com/capital-one-tech/comparing-and-contrasting-open-source-bpm-projects-196833f23391">Comparing and Contrasting Open Source BPM Projects</a><br><a href="https://camunda.com/learn/whitepapers/camunda-bpm-vs-jboss/">Camunda BPM 7 compared to JBoss jBPM 6</a><br><a href="https://salaboy.com/2017/07/05/activiti-7-kick-off-roadmap/">Activiti 7 Kick Off Roadmap</a><br><a href="https://blog.csdn.net/hj7jay/article/details/50855510">Activiti中三种不同的表单及其应用</a><br><a href="https://community.alfresco.com/thread/225988-event-handlers-vs-executionlistener">Event Handlers Vs ExecutionListener</a><br><a href="https://www.zhihu.com/question/52166998">activiti和jbpm工作流引擎哪个比较好?</a></p>]]></content>
      
      
      <categories>
          
          <category> workflow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> activiti </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Actuator 介绍</title>
      <link href="/2019/01/17/spring-boot/spring-boot-actuator-1/"/>
      <url>/2019/01/17/spring-boot/spring-boot-actuator-1/</url>
      
        <content type="html"><![CDATA[<p>这篇文章中，我们将对Spring Boot Actuator进行全面介绍，使读者清楚什么是Spring Boot Actuator，以及如何合理地使用它。</p><p>另外，我们将介绍一些可以和Spring Boot Actuator集成的<a href="https://en.wikipedia.org/wiki/Application_performance_management">APM(Application performance management)</a>。</p><span id="more"></span><h2 id="1-什么是Spring-Boot-Actuator"><a href="#1-什么是Spring-Boot-Actuator" class="headerlink" title="1. 什么是Spring Boot Actuator"></a>1. 什么是Spring Boot Actuator</h2><p><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-actuator">Spring Boot Actuator</a>可以帮助开发者在生产环境中监视和管理应用程序，一旦在pom中添加<code>spring-boot-starter-actuator</code>依赖，Spring Boot将自动集成审计、健康和指标收集等功能到应用程序中。</p><p>换句话说，<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-actuator">Spring Boot Actuator</a>是我们常说的非功能性的监控管理工具；同时，依托于自动配置的机制，使其能够开箱即用。</p><blockquote><p>Actuator的定义<br/><br>中文翻译为致动器，是个制造术语，指用于移动或控制某物的机械装置，它可以从小变化中产生大量的运动。笔者理解应该是指Actuator功能虽然较小，但意义重大。</p></blockquote><h2 id="2-使用方式"><a href="#2-使用方式" class="headerlink" title="2. 使用方式"></a>2. 使用方式</h2><p>只需要在Spring Boot项目中添加如下Starter，即可完成集成并开启Actuator。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-actuator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此时启动服务器，然后请求&#x2F;actuator&#x2F;health，若返回{“status”:”UP”}代表Actuator已生效。</p><p>上述路径中的<code>/actuator</code>为Actuator的默认根目录，health是一个监控点(endpoint)；除了使用HTTP协议访问这些监控点，还可以使用JMX来访问。</p><blockquote><p>Actuator’s endpoints<br/><br>Spring文档中称上述监控点为“endpoints”，即“端点”，笔者觉得翻译过来应该叫监控点、控制点、或检测点比较好。</p></blockquote><p>Actuator默认集成了23个监控点：</p><p>序号 | 名称 | 描述 | 默认开启<br>– | – | – | – | – | – | – | –<br>1  |  auditevents | 公开审计事件信息 | Yes<br>2  |  beans | 列出所有Spring管理的的Beans | Yes<br>3  |  caches | 公开可用缓存 | Yes<br>4  |  conditions | 展示所有自动配置的条件，并显示匹配或不匹配的原因 | Yes<br>5  |  configprops | 展示<code>@ConfigurationProperties</code>列表 | Yes<br>6  |  env | 公开<code>ConfigurableEnvironment</code>下的属性 | Yes<br>7  |  flyway | 展示由Flyway管理的数据库脚本 | Yes<br>8  |  health | 展示程序的健康信息 | Yes<br>9  |  httptrace | 展示HTTP轨迹信息，默认显示最后100次 | Yes<br>10  |  info | 展示应用程序信息 | Yes<br>11  |  integrationgraph | 显示Spring集成视图 | Yes<br>12  |  loggers | 显示和修改日志配置文件 | Yes<br>13 | liquibase | 显示由Liquibase管理的数据库脚本 | Yes<br>14 | metrics | 显示指标信息 | Yes<br>15 | mappings |显示所有被<code>@RequestMapping</code>拦截的路径 | Yes<br>16 | scheduledtasks | 显示定时任务 | Yes<br>17 | sessions | 可以检索或删除会话（Spring管理的会话） | Yes<br>18 | shutdown | 发送优雅关闭指令 | <font color='red'>No</font><br>19 | threaddump | 下载线程dump文件 | Yes<br>20 | heapdump | 下载堆dump文件(只在Web应用下有效) | Yes<br>21 | jolokia | 通过HTTP公开JMX Beans(只在Web应用下有效)  | Yes<br>22 | logfile | 返回日志文件内容(只在Web应用下有效) | Yes<br>23 | prometheus | 以Prometheus服务格式公开指标(只在Web应用下有效) | Yes</p><p>Actuator对监控点有两层控制，第一层是<strong>启用&#x2F;禁用</strong>，第二层是<strong>公开&#x2F;不公开</strong>（JMX和HTTP需要分开指定），只有<strong>启用并公开</strong>的监控点才可以使用。</p><p>启用&#x2F;禁用的默认值(2.x版本)：shutdown被禁用，其它的监控点都启用。</p><p>公开&#x2F;不公开的默认值(2.x版本)：HTTP公开info和health，其它不公开；JMX公开所有监控点。</p><p>启动&#x2F;禁用配置格式为<code>management.endpoint.&#123;ID&#125;.enabled</code>和<code>management.endpoints.enabled-by-default</code>，示例如下：</p><pre class="line-numbers language-none"><code class="language-none"># 启用shutdownmanagement.endpoint.shutdown.enabled&#x3D;true# 全部禁用management.endpoints.enabled-by-default&#x3D;false# 启用infomanagement.endpoint.info.enabled&#x3D;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>公开&#x2F;不公开配置格式有四个，分别控制JMX和HTTP</p><ul><li>management.endpoints.jmx.exposure.exclude</li><li>management.endpoints.jmx.exposure.include</li><li>management.endpoints.web.exposure.exclude</li><li>management.endpoints.web.exposure.include</li></ul><pre class="line-numbers language-none"><code class="language-none"># 在JMX中，公开health和info，此时其它的监控点都不公开management.endpoints.jmx.exposure.include&#x3D;health,info<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 在JMX中，公开除了env和beans之外的所有监控点management.endpoints.web.exposure.include&#x3D;*management.endpoints.web.exposure.exclude&#x3D;env,beans<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上文虽然列出了所有内置的监控点，但看起来仍然有些空洞，这里尝试从实用功能这个维度来描述一下Spring Boot Actuator。</p><ul><li>支持自定义endpoint、定制端口、根路径、HTTPS。</li><li>支持CORS，即跨站资源共享。</li><li>在health中，支持检查磁盘空间、数据库连接、Mongo DB、Rabbit Server等，也支持检查自定义组件。</li><li>在info中，支持展示系统配置、git提交信息、构建信息，也支持公示自定义信息。</li><li>在metrics中，支持监控JVM、CPU、文件描述符、Kafka消费者等指标；同时支持向多个平台推送指标数据，如AppOptics、Influx等；也支持定义指标。</li><li>在auditevents中，若同时使用了Spring Security，则可以监听用户身份认证失败的事件，系统可以以此为准进行访问限制；也支持自定义的事件。</li></ul><h2 id="2-规避安全问题"><a href="#2-规避安全问题" class="headerlink" title="2. 规避安全问题"></a>2. 规避安全问题</h2><p>毫无疑问，Actuator开放的这些监控点存在很多敏感信息，它们的访问权限需要被严格控制，不能被外部访问到。通常的做法有两个：</p><ul><li>使用Spring Security的<code>WebSecurityConfigurerAdapter</code>定制不同角色的访问权限</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ActuatorSecurity</span> <span class="token keyword">extends</span> <span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">HttpSecurity</span> http<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>http<span class="token punctuation">.</span><span class="token function">requestMatcher</span><span class="token punctuation">(</span><span class="token class-name">EndpointRequest</span><span class="token punctuation">.</span><span class="token function">toAnyEndpoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">authorizeRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">anyRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hasRole</span><span class="token punctuation">(</span><span class="token string">"ENDPOINT_ADMIN"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">httpBasic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用<code>management.server.port</code>更改Actuator的访问端口，并限制该端口的外网访问权限</li></ul><pre class="line-numbers language-none"><code class="language-none">management.server.port&#x3D;8081<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-与APMs集成"><a href="#3-与APMs集成" class="headerlink" title="3. 与APMs集成"></a>3. 与APMs集成</h2><p>Spring Boot Actuator只提供了监控和数据收集的功能，这些数据的呈现需要单独的系统来支撑，这些系统通常也称为<a href="https://en.wikipedia.org/wiki/Application_performance_management">APM(Application performance management)</a>。</p><p>如果不打算自研，而是直接集成使用已有的APM相关组件，可以考虑使用下面这些（笔者对此并不熟悉，所以仅列出了一个简单的清单）。</p><p><strong>Spring Boot Admin</strong></p><p><a href="https://github.com/codecentric/spring-boot-admin">Spring Boot Admin</a>是为了监控Spring Boot项目，基于Spring Boot Actuator实现的WEB UI，它和Spring Boot Actuator结合的比较好，基本发挥出所有预定义监控点的作用。需要注意的是，它不能存储数据，只能看到监控服务的实时数据。</p><p><strong>Prometheus</strong></p><p><a href="https://prometheus.io/">Prometheus</a>是一套开源的系统监控报警框架。由工作在 SoundCloud的google前员工在2012年创建，并于2015年正式发布。2016年，Prometheus正式加入 Cloud Native Computing Foundation，成为受欢迎度仅次于 Kubernetes 的项目。可以使用一个<a href="https://github.com/prometheus/client_java/pull/114">适配器</a>，与Spring Boot Actuator集成。</p><p><strong>StatsD</strong></p><p><a href="https://github.com/etsy/statsd">StatsD</a>就是一个简单的网络守护进程，基于 Node.js 平台，通过 UDP 或者 TCP 方式侦听各种统计信息，包括计数器和定时器，并发送聚合信息到后端服务，如 Graphite。Spring Boot有一个关于<a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready-metric-writers-export-to-statsd">将数据导出到StatsD的文档</a>。但是，除了在Spring Boot application module中安装StatsD实例之外，还必须实现一些存根才能使其工作。</p><p><strong>Graphite</strong></p><p><a href="http://graphiteapp.org/">Graphite</a>是一个开源实时的、显示时间序列度量数据的图形系统。Graphite并不收集度量数据本身，而是像一个数据库，通过其后端接收度量数据，然后以实时方式查询、转换、组合这些度量数据，它可以展示StatsD收集到的数据。</p><p><strong>OpenTSDB</strong></p><p><a href="http://opentsdb.net/">OpenTSDB</a>是基于Hbase的分布式的，可伸缩的时间序列数据库。主要用途，就是做监控系统；譬如收集大规模集群（包括网络设备、操作系统、应用程序）的监控数据并进行存储，查询。Spring Boot有一个关于<a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready-metric-writers-export-to-open-tsdb">将数据导出到OpenTSDB的文档</a>。</p><p><strong>JMXTrans</strong></p><p><a href="https://github.com/jmxtrans/jmxtrans">JMXTrans</a>是一个通过JMX采集java应用的数据采集器,他的输出可以是Graphite、StatsD、Ganglia、InfluxDb等。</p><p><strong>Ganglia</strong></p><p><a href="http://ganglia.info/">Ganglia</a>是UC Berkeley发起的一个开源集群监视项目，设计用于测量数以千计的节点。Ganglia的核心包含gmond、gmetad以及一个Web前端。主要是用来监控系统性能，如：cpu 、mem、硬盘利用率，I&#x2F;O负载、网络流量情况等，通过曲线很容易见到每个节点的工作状态，对合理调整、分配系统资源，提高系统整体性能起到重要作用。</p><p><strong>Jolokia</strong></p><p><a href="https://jolokia.org/">Jolokia</a>是一个用来访问远程JMXMBeans的崭新方法,与JSR-160连接器不同的是,它使用基于HTTP的JSON格式作为通讯协议,提供JMX批量操作等。Spring Boot支持<a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready-jolokia">使用Jolokia通过HTTP导出JMX数据</a>，可以开箱即用，无需额外开发。</p><p><strong>Telegraf</strong></p><p><a href="https://www.influxdata.com/time-series-platform/telegraf/">Telegraf</a>是一款Go语言编写的metrics收集、处理、聚合的代理，其设计目标是较小的内存使用，通过插件来构建各种服务和第三方组件的metrics收集。Telegraf通过Jolokia集成支持JMX数据检索。它有一个预先制作的输入<a href="https://github.com/influxdata/telegraf/tree/master/plugins/inputs/jolokia">插件</a>，可以开箱即用。</p><p><strong>InfluxDB</strong></p><p><a href="https://www.influxdata.com/time-series-platform/influxdb/">InfluxDB</a>是一个开源的时序数据库，使用GO语言开发，特别适合用于处理和分析资源监控数据这种时序相关数据。InfluxDB可以通过<a href="https://github.com/influxdata/telegraf/tree/master/plugins/outputs/influxdb">插件</a>接收Telegraf返回的指标。它也是开箱即用的，无需二次开发。</p><p><strong>Grafana</strong></p><p><a href="http://grafana.org/">Grafana</a>是一个可视化面板（Dashboard），有着非常漂亮的图表和布局展示，功能齐全的度量仪表盘和图形编辑器，支持Graphite、zabbix、InfluxDB、Prometheus和OpenTSDB作为数据源。</p><blockquote><p>无二次开发的一个方案<br/><br>Jolokia、Telegraf、InfluxDB、Grafana这四个组件结合使用，可以在不进行二次开发的前提下，实现对Spring Boot Actuator数据的友好展示。</p></blockquote><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>本文主要介绍了<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-actuator">Spring Boot Actuator</a>的基本功能，该组件在指标、审计、健康检查等方面做的非常完善，监控点大多都支持灵活扩展；使用时一定要注意安全问题，需要通过各种手段规避安全风险。</p><p>另外，<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-actuator">Spring Boot Actuator</a>只负责采集数据，采集之后数据的传输和呈现需要依靠其它组件，这方面的开源组件也比较多，如果没有太多的研发预算可以直接使用开源APM。如果是有这方面需求且有研发能力的团队，可以集成开源组件后做一些定制开发，使其满足特定业务需要。</p><p>本文并未关注<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-actuator">Spring Boot Actuator</a>对应用性能上的影响，这对一个监控体系也是非常重要的，下一篇文章将会就此进行说明。</p><h2 id="参考的文章"><a href="#参考的文章" class="headerlink" title="参考的文章"></a>参考的文章</h2><p><a href="https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/#production-ready">Spring Boot Actuator: Production-ready features</a><br><a href="https://www.baeldung.com/spring-boot-actuators">Spring Boot Actuator</a><br><a href="https://aboullaite.me/spring-boot-metrics-monitoring-using-tick-stack/">Spring boot metrics monitoring using TICK stack</a><br><a href="https://medium.com/@brunosimioni/near-real-time-monitoring-charts-with-spring-boot-actuator-jolokia-and-grafana-1ce267c50bcc">Near real-time monitoring charts with Spring Boot Actuator, Jolokia and Grafana</a><br><a href="https://www.ibm.com/developerworks/cn/cloud/library/cl-lo-prometheus-getting-started-and-practice/">Prometheus 入门与实践</a></p>]]></content>
      
      
      <categories>
          
          <category> spring-boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> spring-boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[转载]简话开源协议</title>
      <link href="/2019/01/08/tool/talk-about-license/"/>
      <url>/2019/01/08/tool/talk-about-license/</url>
      
        <content type="html"><![CDATA[<p>一直对 Github 的开源协议没有明确认识，直到有一天，也想搞个开源项目。随之而来的问题是：如何选择，如何在这个到处撕比的时代用武器维护劳动成果？</p><span id="more"></span><h2 id="一、了解协议"><a href="#一、了解协议" class="headerlink" title="一、了解协议"></a>一、了解协议</h2><p>作为第一步，我们首先需要知道什么是协议。协议的英文：License 是软件的授权许可，软件版权属于知识产权的著作权范畴，具有知识产权的特征，即时间性，专有性和地域性。</p><p>什么鬼东西，通俗的告诉我就行！</p><p>License 表述了你获得代码后拥有的权利，可以对别人的作品进行哪些操作，哪些操作又是被禁止的。软件协议一般分为开源协议和商业协议，这节，我们的重点是开源协议。</p><h2 id="二、协议的重要性"><a href="#二、协议的重要性" class="headerlink" title="二、协议的重要性"></a>二、协议的重要性</h2><p>按照小学语文的逻辑，我们要先了解一下重要性，从而提升大家的阅读兴趣。既然已经知道了协议的存在，那么协议为何如此重要呢？举几个通俗易懂的例子：</p><p>1.你使用别人代码的时候，发现里面写了 MIT，贸然地使用会不会侵权？你不知道！<br>2.对开源代码修改了，有哪些限制？你不知道！<br>3.偷着抄袭了别人的博客，却被 CC 协议吓了一跳。<br>4.博客底下的 Copyrights © 2018 Jartto. All Rights Reserved. 是什么意思？<br>5.我的开源项目，别人修改之后，拿去贩卖，我该如何保留自己的权利？你不知道！<br>6.如果作者在代码中下毒，你用的好好的，突然收到了法院的传票，你不知道！</p><p>是不是有点慌了，啥也没干，咋就侵权了呢？啥也没干，还被别人给利用了！</p><h2 id="三、协议分类"><a href="#三、协议分类" class="headerlink" title="三、协议分类"></a>三、协议分类</h2><p>协议太宽松会导致作者丧失对作品的很多权利，太严格又不便于使用者使用及作品的传播。所以除了协议多之外，你还要考虑你对作品想保留哪些权利，放开哪些限制。</p><p>开源协议有成千上万种，如何来选择重点呢？</p><p><img src="/images/2019/01/1646d6f5b2aea44b" alt="License1"></p><p>这就是所谓的捷径，我们可以先从 Github 上最火的开源协议入手。</p><p>话不多说，我们开始吧，先来看看下面这三种常用协议吧：</p><p><img src="/images/2019/01/1646d6f5b29d7b44" alt="License3"></p><p>1.MIT(简单宽松的协议)</p><p>如果你只想要一个简单点的协议不想太麻烦的话。</p><p>MIT 协议相对宽松但还是抓住了要点的。此协议允许别人以任何方式使用你的代码同时署名原作者，但原作者不承担代码使用后的风险，当然也没有技术支持的义务。jQuery 和 Rails 就是 MIT 协议。</p><p>2.Apache(考虑有专利的情况)</p><p>如果你的作品中涉及到专利相关。</p><p>Apache 协议也是个相对宽松与 MIT 类似的协议，但它简单指明了作品归属者对用户专利上的一些授权。Apache服务器，SVN 还有 NuGet 等是使用的 Apache 协议。</p><p>3.GNU GPLv2 (代码分享与促进)</p><p>如果你在乎作品的传播和别人的修改，希望别人也以相同的协议分享出来。</p><p>GNU GPL（V2或V3）是一种版本自由的协议（可以参照copyright 来理解，后者是版本保留，那 copyleft 便是版权自由，或者无版权，但无版权不代表你可以不遵守软件中声明的协议）。此协议要求代码分发者或者以此代码为基础开发出来的衍生作品需要以同样的协议来发布。<br>copyright 和 copyleft 下文会有详细说明。</p><p>4.LGPL (GNU Lesser General Public License)</p><p>鉴于 GPL 是如此的隔绝商业, 就出现了一个宽松版的 GPL 即 LGPL</p><p>但 LGPL 其实只是 GPL 的一个为主要为类库使用设计的开源协议，LGPL允许商业软件通过类库引用方式使用 LGPL类库而不需要开源商业软件的代码。<br>GPL&#x2F;LGPL 都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品，Hibernate 就采用了该协议。</p><p>5.BSD (Berkeley Software Distribution)</p><p>BSD 开源协议是一个给于使用者很大自由的协议, 基本上使用者可以「为所欲为」, 因此是对商业集成很友好的协议。</p><p>但「为所欲为」的前提当你发布使用了 BSD 协议的代码时, 需要满足这三个条件：</p><p>如果在发布的产品中包含源代码, 则在源代码中必须带有原来代码中的 BSD 协议<br>如果在发布的只是二进制类库&#x2F;软件, 则需要在类库&#x2F;软件的文档和版权声明中包含原来代码中的 BSD 协议<br>不可以用开源代码的作者&#x2F;机构名字和原来产品的名字做市场推广<br>采用 BSD协议的软件如：nginx</p><p>6.CC（Creative Commons） 协议<br>上面各协议只是针对软件或代码作品，如果你的作品不是代码，比如视频，音乐，图片，文章等，共享于公众之前，也最好声明一下协议以保证自己的权益不被侵犯。</p><p>针对非代码的数字作品的协议，最通用的莫过于 Creative Commons (也是你经常在别人博客下面可以看到的 CC 协议)协议。</p><p>所以现在你见到别人博客文章下面的签名就不会感到陌生了，数字作品的协议嘛。</p><p>还有更多相关协议，这里就不一一列举了，可以看看下面这张图(感谢作者的整理)，非常详细：</p><p><img src="/images/2019/01/1646d6f5b28367a8" alt="License4"></p><p>关于 MIT，Apache，GNU GPL 协议更多细节，可以看这里：Choose an open source license。</p><h2 id="四、快速选择"><a href="#四、快速选择" class="headerlink" title="四、快速选择"></a>四、快速选择</h2><p>那我们该如何选择呢？看看阮一峰老师的这张图片，简洁易懂：</p><p><img src="/images/2019/01/1646d6f5b2a3187a" alt="License2"></p><h2 id="五、为-Github-项目添加协议"><a href="#五、为-Github-项目添加协议" class="headerlink" title="五、为 Github 项目添加协议"></a>五、为 Github 项目添加协议</h2><p>在 Github 中添加协议很容易，主要分为四步：<br>1.进入你的代码仓库，点击 Create new file；<br>2.这时 Github 的新页面上，有一个空格让你填入文件名称。在输入框输入文件名 LICENSE, 然后点击右侧 Choose a license template；<br>3.出现一系列协议可供选择，选择自己想要的即可；<br>4.点击 Commit new file，这时你添加的开源协议就在代码仓库的菜单中了。</p><p>如果还不清楚，请查看图文：如何为 Github 已有仓库添加协议。</p><h2 id="六、关于默认协议"><a href="#六、关于默认协议" class="headerlink" title="六、关于默认协议"></a>六、关于默认协议</h2><p>那么问题来了，很多情况下我们都忽略了协议的重要性。试想一下，如果你无意或者有意增加协议，那么又该如何算呢？</p><p>You’re under no obligation to choose a license. It’s your right not to include one with your code or project, but please be aware of the implications. Generally speaking, the absence of a license means that the default copyright laws apply. This means that you retain all rights to your source code and that nobody else may reproduce, distribute, or create derivative works from your work. This might not be what you intend.</p><p>Even if this is what you intend, if you publish your source code in a public repository on GitHub, you have accepted the Terms of Service which do allow other GitHub users some rights. Specifically, you allow others to view and fork your repository</p><p>By setting your repositories to be viewed publicly, you agree to allow others to view and fork your repositories</p><h2 id="七、有趣的-WTFPL-协议"><a href="#七、有趣的-WTFPL-协议" class="headerlink" title="七、有趣的 WTFPL 协议"></a>七、有趣的 WTFPL 协议</h2><p>之前同事聊天的时候，有人提到过这个，觉得很有意思，翻阅 wiki 得到如下解释：<br>The WTFPL (Do What the Fuck You Want To Public License) is a permissive license most commonly used as a free software license. As a public domain like license, the WTFPL is essentially the same as dedication to the public domain.[1] It allows redistribution and modification of the software under any terms. As of May 2016, the WTFPL was used by less than one percent of open-source software projects.</p><p>Do What the Fuck You Want To Public License：你 TM 想干嘛就干嘛公共许可证。</p><p>这是一种比较极端的自由软件许可证。也就意味着等同于贡献到公有领域，该许可证已被自由软件基金会认证为兼容 GPL 的自由软件许可证。</p><h2 id="八、Copyright-和-Copyleft"><a href="#八、Copyright-和-Copyleft" class="headerlink" title="八、Copyright 和 Copyleft"></a>八、Copyright 和 Copyleft</h2><p>Copyright（著作权）很常见，我们的网站底部一般都会有它，意思是保留所有权利。而 Copyleft（著佐权）是一个由自由软件运动所发展的概念，是一种利用现有著作权体制来挑战该体制的授权方式。</p><p>Copyleft 是一种让程序或其它作品保持自由（是言论自由的自由，而不是“零价格”）的通用方法，并要求对 Copyleft 程序的任何修改和扩展都保持自由。</p><p>Copyleft 是一种对程序进行版权保护的方法。它并不是放弃版权，因为这样会使 Copyleft 变得不可操作。Copyleft 中的 left，并不使用它在英语中「保留」的意思，而是指它（left，左）与通常的版权( Copyright )中的 right（右）具有镜像的关系。</p><p>践行 Copyleft 最常见的的协议有 GPL。即如果你使用了这份开源代码，要求使用者改作后的衍生作品必须要以同等的授权方式释出以回馈社会。这意味着，如果是商业软件使用这样的开源代码并改动，商业价值有可能会下降。而 Copyleft 也是很多开源协议的标志性特点。</p><p>详细内容请查看：1.什么是 <a href="https://www.gnu.org/copyleft/">Copyleft</a>？ 2.<a href="https://blog.csdn.net/testcs_dn/article/details/51099415">WTFPL</a></p><h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><p>文章中整理了比较热门的开源协议，当然开源协议远远多于此。感兴趣的话，可以去深入学习，这里就不赘述了。而我们的目的就是了解它们，做一个文明的 Coder ，而不是流氓。不论代码或非代码作品，都凝聚了作者的心血，请尊重他们。</p><p>本文转载自： <a href="http://jartto.wang/2018/06/29/talk-about-license/">简话开源协议</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[转载]开源许可协议</title>
      <link href="/2019/01/08/tool/open-source-licenses/"/>
      <url>/2019/01/08/tool/open-source-licenses/</url>
      
        <content type="html"><![CDATA[<p>在保留软件的来源和开放性的前提下，开源许可协议(Open source licenses)向所有人授予为任何目的使用、修改和共享许可软件的权限。</p><p>下面列出常见的开源许可，从上到下约束条件逐渐减弱，即GNU AGPLv3约束力最强，Unlicense约束力最弱。</p><span id="more"></span><blockquote><p>Permissions代表获得的授权，常见授权有Commercial use、Distribution、 Private use等；<br>Conditions代表受到的约束，常见约束有Disclose source、License and copyright notice等；<br>Limitations代表边界，一般开源软件都不保证提供功能的可靠性，不承担相关责任。</p></blockquote><h2 id="GNU-AGPLv3"><a href="#GNU-AGPLv3" class="headerlink" title="GNU AGPLv3"></a>GNU AGPLv3</h2><p><img src="/images/2019/01/agpl-3-0.png" alt="agpl-3.0"></p><h2 id="GNU-GPLv3"><a href="#GNU-GPLv3" class="headerlink" title="GNU GPLv3"></a>GNU GPLv3</h2><p><img src="/images/2019/01/gpl-3-0.png" alt="gpl-3.0"></p><h2 id="GNU-LGPLv3"><a href="#GNU-LGPLv3" class="headerlink" title="GNU LGPLv3"></a>GNU LGPLv3</h2><p><img src="/images/2019/01/lgpl-3-0.png" alt="lgpl-3.0"></p><h2 id="Mozilla-Public-License-2-0"><a href="#Mozilla-Public-License-2-0" class="headerlink" title="Mozilla Public License 2.0"></a>Mozilla Public License 2.0</h2><p><img src="/images/2019/01/mpl-2-0.png" alt="mpl-2.0"></p><h2 id="Apache-License-2-0"><a href="#Apache-License-2-0" class="headerlink" title="Apache License 2.0"></a>Apache License 2.0</h2><p><img src="/images/2019/01/apache-2-0.png" alt="apache-2.0"></p><h2 id="MIT-License"><a href="#MIT-License" class="headerlink" title="MIT License"></a>MIT License</h2><p><img src="/images/2019/01/mit.png" alt="mit"></p><h2 id="The-Unlicens"><a href="#The-Unlicens" class="headerlink" title="The Unlicens"></a>The Unlicens</h2><p><img src="/images/2019/01/unlicense.png" alt="unlicense"></p><p>点击<a href="https://choosealicense.com/appendix/">appendix</a>可以查看所有常见开源许可的特性。</p><p>另外关于有几篇关于开源协议的新闻，因为蛮有意思的，这里也放上来：</p><p><a href="https://www.itcodemonkey.com/article/10582.html">MongoDB怒改开源协议！不爽这些云计算厂商不付钱</a><br><a href="https://www.pingwest.com/a/134686">微博用户协议奇葩？这有一份 Facebook 开源协议让你开开眼</a></p><blockquote><p>本文转载自：<a href="https://choosealicense.com/licenses/">https://choosealicense.com/licenses/</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常见还款计划介绍</title>
      <link href="/2019/01/05/biz/loan-scheme/"/>
      <url>/2019/01/05/biz/loan-scheme/</url>
      
        <content type="html"><![CDATA[<p>由于工作关系，最近对贷款的分期还款计划接触较多，发现其中具有一定的复杂性，而且它们名称看起来都差不多，来回念几遍整个人就蒙圈了。由此，笔者整理了最常见的几种还款方式，并以图表的形式进行对比，希望可以帮助对这方面知识有需要的读者。</p><p>另外为了加深理解，笔者将每种还款计划的计算过程，以Java代码进行相应体现，并已提交至码云，点击<a href="https://gitee.com/ypk1226/loan-scheme">loan-scheme</a>查看。</p><span id="more"></span><p>本文将从基础概念、常见还款计划、还款计划之间的区别这三方面进行阐述。</p><h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h2><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>本金</td><td>即贷款金额</td></tr><tr><td>利率</td><td>根据该值计算利息，也叫费率；月利率 &#x3D; 年利率 &#x2F; 12</td></tr><tr><td>利息</td><td>根据本金和利率计算获得，也叫手续费&#x2F;服务费</td></tr><tr><td>期数</td><td>即分多少期还款</td></tr><tr><td>剩余可用资金占比</td><td>即剩余未还金额&#x2F;应还总额，该值下降越慢，代表资金在借款人手中持有时间越长</td></tr></tbody></table><h2 id="2-常见还款计划"><a href="#2-常见还款计划" class="headerlink" title="2. 常见还款计划"></a>2. 常见还款计划</h2><p>常见分期还款计划的有这几种：</p><table><thead><tr><th align="center">序号</th><th align="center">计划名称</th><th>说明</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">等额本息还款</td><td>每期还款金额相同</td></tr><tr><td align="center">2</td><td align="center">等额本金还款</td><td>每期还款金额递减</td></tr><tr><td align="center">3</td><td align="center">一次还本付息</td><td>只还一次</td></tr><tr><td align="center">4</td><td align="center">按期付息还本</td><td>等额本息变体，减轻了还款压力</td></tr><tr><td align="center">5</td><td align="center">本金归还计划</td><td>等额本金变体，减轻了还款压力</td></tr><tr><td align="center">6</td><td align="center">等额递增&#x2F;等额递减</td><td>等额本息变体，减轻了还款压力</td></tr><tr><td align="center">7</td><td align="center">信用卡分期</td><td>等额本金和一次还本付息的变体，产生利息多于实际应收利息</td></tr></tbody></table><p>其中前三种，是最基础的还款方式，具有特定的计算公式；后四种都是前三种还款方式的变体，以应对各种需求的还款场景；下面将逐一对上述计划进行说明。</p><h3 id="2-1-等额本息还款"><a href="#2-1-等额本息还款" class="headerlink" title="2.1 等额本息还款"></a>2.1 等额本息还款</h3><p>每月偿还同等数额的贷款(包括本金和利息)；它和等额本金是不一样的概念，虽然刚开始还款时每月还款额可能会低于等额本金还款方式的额度，但是最终所还利息会高于等额本金还款方式，该方式经常被银行使用。</p><p>计算公式：</p><p>每月还本付息金额 &#x3D;[ 本金*月利率*(1+月利率)^贷款月数 ]&#x2F;[(1+月利率)^还款月数 - 1]<br>还款总利息&#x3D;贷款额*贷款月数*月利率*(1+月利率)^贷款月数&#x2F;[(1+月利率)^还款月数 - 1] -贷款额<br>还款总额&#x3D;还款月数*贷款额*月利率*(1+月利率)^贷款月数&#x2F;[(1+月利率)^还款月数 - 1]<br>每月利息 &#x3D; 剩余本金*贷款月利率<br>每月本金&#x3D;月供-每月利息</p><h3 id="2-2-等额本金还款"><a href="#2-2-等额本金还款" class="headerlink" title="2.2 等额本金还款"></a>2.2 等额本金还款</h3><p>等额本金还款又称利随本清、等本不等息还款法。贷款人将本金分摊到每个月内，同时付清上一交易日至本次还款日之间的利息。</p><p>这种还款方式相对等额本息而言，总的利息支出较低，但是前期支付的本金和利息较多，还款负担逐月递减。</p><p>计算公式：</p><p>每月还本付息金额&#x3D;(本金&#x2F;还款月数)+(本金-累计已还本金)×月利率<br>每月本金&#x3D;总本金&#x2F;还款月数<br>每月利息&#x3D;(本金-累计已还本金)×月利率<br>还款总利息&#x3D;（还款月数+1）<em>贷款额</em>月利率&#x2F;2<br>还款总额&#x3D;(还款月数+1)<em>贷款额</em>月利率&#x2F;2+贷款额</p><h3 id="2-3-一次还本付息"><a href="#2-3-一次还本付息" class="headerlink" title="2.3 一次还本付息"></a>2.3 一次还本付息</h3><p>即不进行分期，在贷款到期日一次偿还所以贷款。</p><p>由此此方式容易使贷款人缺少还款强迫外力，造成信用损害，所以虽然还款方式操作简单，但是适应的人群面比较窄。采用这种贷款方式，贷款人最好有较好的自我安排能力。</p><p>计算公式：</p><p>到期一次还本付息额&#x3D;贷款本金×[(1+月利率)×贷款期（月）]</p><h3 id="2-4-按期付息还本（等额本息变体）"><a href="#2-4-按期付息还本（等额本息变体）" class="headerlink" title="2.4 按期付息还本（等额本息变体）"></a>2.4 按期付息还本（等额本息变体）</h3><p>按期付息还本是指通过和银行协商，可以制订不同还款时间单位。即自主决定按月、季度或年等时间间隔还款。</p><p>从某种程度来说，其是等额本息还款的变体。例如，15年期，20万元贷款，采用等额本息还款，每月还款额为1707元。如果贷款人选择比较灵活的方式，就可以选择每两个月还3414元。</p><h3 id="2-5-本金归还计划（等额本金变体）"><a href="#2-5-本金归还计划（等额本金变体）" class="headerlink" title="2.5 本金归还计划（等额本金变体）"></a>2.5 本金归还计划（等额本金变体）</h3><p>贷款人经过与银行的协商，每次本金还款不少于1万元，两次还款时间的间隔不能超过12个月，利息可以按月或是按季度归还。</p><p>这种还款方式是银行专门为那些非月收入的入群制定的。尤其考虑到了在年底有大额奖金的人。</p><p>此外，上层行的在家办公一族，很多人每个月都没有固定的收入，但是他们每完成一部作品都会有较大的收入，这些人比较适合这种还款方式。</p><h3 id="2-6-等额递增-等额递减（等额本息变体）"><a href="#2-6-等额递增-等额递减（等额本息变体）" class="headerlink" title="2.6 等额递增&#x2F;等额递减（等额本息变体）"></a>2.6 等额递增&#x2F;等额递减（等额本息变体）</h3><p>这两种还款方式，没有本质上的差异。作为目前几大银行的主推方式，它是等额本息还款方式的另一种变体。</p><p>它把还款年限进行了细化分割，每个分割单位中，还款方式等同于等额本息。区别在于，每个时间分割单位的还款数额可能是等额增加或者等额递减。</p><p>等额递增方式适合目前还款能力较弱，但是，已经预期到未来会逐步增加的人群。很多年轻人需要买房，并且工作业绩不错，虽然目前的收入负担房贷较困难， 但是考虑到未来升迁后的收入大幅增加，可以采用等额递增还款。相反，如果预计到收入将减少，或者目前经济很宽裕，可以选择等额递减。</p><h3 id="2-7-信用卡分期（等额本金和一次还本付息组合后的变体）"><a href="#2-7-信用卡分期（等额本金和一次还本付息组合后的变体）" class="headerlink" title="2.7 信用卡分期（等额本金和一次还本付息组合后的变体）"></a>2.7 信用卡分期（等额本金和一次还本付息组合后的变体）</h3><p>在所有分期方式中，该方式是<font color='red'>对借款人最不利</font>的分期方式；</p><p>本金按照等额本金的方式计算，利息却按照一次还本付息的方式计算，忽略已还金额对利息的影响，已经有很多文章(<a href="http://finance.qq.com/original/MissMoney/mm0215.html">信用卡分期付款有多坑 你知道吗？</a>)进行相关吐槽，这里不再赘述。</p><h2 id="3-还款计划之间的区别"><a href="#3-还款计划之间的区别" class="headerlink" title="3. 还款计划之间的区别"></a>3. 还款计划之间的区别</h2><p>为了方便描述，我们做如下约定：</p><table><thead><tr><th>名称</th><th>约定值</th></tr></thead><tbody><tr><td>借款金额</td><td>10万元</td></tr><tr><td>期数</td><td>12期</td></tr><tr><td>年利率</td><td>12%</td></tr><tr><td>按期付息还本</td><td>每一期固定为3个月</td></tr><tr><td>本金归还计划</td><td>利息每3个月还一次款，本金按照6个月还一次款</td></tr></tbody></table><h3 id="3-1-每期还款趋势对比"><a href="#3-1-每期还款趋势对比" class="headerlink" title="3.1 每期还款趋势对比"></a>3.1 每期还款趋势对比</h3><div id="echarts5888" style="width: 100%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts5888'));        // 指定图表的配置项和数据        var option = {    title: {        text: '还款计划趋势',        subtext: '可切换对比'    },    tooltip: {        trigger: 'axis'    },    legend: {        data:['等额本息','等额本金','一次还本付息','按期付息还本','本金归还计划','信用卡分期'],        selected: {            '等额本息': true,            '等额本金': true,            '一次还本付息': false,            '按期付息还本': false,            '本金归还计划': false,            '等额递增': false,            '信用卡分期': false        }    },    grid: {        left: '3%',        right: '4%',        bottom: '3%',        containLabel: true    },    toolbox: {        feature: {            saveAsImage: {}        }    },    xAxis: {        type: 'category',        boundaryGap: false,        data: ['1月','2月','3月','4月','5月','6月','7月','8月','9月','10月','11月','12月']    },    yAxis: {        type: 'value'    },    series: [        {            smooth: true,            name:'等额本息',            type:'line',            data:[8884.88,8884.88,8884.88,8884.88,8884.88,8884.88,8884.88,8884.88,8884.88,8884.88,8884.88,8884.88]        },        {            smooth: true,            name:'等额本金',            type:'line',            data:[9333.33,9250.00,9166.66,9083.33,9000.00,8916.66,8833.33,8750.00,8666.66,8583.33,8500.00,8416.70]        },        {            smooth: true,            name:'一次还本付息',            type:'line',            data:[0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,112000.00]        },        {            smooth: true,            name:'按期付息还本',            type:'line',            data:[0.00,0.00,26654.64,0.00,0.00,26654.64,0.00,0.00,26654.64,0.00,0.00,26654.64]        },        {            smooth: true,            name:'本金归还计划',            type:'line',            data:[0.00,0.00,2750.00,0.00,0.00,51999.98,0.00,0.00,1250.00,0.00,0.00,50500.02]        },        {            smooth: true,            name:'信用卡分期',            type:'line',            data:[9333.33,9333.33,9333.33,9333.33,9333.33,9333.33,9333.33,9333.33,9333.33,9333.33,9333.33,9333.37]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p><strong>等额本息 vs 等额本金</strong></p><p>等额本息每月还款金额相同；等额本金逐月递减，且前面一半期数还款金额大于等额本息，后面一半期数小于等额本息。</p><p><strong>等额本息 vs 按期付息还本</strong></p><p>按期付息还本是等额本息的变体；与等额本息的区别在于还款时间点变少，每期还款额度增大。</p><p><strong>等额本金 vs 本金归还计划</strong></p><p>本金归还计划是等额本金的变体；与等额本金区的别在于还款时间点变少，每期还款额度增大。</p><h3 id="3-2-还款总额对比"><a href="#3-2-还款总额对比" class="headerlink" title="3.2 还款总额对比"></a>3.2 还款总额对比</h3><div id="echarts9452" style="width: 100%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts9452'));        // 指定图表的配置项和数据        var option = {    title : {        text: '还款总额对比'    },    tooltip : {        trigger: 'axis'    },    legend: {        data:['总还款金额']    },    toolbox: {        show : true,        feature : {            dataView : {show: true, readOnly: false},            magicType : {show: true, type: ['line', 'bar']},            restore : {show: true},            saveAsImage : {show: true}        }    },    calculable : true,    xAxis : [        {            type : 'category',            data : ['等额本息','等额本金','一次还本付息','按期付息还本','本金归还计划','信用卡分期']        }    ],    yAxis : [        {            type : 'value'        }    ],    series : [        {            name: '总还款金额',            type: 'bar',            itemStyle: {              normal: {                label: {                  show: true, //开启显示                  position: 'top', //在上方显示                  textStyle: { //数值样式                    color: 'black',                    fontSize: 16                  },                  formatter: function(a) {                    var result = a.data;                    if((a.data + '').indexOf('\.') == -1) {                      result = a.data + '.00';                    }                    return result;                  }                }              }            },            barWidth: '28%',            data: [106618.56, 106500.00, 112000.00, 106618.56, 106500.00, 112000.00]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>还款金额从高到低，依次是：</p><ul><li>一次还本付息、信用卡分期</li><li>等额本息、按期付息还本总额相同</li><li>等额本金、本金归还计划</li></ul><h3 id="3-3-剩余可用资金占比趋势"><a href="#3-3-剩余可用资金占比趋势" class="headerlink" title="3.3 剩余可用资金占比趋势"></a>3.3 剩余可用资金占比趋势</h3><div id="echarts4402" style="width: 100%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts4402'));        // 指定图表的配置项和数据        var option = {    title: {        text: '剩余可用资金占比趋势',        subtext: '可切换对比'    },    tooltip: {        trigger: 'axis'    },    legend: {        data:['等额本息','等额本金','一次还本付息','按期付息还本','本金归还计划','信用卡分期']    },    grid: {        left: '3%',        right: '4%',        bottom: '3%',        containLabel: true    },    toolbox: {        feature: {            saveAsImage: {}        }    },    xAxis: {        type: 'category',        boundaryGap: false,        data: ['1月','2月','3月','4月','5月','6月','7月','8月','9月','10月','11月','12月']    },    yAxis: {        type: 'value'    },    series: [        {            smooth: true,            name:'等额本息',            type:'line',            itemStyle: {              normal: {                label: {                  formatter: function(a) {                    var result = a.data;                    if((a.data + '').indexOf('\.') == -1) {                      result = a.data + '.00';                    }                    return result;                  }                }              }            },            data:[91.67,83.33,75.00,66.67,58.33,50.00,41.67,33.33,25.00,16.67,8.33,0.00]        },        {            smooth: true,            name:'等额本金',            type:'line',            itemStyle: {              normal: {                label: {                  formatter: function(a) {                    var result = a.data;                    if((a.data + '').indexOf('\.') == -1) {                      result = a.data + '.00';                    }                    return result;                  }                }              }            },            data:[91.24,82.55,73.94,65.41,56.96,48.59,40.30,32.08,23.94,15.88,7.90,0.00]        },        {            smooth: true,            name:'一次还本付息',            type:'line',            itemStyle: {              normal: {                label: {                  formatter: function(a) {                    var result = a.data;                    if((a.data + '').indexOf('\.') == -1) {                      result = a.data + '.00';                    }                    return result;                  }                }              }            },            data:[100.00,100.00,100.00,100.00,100.00,100.00,100.00,100.00,100.00,100.00,100.00,0.00]        },        {            smooth: true,            name:'按期付息还本',            type:'line',            itemStyle: {              normal: {                label: {                  formatter: function(a) {                    var result = a.data;                    if((a.data + '').indexOf('\.') == -1) {                      result = a.data + '.00';                    }                    return result;                  }                }              }            },            data:[100.00,100.00,75.00,75.00,75.00,50.00,50.00,50.00,25.00,25.00,25.00,0.00]        },        {            smooth: true,            name:'本金归还计划',            type:'line',            itemStyle: {              normal: {                label: {                  formatter: function(a) {                    var result = a.data;                    if((a.data + '').indexOf('\.') == -1) {                      result = a.data + '.00';                    }                    return result;                  }                }              }            },            data:[100.00,100.00,97.42,97.42,97.42,48.59,48.59,48.59,47.42,47.42,47.42,0.00]        },        {            smooth: true,            name:'信用卡分期',            type:'line',            itemStyle: {              normal: {                label: {                  formatter: function(a) {                    var result = a.data;                    if((a.data + '').indexOf('\.') == -1) {                      result = a.data + '.00';                    }                    return result;                  }                }              }            },            data:[91.67,83.33,75.00,66.67,58.33,50.00,41.67,33.33,25.00,16.67,8.33,0.00]        }    ]};        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>剩余可用资金占比下降速度稳定，代表每期还款金额近似，每次还款压力较小；剩余可用资金占比水平持续时间越长，到期后还款压力越大。</p><p>上图中，一次还本付息水平持续时间最长；其次是按期付息还本、本金归还计划有部分水平持续时间； 而额本金、等额本息、信用卡分期都是逐期递减的。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>本文介绍了几个常见个还款计划，并分别从还款趋势、还款总额、剩余可用资金占比趋势三个方面进行了对比；可以将这7种还款计划分为四类：</p><p><strong>1. 一次还本付息</strong></p><p>持续较高的剩余可用资金占比，但利息也高，且最后还款压力大。</p><p><strong>2. 等额本息、按期付息还本、等额递增</strong></p><p>等额本息，每期还款金额相同，还款压力稳定，但利息比等额本金高。</p><p>变体后的按期付息还本、等额递增，转移并集中了还款压力，适用于收入不稳定的人群。</p><p><strong>3. 等额本金、本金归还计划</strong></p><p>等额本金，每期还款逐渐减少，初期还款压力大，后期越来越小，总利息最低。</p><p>变体后的本金归还计划，也是转移了还款压力，适用于收入不稳定的人群。</p><p><strong>4. 信用卡分期</strong></p><p>最无赖的还款方式，将“利率”更名为“手续费费率”，看数字很低，但是换算成年化利率后变得很高。</p><p>利息按一次还本付息的方式收取，本金按等额本金的方式收取。</p><h2 id="参考的文章："><a href="#参考的文章：" class="headerlink" title="参考的文章："></a>参考的文章：</h2><p><a href="http://www.zgesfw.roboo.com/web/index/316048.htm">六种还款方式</a><br><a href="http://www.haodai.com/zixun/70913.html">按期付息还本计算公式</a><br><a href="https://zhishi.fang.com/xf/nanjing_34532.html">按揭怎么算？等额本息、等额本金计算公式</a></p>]]></content>
      
      
      <categories>
          
          <category> 业务知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 还款计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Logging Framework 现状</title>
      <link href="/2018/12/22/java/java-loging-framework/"/>
      <url>/2018/12/22/java/java-loging-framework/</url>
      
        <content type="html"><![CDATA[<p>某日笔者心情不错，写代码时没有复制粘贴，打算手敲logger的相关代码，在IDE获得的提示是这样的：</p><p><img src="/images/2018/12/ide-tip.png" alt="IED的日志提示"></p><p>尽管知道<code>ch.qos.logback.classic.Logger</code>在项目中是正确的选择，上图中Logger同名类的数量确实确实让笔者惊讶了一番，为什么这么多同名类？于是就有了这一篇文章。</p><span id="more"></span><p>逐一观察上述的Logger列表后，笔者发现很多jar包的编译版本是Java5、Java6，以<code>com.alibaba.nacos.client.logger.Logger</code>接口为例，它有这几个三个实现类<code>Log4j2Logger</code>,<code>NopLogger</code>,<code>Slf4jLogger</code>，不难看出alibaba这个Logger类是为了灵活切换Log4j2和Slf4j的调用。</p><p>由此笔者推测，老旧的Logger如此之多，多半是由于java.util.logging提供的功能太弱，且当时市面上流行的日志框互相之间的兼容性并不好，开发者们只好自己动手，丰衣足食。而时至今日，Java主流的日志框架发展到了什么程度？旧版本的兼容问题是如何处理的？带着这些问题，我们一起来分析下Java Logging Framework现状。</p><p>本文将从流行的日志框架、日志框架实现、日志框架通用API、常见问题这四个方面进行叙述。</p><h2 id="1-流行的Java日志框架"><a href="#1-流行的Java日志框架" class="headerlink" title="1. 流行的Java日志框架"></a>1. 流行的Java日志框架</h2><p>如何确定哪些框架是最流行的日志框架呢，<a href="https://mvnrepository.com/">mvnrepository</a>是一个很好的参考，该网站<a href="https://mvnrepository.com/open-source/logging-frameworks?p=1">logging-frameworks</a>分类下被使用次数最多的artifact整理如下(统计日期为2018-12-22)：</p><table><thead><tr><th>groupId</th><th align="center">artifactId</th><th align="center">使用次数</th><th align="center">占比</th><th align="center">最后更新日期</th></tr></thead><tbody><tr><td>org.slf4j</td><td align="center">slf4j-api</td><td align="center">33401</td><td align="center"><img src="http://progressed.io/bar/37"></td><td align="center">2018年3月21日</td></tr><tr><td>ch.qos.logback</td><td align="center">logback-classic</td><td align="center">14366</td><td align="center"><img src="http://progressed.io/bar/17"></td><td align="center">2018年2月11日</td></tr><tr><td>log4j</td><td align="center">log4j</td><td align="center">13931</td><td align="center"><img src="http://progressed.io/bar/16"></td><td align="center">2012年5月26日</td></tr><tr><td>commons-logging</td><td align="center">commons-logging</td><td align="center">8278</td><td align="center"><img src="http://progressed.io/bar/8"></td><td align="center">2014年7月5日</td></tr><tr><td>org.slf4j</td><td align="center">slf4j-simple</td><td align="center">7368</td><td align="center"><img src="http://progressed.io/bar/8"></td><td align="center">2018年3月21日</td></tr><tr><td>org.apache.logging.log4j</td><td align="center">log4j-core</td><td align="center">3709</td><td align="center"><img src="http://progressed.io/bar/4"></td><td align="center">2018年7月30日</td></tr><tr><td>org.apache.logging.log4j</td><td align="center">log4j-api</td><td align="center">2930</td><td align="center"><img src="http://progressed.io/bar/3"></td><td align="center">2018年7月30日</td></tr><tr><td>ch.qos.logback</td><td align="center">logback-core</td><td align="center">2925</td><td align="center"><img src="http://progressed.io/bar/3"></td><td align="center">2018年2月11日</td></tr><tr><td>org.jboss.logging</td><td align="center">jboss-logging</td><td align="center">1734</td><td align="center"><img src="http://progressed.io/bar/2"></td><td align="center">2018年2月14日</td></tr><tr><td>org.clojure</td><td align="center">tools.logging</td><td align="center">1258</td><td align="center"><img src="http://progressed.io/bar/1"></td><td align="center">2018年3月19日</td></tr></tbody></table><p>其中slf4j-api、logback-classic和log4j遥遥领先其它框架；commons-logging和log4j的最后更新时间都是几年前，明显已停止维护了。另外，apache大名鼎鼎的log4j-api和log4j-core竟然排在后面，确实出人意料。至于排在末两位的org.jboss.logging和org.clojure在此略作说明，后续不再做讨论。</p><p>上述日志框架可以分为两类：具体实现、通用API。日志通用API仅提供一套通用API，不提供具体实现，也不包装具体实现的配置(logback.xml或log4j.xml等)，从而达到快速切换具体实现的目的。</p><p>日志框架具体实现有：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://logback.qos.ch/manual/configuration.html">logback-classic</a></td><td>Log4j 1.x项目发起人离开apache后，主导开发出的一套日志框架实现，默认实现slf4j-api，现在已经是最热门的日志框架。</td></tr><tr><td><a href="https://logging.apache.org/log4j/1.2/manual.html">Log4j 1.x</a></td><td>又名log4j12，意为1.x的最后一个版本1.2，apache早期推出的日志实现，奠定了Java日志框架的基础，大量老项目使用了该框架，目前已停止更新。</td></tr><tr><td><a href="https://logging.apache.org/log4j/2.x/">log4j 2.x</a></td><td>apache最近几年新推出的日志框架，功能齐全、性能强劲、文档齐全。</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html">Java Util Logging</a></td><td>又名JUL(首字母缩写)、JDK logging、jdk14(发布于jdk1.4)，包含在JDK内部java.util.logging包下的日志实现，每个服务都包含这个实现，因此不包含在上面的排行榜中。</td></tr></tbody></table><p>日志框架通用API(又名Logging Shim或Logging Bridge)有：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.slf4j.org/manual.html">slf4j-api</a></td><td>当下如日中天的日志API，大量的开发者依赖此api编写日志相关代码，后文将展开详细解读。</td></tr><tr><td><a href="https://commons.apache.org/proper/commons-logging/guide.html">commons-logging</a></td><td>又名<strong>JCL</strong>(Jakarta Commons Logging)，apache早期提供的日志api，由于种种原因没有发展起来，现在已停止更新。</td></tr><tr><td><a href="http://docs.jboss.org/hibernate/orm/4.3/topical/html/logging/Logging">org.jboss.logging</a></td><td>由于其支持国际化功能，hibernate从4.0开始一直使用该框架，本文后续不讨论该框架。</td></tr><tr><td><a href="https://clojure.github.io/tools.logging/">org.clojure</a></td><td>在Clojure语言中使用，本文后续不讨论该框架。</td></tr></tbody></table><h2 id="2-日志框架具体实现"><a href="#2-日志框架具体实现" class="headerlink" title="2. 日志框架具体实现"></a>2. 日志框架具体实现</h2><p>日志框架一般主要由三部分构成：Logger、Formatter和Handler(又名Appender)；其中Logger负责收集需要记录的信息和一些元数据，随后Formatter将收集到的信息进行格式化，最后由Handler(又名Appender)决定日志输出的方式，输出方式多种多样，可以控制台、磁盘文件等。</p><p>一个Logger可以同时关联到多个Appender，因此一份日志可以同时以多种方式输出；一个Appender再关联到一个Formatter以指定其格式。多个Logger之间具有特定的层次结构，下面笔者对这种层次结构进行详细介绍。</p><p><strong>Named的层次结构</strong><br/></p><p>Logger的名称通常具有层次结构，如下方所示，com.sun是com的子级，com.sun.some是com.sun的子级。</p><ul><li>com</li><li>com.sun</li><li>com.sun.some</li></ul><p><strong>Level的层次结构</strong><br/></p><p>若当前Logger没有设置日志级别，则从父级继承；若当前Logger已设置日志级别，则忽略父级的日志级别，举例如下：</p><table><thead><tr><th>Logger名称</th><th align="center">声明的Level</th><th align="center">继承的Level</th></tr></thead><tbody><tr><td>root</td><td align="center">Proot</td><td align="center">Proot</td></tr><tr><td>X</td><td align="center">Px</td><td align="center">Px</td></tr><tr><td>X.Y</td><td align="center">none</td><td align="center">Px</td></tr><tr><td>X.Y.Z</td><td align="center">Pxyz</td><td align="center">Pxyz</td></tr></tbody></table><p><strong>Appender的可叠加性</strong><br/></p><p>子级Logger会从父级继承关联的Appender作为自己的Appender，与子级自身关联的Appender叠加起来(即Appender使是相同的)，距离如下：</p><table><thead><tr><th>Logger名称</th><th align="center">叠加的Appender</th><th align="center">叠加性是标识</th><th align="center">输出目标</th></tr></thead><tbody><tr><td>root</td><td align="center">A1</td><td align="center">不可配置</td><td align="center">A1</td></tr><tr><td>x</td><td align="center">A-x1, A-x2</td><td align="center">true</td><td align="center">A1, A-x1, A-x2</td></tr><tr><td>x.y</td><td align="center">none</td><td align="center">true</td><td align="center">A1, A-x1, A-x2</td></tr><tr><td>x.y.z</td><td align="center">A-xyz1</td><td align="center">true</td><td align="center">A1, A-x1, A-x2, A-xyz1</td></tr><tr><td>security</td><td align="center">A-sec</td><td align="center">false</td><td align="center">A-sec</td></tr><tr><td>security.access</td><td align="center">none</td><td align="center">true</td><td align="center">A-sec</td></tr></tbody></table><p>最后，让我们回到上文所述的四个日志框架的具体实现上来，下面将按照框架诞生的时间顺序，进行逐一介绍；其中logback和log4j 2.x社区都非常活跃，是Java日志框架的主力军，笔者将进行重点介绍。</p><h3 id="2-1-Log4j-1-x（始于1999）"><a href="#2-1-Log4j-1-x（始于1999）" class="headerlink" title="2.1 Log4j 1.x（始于1999）"></a>2.1 Log4j 1.x（始于1999）</h3><p><a href="https://logging.apache.org/log4j/1.2/manual.html">Log4j 1.x</a>是由Ceki Gülcü在ASF(Apache Software Foundation)发起的开源项目，其第一个版本发布于1999年，一经发布就在开源社区中得到了广泛的使用，包括一些大名鼎鼎的项目，如JBoss和Hibernate。Log4j的体系结构是围绕三个主要概念构建的：loggers、appenders和layouts，在此之后的日志框架，大多也采用了这个结构。</p><p><a href="https://logging.apache.org/log4j/1.2/manual.html">Log4j 1.x</a>最后更新时间为2012年5月26日(版本为1.2.17)，于2015年8月5日正式宣布停止更新。 时至今日，Log4j 1.x的引用比例仍有16%，开发者们更多的考虑的是如何兼容旧版本，除了这个理由之外，不会再选择该框架了。</p><h3 id="2-2-Java-Util-Logging（始于2002）"><a href="#2-2-Java-Util-Logging（始于2002）" class="headerlink" title="2.2 Java Util Logging（始于2002）"></a>2.2 Java Util Logging（始于2002）</h3><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html">Java Util Logging</a>是2002年发布的Java1.4新增的特性，其模仿log4j实现了基本的日志输出功能，但由于发布时间相比Log4j 1.x晚一些，且功能上不如Log4j完善，一直没有真正流行起来；目前对于该框架，多数项目考虑的也是兼容性。</p><h3 id="2-3-logback（始于2006）"><a href="#2-3-logback（始于2006）" class="headerlink" title="2.3 logback（始于2006）"></a>2.3 logback（始于2006）</h3><p><a href="https://logging.apache.org/log4j/1.2/manual.html">Log4j 1.x</a>项目开展到后期，项目发起者Ceki Gülcü觉得自己失去了对框架的控制，新特性的决定变的复杂，提意见的人太多了，陷入了无休止的邮件往来之中；后来Ceki Gülcü决定脱离ASF，打算重头开始再写一个日志框架，于是<a href="https://logback.qos.ch/index.html">logback</a>诞生了。</p><p>2006年7月26日，<a href="https://logback.qos.ch/index.html">logback</a>的第一个release版本正式发布，随后快速地迭代发布新版本，目前是<a href="https://mvnrepository.com/">mvnrepository</a>上显示的日志框架中最为流行的；而该项目发起人Ceki Gülcü着实是个牛人，笔者特地找了其本人的两张照片放在下面（侵删）。</p><p><img src="/images/2018/12/ceki-gulcu.png" alt="Ceki Gülcü"></p><p>logback分为三个模块，logback-core, logback-classic和logback-access。其中logback-core模块为其他两个模块提供了基础功能；logback-classic模块可以视为log4j的改进版本，同时logback-classic天生就实现了SLF4J API，这样开发者就可以在不修改客户端代码的前提下，随时切换底层具体实现。</p><p>logback-access模块可以与Servlet容器(如Tomcat和Jetty)集成，以提供HTTP-access日志功能。logback具有以下优秀特性：</p><ul><li>速度快且占用内存少</li><li>经过了大量的测试</li><li>天生实现了SLF4J API，使用SLF4J API时不会存在任何性能损失</li><li>丰富完善的文档</li><li>配置文件支持XML或Groovy</li><li>自动重新加载配置文件</li><li>可以从I&#x2F;O故障中进行优雅的恢复</li><li>可以自动删除旧日志档案</li><li>可以压缩日志文件</li><li>谨慎模式下，可以让多个JVM写入同一个文件</li><li>提供名为Lilith的日志查看器，可以查看大日志文件</li><li>配置文件支持if-then-else的判断</li><li>过滤器(Filter)机制提供的扩展，比如可以在不改变日志level的前提下，输出某些level更低的日志</li><li>SiftingAppender可以根据运行时属性拆分日志文件，比如为每个用户单独创建一份日志文件</li><li>发生异常时，打印完整的堆栈信息，精确到对应jar包的版本号</li><li>logback-access对HTTP-access日志提供了强有力的支持</li></ul><h3 id="2-4-Log4j-2-x（始于2014"><a href="#2-4-Log4j-2-x（始于2014" class="headerlink" title="2.4 Log4j 2.x（始于2014)"></a>2.4 Log4j 2.x（始于2014)</h3><p><a href="https://logging.apache.org/log4j/2.x/">Log4j 2.x</a>(又名log4j2)是ASF对<a href="https://logging.apache.org/log4j/1.2/manual.html">Log4j 1.x</a>的重构和升级，并且不再与之前的版本兼容。该项目始于2012年07月29日，2014年07月12日发布了第一个release版本，Log4j2是这四个日志实现框架中最年轻的一个，它综合了Log4j 1.x和logback的优点，并改进它们已知的不足，可以说是这四个日志框架中最新先进的。它具有以下优秀特性：</p><ul><li>API与实现分离，使开发者清楚地知道可以使用哪些类和方法，同时确保向前兼容</li><li>性能显著提示，官网文档宣称在多线程场景下，性能明显优于其他三个日志框架</li><li>支持多种API，支持Log4j 1.2、SLF4J、Commons Logging和java.util.logging (JUL) APIs</li><li>避免锁定实现，提供log4j-to-slf4j适配器，可以重定向访问Log4j2的请求</li><li>支持配置文件自动重载，并且解决了logback自动重载配置文件时的问题</li><li>更加先进的过滤器(Filter)，在logback之上做了优化</li><li>支持插件机制</li><li>配置属性支持</li><li>Java 8 Lambda表达式支持</li><li>自定义日志级别</li><li>在运行的程序中不产生内存垃圾，在web程序中产生少量内存垃圾，减轻了垃圾回收的压力</li><li>提供与应用服务器集成的能力，如tomcat和netty</li></ul><p>作为最晚出现的日志框架，Log4j 2.x的细节特性优于以往的任何框架，但为何<a href="https://mvnrepository.com/">mvnrepository</a>中使用量如此低呢？笔者分析，可能是SLF4J API的深入人心，而logback默认实现了该API，使用起来性能不存在损耗，所以多数开发者习惯性选择了logback作为其实现。</p><p>不管怎样，Log4j2是一个强大而健壮的日志记录框架，具有非常灵活的配置选项，相信未来会有越来越多的人使用该框架。</p><h2 id="3-日志框架API"><a href="#3-日志框架API" class="headerlink" title="3. 日志框架API"></a>3. 日志框架API</h2><p>日志框架API，又名Logging Shim或Logging Bridge，设计目的是解决应用程序切换日志实现框架不方便的问题，API不提供日志输出的配置功能，如何编写配置文件需要具体的日志实现框架决定。 使用最广泛的API是<a href="https://www.slf4j.org/manual.html">slf4j-api</a>和<a href="https://commons.apache.org/proper/commons-logging/guide.html">Apache Commons Logging</a>(又名<strong>JCL</strong>，Jakarta Commons Logging)。一般情况下，通过API调用日志框架实现的流程如下：</p><p><img src="/images/2018/12/log-api.png" alt="调用日志框架API流程"></p><h3 id="3-1-JCL（Jakarta-Commons-Logging）（始于2002"><a href="#3-1-JCL（Jakarta-Commons-Logging）（始于2002" class="headerlink" title="3.1 JCL（Jakarta Commons Logging）（始于2002)"></a>3.1 JCL（Jakarta Commons Logging）（始于2002)</h3><p>JCL是Apache与2002年发布的一个日志API，最后一次更新时间为2014年07月11日， 使用它可以隔离具体的日志实现，使底层日志实现代码不侵入项目，方便进行切换。当引入了common-logging之后，它将自动查找当前classpath下包含的，用户不需要任何配置。查找的顺序如下：</p><ol><li>寻找配置文件中是否为org.apache.common.logging.Log配置的值</li><li>是否包含log4j</li><li>是否包含JDK Logger</li><li>使用Common-logging自带的SimpleLog</li></ol><p>如上所述，如果想要指定使用哪个实现，可以在classpath目录下新增common-logging.properties文件，指定Log4j示例如下：</p><pre class="line-numbers language-none"><code class="language-none">org.apache.commons.logging.Log&#x3D;org.apache.commons.logging.impl.Log4JLogger<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-SLF4J（Simple-Logging-Facade-for-Java）（始于2005"><a href="#3-2-SLF4J（Simple-Logging-Facade-for-Java）（始于2005" class="headerlink" title="3.2 SLF4J（Simple Logging Facade for Java）（始于2005)"></a>3.2 SLF4J（Simple Logging Facade for Java）（始于2005)</h3><p>SLF4J始于2005年，是目前使用最为广泛的日志API，该API也是由Ceki Gülcü主导发起的；与JCL不同的是，API转换过程不包含在SLF4J API中，SLF4J运用了Java提供的<a href="https://docs.oracle.com/javase/7/docs/api/java/util/ServiceLoader.html">Service Loader</a>机制，将SLF4J API和实际的转换映射过程在依赖上完全分离，在runtime时才使用具体实现。</p><h3 id="3-2-1-SLF4J-API绑定日志实现"><a href="#3-2-1-SLF4J-API绑定日志实现" class="headerlink" title="3.2.1 SLF4J API绑定日志实现"></a>3.2.1 SLF4J API绑定日志实现</h3><p>SLF4J API需要一些用于绑定日志实现的jar包，来确定到底使用哪个日志框架，这些Jar包也包含了对应日志实现框架的依赖；已有的Jar包整理汇总如下：</p><table><thead><tr><th>JAR</th><th>描述</th></tr></thead><tbody><tr><td>slf4j-log4j12</td><td>用于绑定Log4j 1.2版本，即调用SLF4J API时，重定向到Log4j 1.2</td></tr><tr><td>slf4j-jdk14</td><td>用于绑定JUL，即调用SLF4J API时，重定向到JUL（java.util.logging）</td></tr><tr><td>slf4j-jcl</td><td>用于绑定JCL，调用SLF4J API时，重定向到JCL（apache的Jakarta Commons Logging）</td></tr><tr><td>slf4j-nop</td><td>绑定一个空实现，默认忽略掉所有的日志</td></tr><tr><td>slf4j-simple</td><td>绑定简单实现，直接输入日志到控制台</td></tr><tr><td>logback-classic</td><td>天生实现SLF4J API，调用SLF4J API时，使用logback相关库</td></tr><tr><td>log4j-slf4j-impl</td><td>该库是由apache提供，作用是调用SLF4J API时，重定向到Log4J 2.x</td></tr></tbody></table><p>SLF4J API在运行时会进行自动检测当前classpath中是否包含绑定日志实现的Jar包，若存在则实例化该Jar包指向的的日志实现。注意SLF4J API不支持同时使用多个日志实现，当classpath中出现多个实现时，SLF4J API只会选择使用其中一个并打印警告信息。下图说明了绑定过程：</p><img src="/images/2018/12/slf4j-binding.png" width=800><h3 id="3-2-2-SLF4J-桥接遗留的API"><a href="#3-2-2-SLF4J-桥接遗留的API" class="headerlink" title="3.2.2 SLF4J 桥接遗留的API"></a>3.2.2 SLF4J 桥接遗留的API</h3><p>SLF4J除了以API的身份包装底层接口外，还有<strong>桥接遗留API</strong>的功能；假设某个项目中包含了JUL、JCL、Log4j 1.x这些日志框架的日志调用，其中明确引入了具体的框架实现，SLF4J可以把这些框架的调用强行重定向到已经绑定的日志实现，从而使项目中所有的日志调用全部指向一个唯一的实现。可以用桥接遗留API的Jar包整理如下：</p><table><thead><tr><th>JAR</th><th>描述</th></tr></thead><tbody><tr><td>jcl-over-slf4j</td><td>桥接JCL到SLF4J，将使用JCL相关代码的日志调用重定向到SLF4J</td></tr><tr><td>jul-to-slf4j</td><td>桥接JUL到SLF4J，将使用JUL相关代码的日志调用重定向到SLF4J；此转换会有额外的性能开销，需要做一定处理才行，详见<a href="https://www.slf4j.org/legacy.html#jclRecursion">Bridging legacy APIs</a></td></tr><tr><td>log4j-over-slf4j</td><td>桥接Log4j 1.x到SLF4J，将使用Log4j 1.x相关代码的日志调用重定向到SLF4J</td></tr></tbody></table><blockquote><p><strong>jcl-over-slf4j vs slf4j-jcl</strong><br/><br>注意这两个Jar不能同时使用，前者是将JCL的调用重定向到SLF4J绑定的日志实现，后者又将日志实现指定为了JCL，这是自相矛盾的；而JUL和Log4j 1.x也是如此。</p></blockquote><p>若读者觉得不好理解，可以直接查看笔者在码云上的示例代码<a href="https://gitee.com/ypk1226/sample-logging-framework/blob/master/together-slf4j-log4j2-cover-others/src/main/java/com/learn/together/slf4j/log4j/cover/others/SLF4jLog4jCoverOthers.java"><code>SLF4jLog4jCoverOthers</code></a>。该功能对于SLF4J API的<strong>快速传播</strong>起到了重要作用，它的流程是这样的：</p><img src="/images/2018/12/bridging-legacy-apis.png" width=800><h2 id="4-常见问题"><a href="#4-常见问题" class="headerlink" title="4. 常见问题"></a>4. 常见问题</h2><p>常见问题中的相关代码，笔者已提交至码云，有需要可以查看<a href="https://gitee.com/ypk1226/sample-logging-framework">sample-logging-framework</a>。</p><h3 id="4-1-为SLF4J绑定多个日志实现"><a href="#4-1-为SLF4J绑定多个日志实现" class="headerlink" title="4.1 为SLF4J绑定多个日志实现"></a>4.1 为SLF4J绑定多个日志实现</h3><p>由于SLF4J API仅支持绑定一个日志实现，在pom中同时指定两个日志实现会得到如下的错误信息，此时去掉一种一个实现的依赖即可，比如下面的场景去除<code>slf4j-log4j12</code>的依赖。</p><pre class="line-numbers language-none"><code class="language-none">SLF4J: Class path contains multiple SLF4J bindings.SLF4J: Found binding in [jar:file:&#x2F;Users&#x2F;ypk&#x2F;.m2&#x2F;repository&#x2F;ch&#x2F;qos&#x2F;logback&#x2F;logback-classic&#x2F;1.2.3&#x2F;logback-classic-1.2.3.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]SLF4J: Found binding in [jar:file:&#x2F;Users&#x2F;ypk&#x2F;.m2&#x2F;repository&#x2F;org&#x2F;slf4j&#x2F;slf4j-log4j12&#x2F;1.7.25&#x2F;slf4j-log4j12-1.7.25.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]SLF4J: See http:&#x2F;&#x2F;www.slf4j.org&#x2F;codes.html#multiple_bindings for an explanation.SLF4J: Actual binding is of type [ch.qos.logback.classic.util.ContextSelectorStaticBinder]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-日志重复打印"><a href="#4-2-日志重复打印" class="headerlink" title="4.2 日志重复打印"></a>4.2 日志重复打印</h3><p>有时候我们会发现一行日志被重复打印了多次，这是由于Appender的可叠加性导致的（详见上文），子级和父级Logger同时绑定了Appender；解决办法一般是在子级关闭Appender的可叠加性，以Log4j 2.x的配置为例，指定additivity为false：</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;Configuration status&#x3D;&quot;WARN&quot;&gt;    &lt;Appenders&gt;        &lt;Console name&#x3D;&quot;Console&quot; target&#x3D;&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern&#x3D;&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;&#x2F;&gt;        &lt;&#x2F;Console&gt;    &lt;&#x2F;Appenders&gt;    &lt;Loggers&gt;        &lt;Logger name&#x3D;&quot;com.learn.log4j2.trace&quot; level&#x3D;&quot;trace&quot; additivity&#x3D;&quot;false&quot;&gt;&lt;!-- additivity关闭继承特性 --&gt;            &lt;AppenderRef ref&#x3D;&quot;Console&quot;&#x2F;&gt;        &lt;&#x2F;Logger&gt;        &lt;Root level&#x3D;&quot;info&quot;&gt;            &lt;AppenderRef ref&#x3D;&quot;Console&quot;&#x2F;&gt;        &lt;&#x2F;Root&gt;    &lt;&#x2F;Loggers&gt;&lt;&#x2F;Configuration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-自相矛盾的依赖"><a href="#4-3-自相矛盾的依赖" class="headerlink" title="4.3 自相矛盾的依赖"></a>4.3 自相矛盾的依赖</h3><p>同时指定自相矛盾的 jcl-over-slf4j 和 slf4j-jcl，将会得到下面的异常；解决办法是去掉一种的一个。</p><pre class="line-numbers language-none"><code class="language-none">Caused by: java.lang.IllegalStateException: Detected both jcl-over-slf4j.jar AND bound slf4j-jcl.jar on the class path, preempting StackOverflowError. See also http:&#x2F;&#x2F;www.slf4j.org&#x2F;codes.html#jclDelegationLoop for more details.at org.slf4j.impl.JCLLoggerFactory.&lt;clinit&gt;(JCLLoggerFactory.java:54)... 30 more<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>本文介绍了Java当下流行的Logging Framework，旨在使读者对Java日志框架有一个整体印象。Logger实现一般分为三部分：Logger、Formatter和Handler(又名Appender)，Logger之间存在层级关系。</p><p>在日志框架的具体实现中，可选的有logback和Log4j 2.x；目前选择logback选择的人更多，其与SL4J API无缝集成；Log4j 2.x出现时间较晚，改进了前面的问题并更进一步做了很多特性提升，预期使用的人会越来越多。</p><p>而日志API，SLF4J API使用最为广泛，它不仅解决了通常意义上的日志框架切换问题，还提供了“桥接遗留的API”的功能，使项目内所有的日志输出被统一到了同一个日志实现中。</p><p>最后，我们列出了几个日志配置常见的异常，希望可以帮到读者。</p><h2 id="关于转载"><a href="#关于转载" class="headerlink" title="关于转载"></a>关于转载</h2><p>原创文章，转载请注明出处： <a href='/2018/12/22/java/java-loging-framework/' target='_blank'>http://www.ypk1226.com/2018/12/22/java/java-loging-framework/</a></p><h1 id="参考的文章："><a href="#参考的文章：" class="headerlink" title="参考的文章："></a>参考的文章：</h1><p><a href="https://en.wikipedia.org/wiki/Java_logging_framework">Java logging framework - Wikipedia</a><br><a href="https://logging.apache.org/log4j/1.2/manual.html">Apache log4j 1.2 -Short introduction to log4j</a><br><a href="http://java.sys-con.com/node/48541">Cover Story: Log4j vs java.util.logging</a><br><a href="https://news.ycombinator.com/item?id=7823148">Curious, why Ceki Gülcü (Log4J author) is no longer in team? | Hacker News</a><br><a href="https://www.sitepoint.com/which-java-logging-framework-has-the-best-performance/">Which Java Logging Framework Has the Best Performance?</a><br><a href="https://stackify.com/logging-java/">The State of Logging in Java</a><br><a href="https://www.slf4j.org/legacy.html#jclRecursion">Bridging legacy APIs</a></p>]]></content>
      
      
      <categories>
          
          <category> Logging Framework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> logging </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 自定义Auto-configuration</title>
      <link href="/2018/12/12/spring-boot/spring-boot-auto-configuration-2/"/>
      <url>/2018/12/12/spring-boot/spring-boot-auto-configuration-2/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot的Auto-configuration以其易用性和实用性，得到了开发者们的广泛认可；但与此同时，Spring Boot内置的Auto-configuration仅能满足基本需求，对于企业级的应用生态来说是不够的，所以自定义Auto-configuration变的尤为重要。</p><p>本文将从这几个方面阐述如何自定义一个Auto-configuration： 原理、结构、实战步骤。</p><span id="more"></span><h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h2><p>Spring是如何发现自动配置的内容，并选择性的加载组件呢？</p><p>自动配置功能的实现，得益于<code>spring-context</code>的强扩展性，主要使用了它两个扩展点： <code>@Import</code>和<code>ImportSelector</code>、<code>@Conditional</code>和<code>Condition</code>。</p><ol><li>在<code>@EnableAutoConfiguration</code>内部使用<code>@Import</code>和<code>ImportSelector</code>特性，使配置可以委托到外部来处理。</li><li>在接入点切入后，再使用各种自定义的<code>@Conditional</code>和<code>Condition</code>来筛选预先定义好的自动配置类和相关的Bean。</li></ol><p>简单来讲，Spring Boot的Auto-configuration依靠<code>spring-context</code>中提供已有特性，做了大量的默认配置（通常也是最常见的重复性配置），使开发者的配置方式由“从头开始配置”转变为了“直接使用默认配置或覆盖小部分配置”，着实解放了双手。</p><p>另外，<code>@Import</code>和<code>ImportSelector</code>是在入口处统一处理的，开发者只需要在<code>META-INF/spring.factories</code>中增加一个配置，即可让<code>ImportSelector</code>识别我们自定义的Auto-configuration; 所以，开发一个Auto-configuration，实质上就是基于<code>@Conditional</code>和<code>Condition</code>实现一个<code>@Configuration类</code>。</p><blockquote><p><strong>更详细的原理阐述</strong><br/><br>在笔者的上一篇文章中，曾尝试详细阐述其原理，在此不再赘述，有兴趣的开发者可以点击<a href='/2018/12/05/spring-boot/spring-boot-auto-configuration-1/' target='\_blank'>《Spring Boot Auto-configuration 自动配置详解》</a>查看。</p></blockquote><h2 id="2-结构"><a href="#2-结构" class="headerlink" title="2. 结构"></a>2. 结构</h2><p>想要自定义一个Auto-configuration，首先必须了解其内部结构，知晓哪些部分是开放给开发者实现的。<code>MultipartAutoConfiguration</code>具有自动配置<code>MultipartResolver</code>的功能， 现以<code>MultipartAutoConfiguration</code>为例，分析其类图如下：</p><p><img src="/images/2018/12/uml.png" alt="uml"></p><p>图中红框标识的四部分通常需要定制，以表格的形式展示如下：</p><table><thead><tr><th>序号</th><th>名称</th><th>功能</th></tr></thead><tbody><tr><td>①</td><td><code>@Configuration类</code></td><td>若该配置被开启，指定具体配置的内容。</td></tr><tr><td>②</td><td><code>@Conditional*注解</code></td><td>决定是否开启该配置，将具体决定权委托出去了;Spring Boot已经提供了很多此类注解，如<code>@ConditionalOnClass</code>，如果不够用再考虑新增。</td></tr><tr><td>③</td><td><code>On*Condition类</code></td><td>接受<code>@Conditional*注解</code>的委托，指定如何决定的具体逻辑。</td></tr><tr><td>④</td><td><code>@ConfigurationProperties类</code></td><td>指定该自动配置中可配置的变量（即application.properties&#x2F;application.yml中的变量）。</td></tr></tbody></table><p>下面，我们将详细阐述四个类别的作用和原理。</p><blockquote><p><strong>注意</strong><br/></p><p>另外，除了上述的Java代码之外，还需要配在classpath目录下的<code>META-INF/spring.factories</code>文件中，存在如下配置, Spring Boot启动时将检查文件中是否存在如上配置，若不存在则不加载该自动配置。</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span><span class="token punctuation">=</span><span class="token value attr-value">\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h3 id="2-1-Configuration类"><a href="#2-1-Configuration类" class="headerlink" title="2.1 @Configuration类"></a>2.1 @Configuration类</h3><ol><li><code>@Configuration类</code>类中指定若启用该自动配置后，创建哪些Bean；同时添加@Conditional*和@EnableConfigurationProperties注解，用于限制条件和指定属性。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token class-name">Servlet</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">StandardServletMultipartResolver</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token class-name">MultipartConfigElement</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.servlet.multipart"</span><span class="token punctuation">,</span> name <span class="token operator">=</span> <span class="token string">"enabled"</span><span class="token punctuation">,</span> matchIfMissing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnWebApplication</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">Type</span><span class="token punctuation">.</span><span class="token constant">SERVLET</span><span class="token punctuation">)</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token class-name">MultipartProperties</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MultipartAutoConfiguration</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">MultipartProperties</span> multipartProperties<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">MultipartAutoConfiguration</span><span class="token punctuation">(</span><span class="token class-name">MultipartProperties</span> multipartProperties<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>multipartProperties <span class="token operator">=</span> multipartProperties<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Bean</span><span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token class-name">MultipartConfigElement</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token class-name">CommonsMultipartResolver</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">MultipartConfigElement</span> <span class="token function">multipartConfigElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>multipartProperties<span class="token punctuation">.</span><span class="token function">createMultipartConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token class-name">DispatcherServlet</span><span class="token punctuation">.</span><span class="token constant">MULTIPART_RESOLVER_BEAN_NAME</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span><span class="token class-name">MultipartResolver</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">StandardServletMultipartResolver</span> <span class="token function">multipartResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">StandardServletMultipartResolver</span> multipartResolver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StandardServletMultipartResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>multipartResolver<span class="token punctuation">.</span><span class="token function">setResolveLazily</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>multipartProperties<span class="token punctuation">.</span><span class="token function">isResolveLazily</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> multipartResolver<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-Conditional-注解"><a href="#2-2-Conditional-注解" class="headerlink" title="2.2 @Conditional*注解"></a>2.2 @Conditional*注解</h3><p>指定自动配置需要经过哪些条件的筛选，可以定义多个<code>@Conditional*注解</code>，必须同时满足这些条件，才允许开启自动配置。这类注解的作用，通常是收集参数，再讲决定权委托到<code>@Conditional</code>的value中，如<code>OnClassCondition</code>、<code>OnPropertyCondition</code>等。</p><p>在<code>MultipartAutoConfiguration</code>中使用的<code>@ConditionalOnProperty</code>如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">TYPE</span><span class="token punctuation">,</span> <span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">METHOD</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Conditional</span><span class="token punctuation">(</span><span class="token class-name">OnPropertyCondition</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">ConditionalOnProperty</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">String</span> <span class="token function">prefix</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">String</span> <span class="token function">havingValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> <span class="token function">matchIfMissing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>String Boot已经提供的<code>@Conditional*注解</code>注解如下：</p><p>@ConditionalOnClass ： classpath中存在该类时起效<br>@ConditionalOnMissingClass ： classpath中不存在该类时起效<br>@ConditionalOnBean ： DI容器中存在该类型Bean时起效<br>@ConditionalOnMissingBean ： DI容器中不存在该类型Bean时起效<br>@ConditionalOnSingleCandidate ： DI容器中该类型Bean只有一个或@Primary的只有一个时起效<br>@ConditionalOnExpression ： SpEL表达式结果为true时<br>@ConditionalOnProperty ： 参数设置或者值一致时起效<br>@ConditionalOnResource ： 指定的文件存在时起效<br>@ConditionalOnJndi ： 指定的JNDI存在时起效<br>@ConditionalOnJava ： 指定的Java版本存在时起效<br>@ConditionalOnWebApplication ： Web应用环境下起效<br>@ConditionalOnNotWebApplication ： 非Web应用环境下起效</p><h3 id="2-3-On-Condition类"><a href="#2-3-On-Condition类" class="headerlink" title="2.3 On*Condition类"></a>2.3 On*Condition类</h3><p>与<code>@Conditional*注解</code>是一对一的关系，接受<code>@Conditional*注解</code>的委托，同时获得传递过来的参数，<code>Condition</code>接口实现类根据参数返回一个boolean值，为true代表通过了该条件的校验。</p><p>以<code>OnPropertyCondition</code>为例，其类图如下：<br><img src="/images/2018/12/onpropertycondition.png" alt="OnPropertyCondition"></p><p>其中抽象类<code>SpringBootCondition</code>提供了日志上的优化，提供了合理的日志记录和一致的异常处理。</p><h3 id="2-4-ConfigurationProperties类"><a href="#2-4-ConfigurationProperties类" class="headerlink" title="2.4 @ConfigurationProperties类"></a>2.4 @ConfigurationProperties类</h3><p><code>@ConfigurationProperties类</code>是通过<code>@EnableConfigurationProperties</code>开启的，它声明了一些属性，这些属性都可以在application.properties&#x2F;application.yml进行设置；同时，当前的自动配置也可以获得用户配置的属性值，根据不同的配置做出不同的动作。</p><p><code>MultipartProperties</code>的代码片段如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.servlet.multipart"</span><span class="token punctuation">,</span> ignoreUnknownFields <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MultipartProperties</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> enabled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token class-name">String</span> location<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token class-name">DataSize</span> maxFileSize <span class="token operator">=</span> <span class="token class-name">DataSize</span><span class="token punctuation">.</span><span class="token function">ofMegabytes</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-实战步骤"><a href="#3-实战步骤" class="headerlink" title="3. 实战步骤"></a>3. 实战步骤</h2><p>实现一个自定义自动配置，通常需要考虑这几个问题：</p><ol><li>自动配置到底配置了什么，内容有哪些；</li><li>什么条件下开启自动配置；</li><li>设计支持定制的参数开放给用户；</li><li>确定多个自动配置之间的加载顺序；</li><li>如何使自定义的自动配置被Spring纳入管理范围；</li><li>用户如何确认系统是否开启了该自动配置。</li></ol><p>下面我们将搭配示例代码，对每一个问题进行详细阐述；整个工程代码已经提交到码云，点击<a href='https://gitee.com/ypk1226/custom-sample-spring-boot-auto-configuration' target='\_blank'>示例源码</a>查看；</p><h3 id="3-1-定义自动配置的内容-Configuration类"><a href="#3-1-定义自动配置的内容-Configuration类" class="headerlink" title="3.1 定义自动配置的内容--@Configuration类"></a>3.1 定义自动配置的内容--@Configuration类</h3><p>定义自动配置的内容，即配置一个<code>@Configuration</code>类，在其内部声明想要创建的配置项；声明什么好呢，我们声明个girlfriend吧！</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//省略包</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GirlfriendAutoConfiguration</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">GirlfriendAtHome</span> <span class="token function">girlfriendAtHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">GirlfriendAtHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如此，一个简单的配置类就创建完了，当然目前它还只是个配置，不是自动的。</p><h3 id="3-2-设定开启自动配置的条件-ConditionalOn-注解"><a href="#3-2-设定开启自动配置的条件-ConditionalOn-注解" class="headerlink" title="3.2 设定开启自动配置的条件--@ConditionalOn*注解"></a>3.2 设定开启自动配置的条件--@ConditionalOn*注解</h3><p>给<code>@Configuration</code>类增加<code>@ConditionalOn*</code>注解，设置条件。现在给<code>GirlfriendAutoConfiguration</code>增加条件<code>@ConditionalOnClass</code>和<code>@ConditionalOnMotherInLaw</code>，这样创建<code>GirlfriendAutoConfiguration</code>就多出了两个条件。</p><ol><li><code>@ConditionalOnClass</code> 是Spring Boot内置的注解，用来校验传入的类型在在classpath中是否存在，这里我们传入<code>GirlfriendAtHome.class</code></li><li><code>@ConditionalOnMotherInLaw</code> 是我们自己创建的注解，用来校验岳母的信息，参数中传入心情为HAPPY；同时，为实现这个自定义条件，我们还创建了<code>OnMotherInLawCondition</code>类，该类继承自<code>SpringBootCondition</code>。</li></ol><p>此时代码是这样的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//省略包</span><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">GirlfriendAtHome</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//必须在家</span><span class="token annotation punctuation">@ConditionalOnMotherInLaw</span><span class="token punctuation">(</span>mood <span class="token operator">=</span> <span class="token class-name">MoodConst</span><span class="token punctuation">.</span><span class="token constant">HAPPY</span><span class="token punctuation">)</span><span class="token comment">//必须高兴才加载这个自动配置</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GirlfriendAutoConfiguration</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">GirlfriendAtHome</span> <span class="token function">girlfriendAtHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">GirlfriendAtHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//省略包</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">TYPE</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Conditional</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">OnMotherInLawCondition</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">ConditionalOnMotherInLaw</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> <span class="token function">mood</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//岳母心情</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//省略包</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OnMotherInLawCondition</span> <span class="token keyword">extends</span> <span class="token class-name">SpringBootCondition</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">DEFAULT_MOOD</span> <span class="token operator">=</span> <span class="token class-name">MoodConst</span><span class="token punctuation">.</span><span class="token constant">HAPPY</span><span class="token punctuation">;</span><span class="token comment">//假定一直很开心</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">ConditionOutcome</span> <span class="token function">getMatchOutcome</span><span class="token punctuation">(</span><span class="token class-name">ConditionContext</span> context<span class="token punctuation">,</span> <span class="token class-name">AnnotatedTypeMetadata</span> metadata<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> attributes <span class="token operator">=</span> metadata<span class="token punctuation">.</span><span class="token function">getAnnotationAttributes</span><span class="token punctuation">(</span><span class="token class-name">ConditionalOnMotherInLaw</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> mood <span class="token operator">=</span> attributes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"mood"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> match <span class="token operator">=</span> <span class="token constant">DEFAULT_MOOD</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>mood<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> message <span class="token operator">=</span> match <span class="token operator">?</span> <span class="token string">"心情匹配"</span> <span class="token operator">:</span> <span class="token string">"心情不匹配"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConditionOutcome</span><span class="token punctuation">(</span>match<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，这个普通的<code>@Configuration</code>类拥有了两个限制条件，只有在两个条件都成立时才会被创建。</p><h3 id="3-3-设计支持定制的参数-EnableConfigurationProperties"><a href="#3-3-设计支持定制的参数-EnableConfigurationProperties" class="headerlink" title="3.3 设计支持定制的参数--@EnableConfigurationProperties"></a>3.3 设计支持定制的参数--@EnableConfigurationProperties</h3><p>有时候，girlfriend的心情会发生变化，所以我们也要支持用户在application.properties&#x2F;application.yaml中定制心情，<code>@EnableConfigurationProperties</code>注解专门用来完成配置项的创建。</p><p>为<code>GirlfriendAutoConfiguration</code>增加注解<code>@EnableConfigurationProperties</code>，同时指定具体的配置实现类<code>GirlfriendProperties</code>，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//省略包</span><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">GirlfriendAtHome</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//必须在家</span><span class="token annotation punctuation">@ConditionalOnMotherInLaw</span><span class="token punctuation">(</span>mood <span class="token operator">=</span> <span class="token class-name">MoodConst</span><span class="token punctuation">.</span><span class="token constant">HAPPY</span><span class="token punctuation">)</span><span class="token comment">//必须高兴才加载这个自动配置</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token class-name">GirlfriendProperties</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GirlfriendAutoConfiguration</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">GirlfriendProperties</span> properties<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">public</span> <span class="token class-name">GirlfriendAutoConfiguration</span><span class="token punctuation">(</span><span class="token class-name">GirlfriendProperties</span> properties<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>properties <span class="token operator">=</span> properties<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">GirlfriendAtHome</span> <span class="token function">girlfriendAtHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> mood <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getMood</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mood <span class="token operator">=</span> mood <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token string">"未知"</span> <span class="token operator">:</span> mood<span class="token punctuation">;</span>        <span class="token class-name">GirlfriendAtHome</span> girlfriendAtHome <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GirlfriendAtHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        girlfriendAtHome<span class="token punctuation">.</span><span class="token function">setMood</span><span class="token punctuation">(</span>mood<span class="token punctuation">)</span><span class="token punctuation">;</span>        girlfriendAtHome<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"甄姬"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        girlfriendAtHome<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token string">"18"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> girlfriendAtHome<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//省略包</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span><span class="token string">"third.party.girlfriend"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GirlfriendProperties</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> mood<span class="token punctuation">;</span><span class="token comment">//心情</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getMood</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> mood<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMood</span><span class="token punctuation">(</span><span class="token class-name">String</span> mood<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mood <span class="token operator">=</span> mood<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，我们就可以在application.properties&#x2F;application.yaml中指定girlfriend的心情了：third.party.girlfriend.mood&#x3D;happy</p><h3 id="3-4-确定加载顺序"><a href="#3-4-确定加载顺序" class="headerlink" title="3.4 确定加载顺序"></a>3.4 确定加载顺序</h3><p>Spring Boot为开发者提供了几个注解，专门用于指定自动配置的先后顺序，这些注解使用时注解在<code>@Configuration</code>类上即可。</p><p><code>@AutoConfigureAfter</code>：在指定的配置类初始化后再加载, 如@AutoConfigureAfter(JacksonAutoConfiguration.class)<br><code>@AutoConfigureBefore</code>：在指定的配置类初始化前加载, 如@AutoConfigureBefore(JacksonAutoConfiguration.class)<br><code>@AutoConfigureOrder</code>：数越小越先初始化， 如@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</p><p>我们为<code>GirlfriendAutoConfiguration</code>增加<code>@AutoConfigureOrder</code>，使其优先级最高^_^。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//省略包</span><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">GirlfriendAtHome</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnMotherInLaw</span><span class="token punctuation">(</span>mood <span class="token operator">=</span> <span class="token class-name">MoodConst</span><span class="token punctuation">.</span><span class="token constant">HAPPY</span><span class="token punctuation">)</span><span class="token comment">//必须高兴才加载这个自动配置</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token class-name">GirlfriendProperties</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@AutoConfigureOrder</span><span class="token punctuation">(</span><span class="token class-name">Ordered</span><span class="token punctuation">.</span><span class="token constant">HIGHEST_PRECEDENCE</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GirlfriendAutoConfiguration</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//省略</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-使自定义的自动配置被Spring纳入管理范围–META-INF-spring-factories"><a href="#3-5-使自定义的自动配置被Spring纳入管理范围–META-INF-spring-factories" class="headerlink" title="3.5 使自定义的自动配置被Spring纳入管理范围–META-INF&#x2F;spring.factories"></a>3.5 使自定义的自动配置被Spring纳入管理范围–META-INF&#x2F;spring.factories</h3><p>现在万事具备，只欠东风，Spring Boot在<code>META-INF/spring.factories</code>中设置有总开关，必须开启开行。增加如下配置</p><pre class="line-numbers language-none"><code class="language-none">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\com.example.learn.girlfriend.spring.boot.autoconfigure.GirlfriendAutoConfiguration<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-6-用户如何确认系统是否开启了该自动配置–使用-Ddebug参数启动"><a href="#3-6-用户如何确认系统是否开启了该自动配置–使用-Ddebug参数启动" class="headerlink" title="3.6 用户如何确认系统是否开启了该自动配置–使用-Ddebug参数启动"></a>3.6 用户如何确认系统是否开启了该自动配置–使用-Ddebug参数启动</h3><p>启动服务时，增加VM参数-Ddebug，就能看到我们的girlfriend是否正常加载了：<br><img src="/images/2018/12/auto-configuration-result-check.png" alt="auto-configuration-result-check"></p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>本文从这几个方面阐述如何自定义一个Auto-configuration： 原理、结构、实战步骤；在理解内部原理和结构之后，再实现了一个简单的自动配置。</p><p>原理：基于Spring Framework的扩展机制<code>@Import</code>和<code>ImportSelector</code>、<code>@Conditional</code>和<code>Condition</code>，实现自动配置功能。</p><p>结构：大体上由这几部分构成<code>@Configuration类</code>、<code>@Conditional*注解</code>、<code>On*Condition类</code>、 <code>@ConfigurationProperties类</code>。</p><p>实战步骤中的各个操作，基本上就是创建上述结构中的各个部分内容，<a href='https://gitee.com/ypk1226/custom-sample-spring-boot-auto-configuration' target='\_blank'>示例源码</a>已提交码云，可下载查阅。</p><p>参考：<br><a href="https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/#boot-features-developing-auto-configuration">Spring Boot Reference Guide</a><br><a href="https://github.com/snicoll-demos/spring-boot-master-auto-configuration">demo project</a></p>]]></content>
      
      
      <categories>
          
          <category> spring-boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> spring-boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Auto-configuration 自动配置详解</title>
      <link href="/2018/12/05/spring-boot/spring-boot-auto-configuration-1/"/>
      <url>/2018/12/05/spring-boot/spring-boot-auto-configuration-1/</url>
      
        <content type="html"><![CDATA[<p>毋庸置疑，Auto-configuration是Spring Boot的核心特性，其约定大于配置的思想，赋予了Spring Boot开箱即用的强大能力。本文从诞生背景、使用方式、实现原理这几个方面详细介绍这一特性。</p><span id="more"></span><h2 id="1-诞生背景"><a href="#1-诞生背景" class="headerlink" title="1. 诞生背景"></a>1. 诞生背景</h2><p>一直以来，应用程序模块之间的依赖及相应的配置管理，都是件繁琐的事情；maven和gradle的出现，基本解决了<strong>依赖管理</strong>，使依赖管理变得优雅起来。但与之相对的，繁琐的<strong>配置工作</strong>仍然让开发者头疼不已，我们来看一段Spring集成Hibernate的配置代码：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.commons.dbcp.BasicDataSource<span class="token punctuation">"</span></span> <span class="token attr-name">destroy-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>close<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>driverClassName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.mysql.jdbc.Driver<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jdbc:mysql://localhost/test<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>123456<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sessionFactory<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.orm.hibernate4.LocalSessionFactoryBean<span class="token punctuation">"</span></span> <span class="token attr-name">lazy-init</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 注入datasource，给sessionfactoryBean内setdatasource提供数据源 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>configLocation<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>classpath:hibernate.cfg.xml<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- //加载实体类的映射文件位置及名称 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mappingLocations<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>classpath:com/demo/entities/*.hbm.xml<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 配置Spring声明式事务 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>transactionManager<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.orm.hibernate4.HibernateTransactionManager<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sessionFactory<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sessionFactory<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些代码很多开发者已经非常熟悉了，但是每次创建新项目，总是要带着它们（即使使用Java Config的形式，这些bean的也需要一个个声明出来）。有鉴于此，Spring团队提出了Auto-configuration机制，力图解决重复、复杂的配置问题。</p><h2 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h2><p>顾名思义，Spring Boot Auto-configuration尝试根据项目的jar依赖关系，自动配置Spring应用程序。</p><p>例如，如果HSQLDB在项目的classpath中，并且没有手动配置任何数据库链接相关的Bean，那么Spring Boot将自动配置一个的内存数据库。通过这种方式，大大减轻了配置的工作量，开发者通常只需要调整部分配置即可。为帮助理解，HSQLDB自动配置的流程如下：</p><p><img src="/images/2018/12/auto.png" alt="auto"></p><h2 id="3-使用方式"><a href="#3-使用方式" class="headerlink" title="3. 使用方式"></a>3. 使用方式</h2><p>笔者按照如下两个维度介绍使用方式，以求尽可能清晰明了:</p><ol><li>按具体配置方式分类</li><li>按操作目的分类</li></ol><h3 id="3-1-按具体配置方式分类"><a href="#3-1-按具体配置方式分类" class="headerlink" title="3.1 按具体配置方式分类"></a>3.1 按具体配置方式分类</h3><p>按照具体配置方式分类，入口有这几种：相关注解、spring.factories、application.properties&#x2F;application.yml。</p><h4 id="3-1-1-相关注解"><a href="#3-1-1-相关注解" class="headerlink" title="3.1.1 相关注解"></a>3.1.1 相关注解</h4><p>@EnableAutoConfiguration和@SpringBootApplication都有开启Spring Boot Auto-configuration能力。除了这两个注解之外，Spring Boot Auto-configuration没有其它面向用户的注解了。</p><blockquote><p><strong>@SpringBootApplication vs @EnableAutoConfiguration</strong><br/><br>@SpringBootApplication的作用等同于一起使用这三个注解：@Configuration、@EnableAutoConfiguration、和@ComponentScan</p></blockquote><h4 id="3-1-2-spring-factories文件"><a href="#3-1-2-spring-factories文件" class="headerlink" title="3.1.2 spring.factories文件"></a>3.1.2 spring.factories文件</h4><p>spring.factories文件指定了*AutoConfiguration类列表，只有在列表中的自动配置才会被检索到。Spring会检测classpath下所有的META-INF&#x2F;spring.factories文件；若要引入自定义的自动配置，需要将自定义的*AutoConfiguration类添加到spring.factories文件中。</p><p>另外，该文件不是Spring Boot新增的特性，而是spring-core包中的SpringFactoriesLoader类负责检索并解析META-INF&#x2F;spring.factories文件</p><h4 id="3-1-3-application-properties-application-yml"><a href="#3-1-3-application-properties-application-yml" class="headerlink" title="3.1.3 application.properties&#x2F;application.yml"></a>3.1.3 application.properties&#x2F;application.yml</h4><p>Spring会检测classpath中是否存在这application.properties或application.yml，若存在将获取其中配置作用到Auto-configuration上，覆盖默认配置。</p><p>点击<a href="https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/#appendix">properties列表</a>可以查看所有Spring Boot内置的属性配置示例。</p><h3 id="3-2-按操作目的分类"><a href="#3-2-按操作目的分类" class="headerlink" title="3.2 按操作目的分类"></a>3.2 按操作目的分类</h3><p>按照操作目的划分，通常有这几种：定制部分配置、排除、全局开启&#x2F;关闭、新增(相对复杂一些，会在另外一篇文章中单独介绍)。</p><h4 id="3-2-1-定制部分配置"><a href="#3-2-1-定制部分配置" class="headerlink" title="3.2.1 定制部分配置"></a>3.2.1 定制部分配置</h4><p>自动配置开启后，特定组件的配置变量名称是固定的（即做好了“约定”），将特定配置写入application.properties或application.yml即可覆盖已有配置。</p><p>以DataSourceAutoConfiguration为例，常用的配置为：</p><pre class="line-numbers language-none"><code class="language-none">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test？characterEncoding&#x3D;utf8&amp;useSSL&#x3D;truespring.datasource.username&#x3D;rootspring.datasource.password&#x3D;1234spring.datasource.driver-class-name&#x3D;com.mysql.jdbc.Driver<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-2-排除"><a href="#3-2-2-排除" class="headerlink" title="3.2.2 排除"></a>3.2.2 排除</h4><p>分为两种排除方式：自动排除特定Bean、手动排除指定的AutoConfiguration。</p><p><strong>自动排除特定Bean</strong></p><p>当开发者在项目中手动声明了某个组件的特定类，Spring Boot Auto-configuration通过@Condition机制实现了自动避让；即Spring探测到用户自己手动声明了某些特定类后，对应的Auto-configuration就不再加载了。</p><blockquote><p><strong>如何查看所谓“特定类”</strong><br/><br>AutoConfiguration类中，被@ConditionalOnMissingBean或@ConditionalOnMissingClass的value值，例如org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration：<br><img src="/images/2018/12/jdbc.png" alt="jdbc"></p></blockquote><p><strong>手动排除指定的AutoConfiguration</strong></p><p>使用@SpringBootApplication或@EnableAutoConfiguration中的exclude和excludeName属性可以排除指定的AutoConfiguration，属性值通常是以*AutoConfiguration结尾的类。</p><p>另外，在application.properties或application.yml中使用spring.autoconfigure.exclude也可以排除指定的AutoConfiguration。</p><p>示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token punctuation">(</span>exclude <span class="token operator">=</span> <span class="token class-name">FreeMarkerAutoConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">EnableAutoConfigurationWithClassExclusions</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token punctuation">(</span>excludeName <span class="token operator">=</span> <span class="token string">"org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">EnableAutoConfigurationWithClassNameExclusions</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token punctuation">(</span>exclude <span class="token operator">=</span> <span class="token class-name">MustacheAutoConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> excludeName <span class="token operator">=</span> <span class="token string">"org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">EnableAutoConfigurationWithClassAndClassNameExclusions</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">spring.autoconfigure.exclude&#x3D;org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>如何找到可选的*AutoConfiguration</strong><br/><br>方法1：添加启动参数-Ddebug，在日志中可以看到已经加载的<em>AutoConfiguration<br>方法2：spring-boot-autoconfigure包中存在<a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories">spring.factories</a>文件，文件中org.springframework.boot.autoconfigure.EnableAutoConfiguration变量的值中，列出了所有Spring Boot内置的</em>AutoConfiguration类</p></blockquote><h4 id="3-2-3-全局开启-关闭自动配置"><a href="#3-2-3-全局开启-关闭自动配置" class="headerlink" title="3.2.3 全局开启&#x2F;关闭自动配置"></a>3.2.3 全局开启&#x2F;关闭自动配置</h4><p>全局开启：添加@SpringBootApplication或@EnableAutoConfiguration到配置类上，且spring.boot.enableautoconfiguration属性设置为true（默认为true）。</p><p>全局关闭：不使用@SpringBootApplication或@EnableAutoConfiguration，或spring.boot.enableautoconfiguration属性设置为false。</p><h2 id="4-实现原理"><a href="#4-实现原理" class="headerlink" title="4. 实现原理"></a>4. 实现原理</h2><p>得益于spring-context中的扩展机制@Import(ImportSelector)和@Conditional(Condition)，Spring Boot Auto-configuration自然地扩展选择器和过滤器，从而筛选出符合条件的配置组件。下面分两部分介绍其原理：Spring Framework的扩展点、调用流程。</p><h3 id="4-1-Spring-Framework的扩展点"><a href="#4-1-Spring-Framework的扩展点" class="headerlink" title="4.1 Spring Framework的扩展点"></a>4.1 Spring Framework的扩展点</h3><p>@Import(ImportSelector)的使用，使配置可以委托到外部来处理，为Auto-configuration提供了的接入点。在接入点切入后，再使用各种自定义的@Conditional(Condition)筛选预先定义好的自动配置类和相关的Bean。</p><p>可以说，@Conditional(Condition)是Spring Boot实现自动配置的关键。</p><blockquote><p><strong>@Import</strong><br/><br>@Import是Spring 3.0提供在spring-context中的注解，提供与Spring XML中的<import/>元素等效的功能。允许导入@Configuration类、ImportSelector实现、ImportBeanDefinitionRegistrar实现，以及常规的@Component类。</p></blockquote><blockquote><p><strong>ImportSelector接口</strong><br/><br>ImportSelector接口是Spring 3.1提供在spring-context中的接口。<br>接口方法：String[]selectImports(AnnotationMetadata importingClassMetadata)<br>提供根据传入的@Import类的元数据，返回需要加载的@Configuration类。</p></blockquote><blockquote><p><strong>@Conditional</strong><br/><br>@Conditional是Spring 4.0提供在spring-context中的注解。<br>代表component只有在所有指定条件匹配时才有会被注册，允许指定一个Condition的实现类，以定义匹配规则。</p></blockquote><blockquote><p><strong>Condition接口</strong><br/><br>Condition接口是Spring 4.0提供在spring-context中的接口。<br>接口方法：booleanmatches(ConditionContext context, AnnotatedTypeMetadata metadata)<br>根据传入的@Conditional类的元数据，返回是否加载该类。</p></blockquote><h3 id="4-2-调用流程"><a href="#4-2-调用流程" class="headerlink" title="4.2 调用流程"></a>4.2 调用流程</h3><p>下图描述了Spring Boot Auto-configuration启动加载的基本流程。</p><p><img src="/images/2018/12/flow.jpg" alt="flow"></p><ol><li>调用SpringApplication#run，开始启动</li><li>调用AbstractApplicationContext#refresh，进入容器启动的生命周期</li><li>进入BeanFactoryPostProcessors</li><li>解析@Import获得AutoConfigurationImportSelector类，该类是自动配置的核心，对配置列表的筛选、排序等操作在这里完成；同时该类实现了DeferredImportSelector接口，它时延迟执行的</li><li>在需要的时候，读取META-INF&#x2F;spring.factories文件中配置的AutoConfigurationImportFilter列表、EnableAutoConfiguration列表、AutoConfigurationImportListener列表</li><li>根据用户注解中的exclue配置，排除指定的AutoConfiguration</li><li>调用AutoConfigurationImportFilter#match，以spring.factories文件中的EnableAutoConfiguration列表作为参数，进行筛选</li><li>对自动配置结果进行排序</li><li>根据@Condition类的条件对Bean进行筛选</li><li>启动完成</li></ol><blockquote><p>AutoConfigurationImportFilter<br>只有实现了该接口的Condition，才会在AutoConfigurationImportSelector被调用，Spring默认只配置了三个：OnBeanCondition、OnClassCondition、OnWebApplicationCondition</p></blockquote><blockquote><p>@Condition类<br>@Condition注解是spring-context的扩展，@Condition类的实现其实是在离开spring-boot-autoconfigure之后，在spring-context中调用的</p></blockquote><blockquote><p>注意<br>本文的代码分析，基于Spring Boot 2.1.2.BUILD-SNAPSHOT</p></blockquote><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>自动配置特性使开发者节省了很多配置工作量，从重复繁琐的配置中解脱了出来。本文从诞生背景、使用方式、实现原理这几个方面详细介绍了Auto-configuration这一特性。<br>它的核心配置方式有三个：相关注解、spring.factories、application.properties&#x2F;application.yml。<br>原理上，得益于Spring Framework强大的扩展能力，使用@Import(ImportSelector)和@Conditional(Condition)后，Spring Boot优雅地实现了自动配置特性。</p>]]></content>
      
      
      <categories>
          
          <category> spring-boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> spring-boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Staters 详解</title>
      <link href="/2018/11/29/spring-boot/spring-boot-staters/"/>
      <url>/2018/11/29/spring-boot/spring-boot-staters/</url>
      
        <content type="html"><![CDATA[<p>Maven和Gradle为Java开发者解决了依赖管理的心头大患，已然成为事实上的依赖管理标准。但贪心的开发者还想更“懒”，有没有办法使依赖管理更简单、更快捷？</p><p>答案是肯定的，Spring Boot项目中引入了Starter的概念。</p><span id="more"></span><h2 id="1-诞生背景"><a href="#1-诞生背景" class="headerlink" title="1. 诞生背景"></a>1. 诞生背景</h2><p>以往开发者想要集成第三方组件，通常需要将对应的依赖添加进pom，然后进行相应集成配置工作。以jackson为例，需要的dependency有4个之多，如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-databind<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.9.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.datatype<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-datatype-jdk8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.9.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.datatype<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-datatype-jsr310<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.9.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.module<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-module-parameter-names<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.9.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常这些组件需要的依赖和配置差别不大，但每次使用都要做一遍，这对于“懒惰的”开发者门，实在非常不友好。于是Spring团队在分析总结常用的组件模型后，提出了Starter这个概念用以打包这些依赖和配置，从而达到了第三方组件的一站式集成的目的。</p><h2 id="2-Stater是什么"><a href="#2-Stater是什么" class="headerlink" title="2. Stater是什么"></a>2. Stater是什么</h2><p>Stater是一组依赖描述符，使开发者可以一站式依赖一些组件（包括默认配置），而不必根据这些组件的示例拷贝粘贴相关依赖配置。换言之，Starter就是Maven的一个artifact，它包含两部分内容：</p><p>1、聚合多个dependency，使依赖更方便<br>2、增加Auto-configuration特性，提供组件的默认配置，达到开箱即用的目的</p><p>现在以spring-boot-starter-web为例，其将web应用需要的包都加载进classpath，同时依赖spring-boot-starter开启了Auto-configuration，结构如下图：</p><p><img src="/images/2018/11/starter-web-case.png" alt="starter-web-case"></p><p><strong>封装为Stater后的优点</strong></p><p>1、使用Starter使依赖变得简单<br>2、在pom的parent约定好了版本，使开发者免除版本冲突的困扰<br>3、与另外一个特性Auto-configuration完美搭配，减少配置困扰</p><blockquote><h5 id="与Auto-configuration的关系"><a href="#与Auto-configuration的关系" class="headerlink" title="与Auto-configuration的关系"></a>与Auto-configuration的关系</h5><p>所有的Starters都必须依赖一个Auto-configuration，且Auto-configuration只应提供配置相关的内容，不应管理依赖。<br>Starter和Auto-configuration和配合使用后，应用程序有了一丝智能的感觉，具体情况将在另外一篇文章中详细介绍。</p></blockquote><blockquote><h5 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h5><p>观察发现所有的依赖都没有version，这些版本号都继承了spring-boot-dependencies，在其中统一管理。<br>不止Starter，所有其它的Spring Boot模块都继承了spring-boot-dependencies</p></blockquote><blockquote><h5 id="已提供的Starters"><a href="#已提供的Starters" class="headerlink" title="已提供的Starters"></a>已提供的Starters</h5><ol><li><a href="https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/#using-boot-starter">官网内置的Staters</a></li><li><a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-starters/README.adoc">社区贡献的Staters</a><br>在文章最后将官网的Starters复制了出来，以供参考。</li></ol></blockquote><h2 id="3-自定义Starter"><a href="#3-自定义Starter" class="headerlink" title="3. 自定义Starter"></a>3. 自定义Starter</h2><p>构建一个自定义Starter，需要完成两个必要条件：聚合多个dependency、增加Auto-configuration特性。本文只介绍聚合多个dependency，至于Auto-configuration将在另外一篇文章中详细介绍。</p><p><strong>聚合多个dependency</strong></p><p>定义一个pom.xml文件，在其中依赖该模块需要的所有的依赖（包含Auto-configuration的依赖）。下图是Spring Boot中定义的Starter结构：</p><p><img src="/images/2018/11/starter-case-png.png" alt="starter-case.png"></p><p>这些pom.xml运行install后产生一个空jar，这样使Stater和Auto-configuration分离。</p><p>如果不太关注分离这两点，两者确实可以放在一起，例如Apache Wicket实现的<a href="https://github.com/MarcGiffing/wicket-spring-boot/blob/master/wicket-spring-boot-starter/pom.xml">wicket-spring-boot-starter</a>，可以发现它不像官方的Starter一样内部只有一个pom文件，而是将Auto-configuration相关的代码也放了进去。</p><blockquote><p><strong>命名规范</strong><br>官方提供的Starters命名格式为：spring-boot-starter-*<br>官方文档建议自定义Starter时命名为：*-spring-boot-starter，例如thirdpartyproject-spring-boot-starter，不建议以spring-boot开头。</p></blockquote><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>本文主要介绍了Spring Boot Starter的定义及其内部构成，最后又说明了如何创建自定义的Starter。</p><p>Starter中的两个重要部分：聚合到Stater中的多个dependency、Auto-configuration特性。其中多个dependency往往根据业务场景或功能模块划分边界，而Auto-configuration为这些模块提供自动配置的特性。</p><h2 id="附录-官网Starter列表"><a href="#附录-官网Starter列表" class="headerlink" title="附录 官网Starter列表"></a>附录 官网Starter列表</h2><h3 id="应用程序starters"><a href="#应用程序starters" class="headerlink" title="应用程序starters"></a>应用程序starters</h3><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>spring-boot-starter</td><td>核心Spring Boot starter，包括自动配置支持，日志和YAML</td></tr><tr><td>spring-boot-starter-actuator</td><td>生产准备的特性，用于帮我们监控和管理应用</td></tr><tr><td>spring-boot-starter-amqp</td><td>对”高级消息队列协议”的支持，通过spring-rabbit实现</td></tr><tr><td>spring-boot-starter-aop</td><td>对面向切面编程的支持，包括spring-aop和AspectJ</td></tr><tr><td>spring-boot-starter-batch</td><td>对Spring Batch的支持，包括HSQLDB数据库</td></tr><tr><td>spring-boot-starter-cloud-connectors</td><td>对Spring Cloud Connectors的支持，简化在云平台下（例如，Cloud Foundry 和Heroku）服务的连接</td></tr><tr><td>spring-boot-starter-data-elasticsearch</td><td>对Elasticsearch搜索和分析引擎的支持，包括spring-data-elasticsearch</td></tr><tr><td>spring-boot-starter-data-gemfire</td><td>对GemFire分布式数据存储的支持，包括spring-data-gemfire</td></tr><tr><td>spring-boot-starter-data-jpa</td><td>对”Java持久化API”的支持，包括spring-data-jpa，spring-orm和Hibernate</td></tr><tr><td>spring-boot-starter-data-mongodb</td><td>对MongoDB NOSQL数据库的支持，包括spring-data-mongodb</td></tr><tr><td>spring-boot-starter-data-rest</td><td>对通过REST暴露Spring Data仓库的支持，通过spring-data-rest-webmvc实现</td></tr><tr><td>spring-boot-starter-data-solr</td><td>对Apache Solr搜索平台的支持，包括spring-data-solr</td></tr><tr><td>spring-boot-starter-freemarker</td><td>对FreeMarker模板引擎的支持</td></tr><tr><td>spring-boot-starter-groovy-templates</td><td>对Groovy模板引擎的支持</td></tr><tr><td>spring-boot-starter-hateoas</td><td>对基于HATEOAS的RESTful服务的支持，通过spring-hateoas实现</td></tr><tr><td>spring-boot-starter-hornetq</td><td>对”Java消息服务API”的支持，通过HornetQ实现</td></tr><tr><td>spring-boot-starter-integration</td><td>对普通spring-integration模块的支持</td></tr><tr><td>spring-boot-starter-jdbc</td><td>对JDBC数据库的支持</td></tr><tr><td>spring-boot-starter-jersey</td><td>对Jersey RESTful Web服务框架的支持</td></tr><tr><td>spring-boot-starter-jta-atomikos</td><td>对JTA分布式事务的支持，通过Atomikos实现</td></tr><tr><td>spring-boot-starter-jta-bitronix</td><td>对JTA分布式事务的支持，通过Bitronix实现</td></tr><tr><td>spring-boot-starter-mail</td><td>对javax.mail的支持</td></tr><tr><td>spring-boot-starter-mobile</td><td>对spring-mobile的支持</td></tr><tr><td>spring-boot-starter-mustache</td><td>对Mustache模板引擎的支持</td></tr><tr><td>spring-boot-starter-redis</td><td>对REDIS键值数据存储的支持，包括spring-redis</td></tr><tr><td>spring-boot-starter-security</td><td>对spring-security的支持</td></tr><tr><td>spring-boot-starter-social-facebook</td><td>对spring-social-facebook的支持</td></tr><tr><td>spring-boot-starter-social-linkedin</td><td>对spring-social-linkedin的支持</td></tr><tr><td>spring-boot-starter-social-twitter</td><td>对spring-social-twitter的支持</td></tr><tr><td>spring-boot-starter-test</td><td>对常用测试依赖的支持，包括JUnit, Hamcrest和Mockito，还有spring-test模块</td></tr><tr><td>spring-boot-starter-thymeleaf</td><td>对Thymeleaf模板引擎的支持，包括和Spring的集成</td></tr><tr><td>spring-boot-starter-velocity</td><td>对Velocity模板引擎的支持</td></tr><tr><td>spring-boot-starter-web</td><td>对全栈web开发的支持， 包括Tomcat和spring-webmvc</td></tr><tr><td>spring-boot-starter-websocket</td><td>对WebSocket开发的支持</td></tr><tr><td>spring-boot-starter-ws</td><td>对Spring Web服务的支持</td></tr></tbody></table><h3 id="Spring-Boot生产准备的starters"><a href="#Spring-Boot生产准备的starters" class="headerlink" title="Spring Boot生产准备的starters"></a>Spring Boot生产准备的starters</h3><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>spring-boot-starter-actuator</td><td>添加生产准备特性，比如指标和监控</td></tr><tr><td>spring-boot-starter-remote-shell</td><td>添加远程ssh shell支持</td></tr></tbody></table><h3 id="排除或交换具体技术方面的starters"><a href="#排除或交换具体技术方面的starters" class="headerlink" title="排除或交换具体技术方面的starters"></a>排除或交换具体技术方面的starters</h3><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>spring-boot-starter-jetty</td><td>导入Jetty HTTP引擎（作为Tomcat的替代）</td></tr><tr><td>spring-boot-starter-log4j</td><td>对Log4J日志系统的支持</td></tr><tr><td>spring-boot-starter-logging</td><td>导入Spring Boot的默认日志系统</td></tr><tr><td>spring-boot-starter-tomcat</td><td>导入Spring Boot的默认HTTP引擎</td></tr><tr><td>spring-boot-starter-undertow</td><td>导入Undertow HTTP引擎（作为Tomcat的替代）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> spring-boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> spring-boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 入门介绍</title>
      <link href="/2018/11/27/spring-boot/spring-boot-index/"/>
      <url>/2018/11/27/spring-boot/spring-boot-index/</url>
      
        <content type="html"><![CDATA[<p>一个完善的应用程序，常常需要这些特性：精简明确的配置，快速集成第三方组件，统一的打包部署方式，方便单元测试&#x2F;功能测试，良好的监控能力等。Spring Boot出现之前，这些都需要开发者自行摸索解决，得到的方案可能大同小异，在尝到“约定大于配置”的好处后，人们自然不甘于此，于是Spring Boot应运而生。</p><span id="more"></span><h2 id="1-Spring-Boot是什么"><a href="#1-Spring-Boot是什么" class="headerlink" title="1. Spring Boot是什么"></a>1. Spring Boot是什么</h2><p>Spring Boot的设计目的是用来简化新Spring应用的初始搭建以及开发过程，快速创建生产级的基于Spring的应用程序，达到开箱即用的效果。它具有以下主要特性：</p><ol><li>为所有Spring开发提供一个更快、更广泛的入门体验。</li><li>开箱即用，Spring Boot拥有合理的默认值，同时又能快速响应需求的变化。</li><li>提供对大型项目(如嵌入式服务器、安全性、指标监控、健康检查和外部化配置)常见的一系列非功能性特性。</li><li>绝对没有代码生成，也不需要XML配置</li></ol><h2 id="2-Spring-Boot提供的功能"><a href="#2-Spring-Boot提供的功能" class="headerlink" title="2. Spring Boot提供的功能"></a>2. Spring Boot提供的功能</h2><p>在<a href="https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/">官方文档</a>的基础上，笔者以表格的形式罗列Spring Boot下的所有module，使读者对其有一个完整印象。</p><blockquote><p>自上而下的全局印象，往往比细节更为重要。当然，具体的细节讨论及使用，后续的文章中也会逐一分析。</p></blockquote><table><thead><tr><th>module</th><th>说明</th><th>重要程度</th></tr></thead><tbody><tr><td>spring-boot</td><td>核心库，提供基础功能</td><td>⭐️ ⭐️ ⭐️ ⭐️ ⭐️</td></tr><tr><td>spring-boot-autoconfigure 和 spring-boot-starters</td><td>使用autoconfigure提供自动配置功能；使用Starter达到快速集成的目的</td><td>⭐️ ⭐️ ⭐️ ⭐️ ⭐️</td></tr><tr><td>spring-boot-actuator 和 spring-boot-actuator-autoconfigure</td><td>生产级的非功能性特性，一些监控、健康检查等功能</td><td>⭐️ ⭐️ ⭐️ ⭐️ ⭐️</td></tr><tr><td>spring-boot-test 和 spring-boot-test-autoconfigure</td><td>基于spring boot的测试支持</td><td>⭐️ ⭐️ ⭐️ ⭐️</td></tr><tr><td>spring-boot-parent 和 spring-boot-dependencies</td><td>是所有其他module的父节点，使依赖版本在同一位置管理</td><td>⭐️ ⭐️ ⭐️ ⭐️</td></tr><tr><td>spring-boot-devtools</td><td>开发者工具集，包含自动重启、浏览器自动刷新、远程调试等功能</td><td>⭐️ ⭐️ ⭐️</td></tr><tr><td>spring-boot-tools</td><td>maven&#x2F;gradle插件、可执行jar等功能</td><td>⭐️ ⭐️ ⭐️</td></tr><tr><td>spring-boot-cli</td><td>提供一套命令行工具</td><td>⭐️ ⭐️</td></tr><tr><td>spring-boot-properties-migrator</td><td>帮助开发者从低版本升级到Spring Boot 2.0</td><td>⭐️</td></tr><tr><td>spring-boot-docs</td><td>指定java doc的内容及样式</td><td>⭐️</td></tr></tbody></table><h2 id="3-Spring-Boot与Spring其它project的对比"><a href="#3-Spring-Boot与Spring其它project的对比" class="headerlink" title="3. Spring Boot与Spring其它project的对比"></a>3. Spring Boot与Spring其它project的对比</h2><p>Spring的生态比较庞大，点击<a href="https://spring.io/projects">官网项目列表</a>可以查看这些项目（主要项目甚至还都设计了一个logo ^_^）。一些初学者可能会有一些概念上的混淆，在此做一些简单的比较。</p><h3 id="3-1-Spring-Boot-vs-Spring-Cloud"><a href="#3-1-Spring-Boot-vs-Spring-Cloud" class="headerlink" title="3.1 Spring Boot vs Spring Cloud"></a>3.1 Spring Boot vs Spring Cloud</h3><p>Spring Cloud是一个基于Spring Boot实现的一系列框架的有序集合，是一个关注全局的服务治理框架。</p><p>Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。</p><p>下图是官网截取的，以帮助理解：</p><p><img src="/images/2018/11/spring-cloud-png.png" alt="spring-cloud.png"></p><h3 id="3-2-Spring-Boot-vs-Spring-Framework"><a href="#3-2-Spring-Boot-vs-Spring-Framework" class="headerlink" title="3.2 Spring Boot vs Spring Framework"></a>3.2 Spring Boot vs Spring Framework</h3><p>Spring Framework是一个轻量级、非侵入式、一站式、模块化的开发应用框架。Spring Boot基于Spring Framework开发，不能单独存在。</p><p>下图是官网截取的，以帮助理解：</p><p><img src="/images/2018/11/spring-frame-png.png" alt="spring-frame.png"></p><h3 id="3-3-Spring-Boot-vs-Spring-MVC"><a href="#3-3-Spring-Boot-vs-Spring-MVC" class="headerlink" title="3.3 Spring Boot vs Spring MVC"></a>3.3 Spring Boot vs Spring MVC</h3><p>Spring MVC是Spring Framework中处理web请求的一个模块，是Spring Framework的一部分。层级是这样的:</p><p>Spring MVC &gt;&gt; Spring Framework &gt;&gt; Spring Boot</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h2><p>本文从顶层向下观察整个Spring Boot的构成，旨在使读者对Spring Boot的各个功能有一个大致的了解。</p><p>其提供的功能中，笔者认为Auto-configuration最为精妙好用，其它特性虽好但很多公司也已经有替代的解决方；而自动配置机制却的推出却让人有一种拨云见月、眼前一亮的感觉。</p><p>后面的文章中，我们将仔细介绍Auto-configuration和在此之上的Staters。</p>]]></content>
      
      
      <categories>
          
          <category> spring-boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> spring-boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Test （二、注解详解）</title>
      <link href="/2018/11/20/spring-boot/spring-boot-test-2/"/>
      <url>/2018/11/20/spring-boot/spring-boot-test-2/</url>
      
        <content type="html"><![CDATA[<p>Spring为了避免的繁琐难懂的xml配置，引入大量annotation进行系统配置，确实减轻了配置工作量。由此，理解这些annotation变得尤为重要，一定程度上讲，对Spring Boot Test的使用，就是对其相关annotation的使用。</p><p>掌握这些annotation（及部分关联的类），可以从注解功能分类，相互之间的搭配组合，及相似注解的差异这三方面着手。</p><span id="more"></span><h2 id="1-按功能分类"><a href="#1-按功能分类" class="headerlink" title="1.按功能分类"></a>1.按功能分类</h2><blockquote><p>本文仅讨论Spring Boot Test（版本：2.1.1.BUILD-SNAPSHOT）中的注解，原Spring Test中的注解将在其他文章中讨论。</p></blockquote><blockquote><p>由于使用这些注解的使用方式大多比较简单，为避免干扰阅读，本文不再罗列代码示例。若有想观看示例的开发者，可以查看<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-test">GitHub官方Sample</a>或<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project">spring-boot-test和spring-boot-test-autoconfigure的单元测试</a></p></blockquote><p>从功能上讲，Spring Boot Test中的注解主要分如下几类：</p><p>类别|示例|格式|说明<br>–|–<br>配置类型  |<code>@TestConfiguration</code>等| | 提供一些测试相关的配置入口<br>mock类型  |<code>@MockBean</code>等 | |提供mock支持<br>启动测试类型  |<code>@SpringBootTest</code> | <code>@\*Test</code> |以Test结尾的注解，具有加载applicationContext的能力<br>自动配置类型  |<code>@AutoConfigureJdbc</code>等   |  <code>@AutoConfigure*</code> | 以AutoConfigure开头的注解，具有加载测试支持功能的能力。</p><h3 id="1-1-配置类型的注解"><a href="#1-1-配置类型的注解" class="headerlink" title="1.1 配置类型的注解"></a>1.1 配置类型的注解</h3><p>注解 | 作用 | 实践中的使用<br>–|–<br><code>@TestComponent</code> | 该注解另一种<code>@Component</code>，在语义上用来指定某个Bean是专门用于测试的。| 该注解适用于测试代码和正式混合在一起时，不加载被该注解描述的Bean，使用不多。<br><code>@TestConfiguration</code> | 该注解是另一种<code>@TestComponent</code>，它用于补充额外的Bean或覆盖已存在的Bean | 在不修改正式代码的前提下，使配置更加灵活<br><code>@TypeExcludeFilters</code>  | 用来排除<code>@TestConfiguration</code>和<code>@TestComponent</code> | 适用于测试代码和正式代码混合的场景，使用不多<br><code>@OverrideAutoConfiguration</code> | 可用于覆盖<code>@EnableAutoConfiguration</code>，与<code>ImportAutoConfiguration</code>结合使用，以限制所加载的自动配置类 | 在不修改正式代码的前提下，提供了修改配置自动配置类的能力<br><code>@PropertyMapping</code>  | 定义<code>@AutoConfigure*</code>注解中用到的变量名称，例如在<code>@AutoConfigureMockMvc</code>中定义名为spring.test.mockmvc.webclient.enabled的变量 | 一般不使用</p><blockquote><p>使用<code>@SpringBootApplication</code>启动测试或者生产代码，被<code>@TestComponent</code>描述的Bean会自动被排除掉。如果不是则需要向<code>@SpringBootApplication</code>添加TypeExcludeFilter。</p></blockquote><h3 id="1-2-mock类型的注解"><a href="#1-2-mock类型的注解" class="headerlink" title="1.2 mock类型的注解"></a>1.2 mock类型的注解</h3><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td><code>@MockBean</code></td><td>用于mock指定的class或被注解的属性</td></tr><tr><td><code>@MockBeans</code></td><td>使<code>@MockBean</code>支持在同一类型或属性上多次出现</td></tr><tr><td><code>@SpyBean</code></td><td>用于spy指定的class或被注解的属性</td></tr><tr><td><code>@SpyBeans</code></td><td>使<code>@SpyBeans</code>支持在同一类型或属性上多次出现</td></tr></tbody></table><p><code>@MockBean</code>和<code>@SpyBean</code>这两个注解，在mockito框架中本来已经存在，且功能基本相同。Spring Boot Test又定义一份重复的注解，目的在于使<code>MockBean</code>和<code>SpyBean</code>被ApplicationContext管理，从而方便使用。</p><blockquote><p>MockBean和SpyBean功能非常相似，都能模拟方法的各种行为。不同之处在于MockBean是全新的对象，跟正式对象没有关系；而SpyBean与正式对象紧密联系，可以模拟正式对象的部分方法，没有被模拟的方法仍然可以运行正式代码。</p></blockquote><h3 id="1-3-自动配置类型的注解（-AutoConfigure-）"><a href="#1-3-自动配置类型的注解（-AutoConfigure-）" class="headerlink" title="1.3 自动配置类型的注解（@AutoConfigure*）"></a>1.3 自动配置类型的注解（@AutoConfigure*）</h3><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td><code>@AutoConfigureJdbc</code></td><td>自动配置JDBC</td></tr><tr><td><code>@AutoConfigureCache</code></td><td>自动配置缓存</td></tr><tr><td><code>@AutoConfigureDataLdap</code></td><td>自动配置LDAP</td></tr><tr><td><code>@AutoConfigureJson</code></td><td>自动配置JSON</td></tr><tr><td><code>@AutoConfigureJsonTesters</code></td><td>自动配置JsonTester</td></tr><tr><td><code>@AutoConfigureDataJpa</code></td><td>自动配置JPA</td></tr><tr><td><code>@AutoConfigureTestEntityManager</code></td><td>自动配置TestEntityManager</td></tr><tr><td><code>@AutoConfigureRestDocs</code></td><td>自动配置Rest Docs</td></tr><tr><td><code>@AutoConfigureMockRestServiceServer</code></td><td>自动配置 MockRestServiceServer</td></tr><tr><td><code>@AutoConfigureWebClient</code></td><td>自动配置 WebClient</td></tr><tr><td><code>@AutoConfigureWebFlux</code></td><td>自动配置 WebFlux</td></tr><tr><td><code>@AutoConfigureWebTestClient</code></td><td>自动配置 WebTestClient</td></tr><tr><td><code>@AutoConfigureMockMvc</code></td><td>自动配置 MockMvc</td></tr><tr><td><code>@AutoConfigureWebMvc</code></td><td>自动配置WebMvc</td></tr><tr><td><code>@AutoConfigureDataNeo4j</code></td><td>自动配置 Neo4j</td></tr><tr><td><code>@AutoConfigureDataRedis</code></td><td>自动配置 Redis</td></tr><tr><td><code>@AutoConfigureJooq</code></td><td>自动配置 Jooq</td></tr><tr><td><code>@AutoConfigureTestDatabase</code></td><td>自动配置Test Database，可以使用内存数据库</td></tr></tbody></table><p>这些注解可以搭配<code>@\*Test</code>使用，用于开启在<code>@\*Test</code>中未自动配置的功能。例如<code>@SpringBootTest</code>和<code>@AutoConfigureMockMvc</code>组合后，就可以注入<code>org.springframework.test.web.servlet.MockMvc</code>。</p><blockquote><p><strong>“自动配置类型”有两种使用方式：</strong></p></blockquote><ol><li>在功能测试（即使用<code>@SpringBootTest</code>）时显示添加。</li><li>一般在切片测试中被隐式使用，例如<code>@WebMvcTest</code>注解时，隐式添加了<code>@AutoConfigureCache</code>、<code>@AutoConfigureWebMvc</code>、<code>@AutoConfigureMockMvc</code>。</li></ol><blockquote><p><strong>实现原理</strong><br>与<code>spring-boot-autoconfigure</code>中的<code>@\*AutoConfiguration</code>实现略有不同，Test包中的<code>@AutoConfigure\*</code>通过<code>DeterminableImports</code>接口作为指定代码的识别入口，通过<code>ImportAutoConfiguration</code>注解作为配置入口，从Test包下的<a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-test-autoconfigure/src/main/resources/META-INF/spring.factories"><code>spring.factories</code></a>读取配置文件，每个<code>@AutoConfigure\*</code>中都可以包含多个Spring Boot的<code>@\*AutoConfiguration</code>，例如：<br><img src="/images/2018/12/autoconfigurewebmvc.png" alt="AutoConfigureWebMvc"></p></blockquote><h3 id="1-4-启动测试类型的注解（-Test）"><a href="#1-4-启动测试类型的注解（-Test）" class="headerlink" title="1.4 启动测试类型的注解（@*Test）"></a>1.4 启动测试类型的注解（@*Test）</h3><p>所有的@*Test注解都被<code>@BootstrapWith</code>注解，它们可以启动ApplicationContext，是测试的入口，所有的测试类必须声明一个@*Test注解。</p><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td><code>@SpringBootTest</code></td><td>自动侦测并加载@SpringBootApplication或@SpringBootConfiguration中的配置，默认web环境为MOCK，不监听任务端口</td></tr><tr><td><code>@DataRedisTest</code></td><td>测试对Redis操作，自动扫描被@RedisHash描述的类，并配置Spring Data Redis的库</td></tr><tr><td><code>@DataJpaTest</code></td><td>测试基于JPA的数据库操作，同时提供了TestEntityManager替代JPA的EntityManager</td></tr><tr><td><code>@DataJdbcTest</code></td><td>测试基于Spring Data JDBC的数据库操作</td></tr><tr><td><code>@JsonTest</code></td><td>测试JSON的序列化和反序列化</td></tr><tr><td><code>@WebMvcTest</code></td><td>测试Spring MVC中的controllers</td></tr><tr><td><code>@WebFluxTest</code></td><td>测试Spring WebFlux中的controllers</td></tr><tr><td><code>@RestClientTest</code></td><td>测试对REST客户端的操作</td></tr><tr><td><code>@DataLdapTest</code></td><td>测试对LDAP的操作</td></tr><tr><td><code>@DataMongoTest</code></td><td>测试对MongoDB的操作</td></tr><tr><td><code>@DataNeo4jTest</code></td><td>测试对Neo4j的操作</td></tr></tbody></table><blockquote><p>除了<code>@SpringBootTest</code>之外的注解都是用来进行切面测试的，他们会默认导入一些自动配置，点击<a href="https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/#test-auto-configuration">官方docs</a>查看详情。</p></blockquote><p>一般情况下，推荐使用<code>@SpringBootTest</code>而非其它切片测试的注解，简单有效。若某次改动仅涉及特定切片，可以考虑使用切片测试。</p><p><code>@SpringBootTest</code>是这些注解中最常用的一个，其中包含的配置项如下：</p><table><thead><tr><th>配置名称</th><th>说明</th></tr></thead><tbody><tr><td><code>value</code></td><td>指定配置属性</td></tr><tr><td><code>properties</code></td><td>指定配置属性，和value意义相同</td></tr><tr><td><code>classes</code></td><td>指定配置类，等同于<code>@ContextConfiguration</code>中的class，若没有显示指定，将查找嵌套的<code>@Configuration</code>类，然后返回到<code>SpringBootConfiguration</code>搜索配置</td></tr><tr><td><code>webEnvironment</code></td><td>指定web环境，可选值有：<code>MOCK</code>、<code>RANDOM_PORT</code>、<code>DEFINED_PORT</code>、<code>NONE</code></td></tr></tbody></table><p><code>webEnvironment</code>详细说明：</p><table><thead><tr><th>可选值</th><th>说明</th></tr></thead><tbody><tr><td><code>MOCK</code></td><td>此值为默认值，该类型提供一个mock环境，此时内嵌的服务（servlet容器）并没有真正启动，也不会监听web端口。</td></tr><tr><td><code>RANDOM_PORT</code></td><td>启动一个真实的web服务，监听一个随机端口。</td></tr><tr><td><code>DEFINED_PORT</code></td><td>启动一个真实的web服务，监听一个定义好的端口（从配置中读取）。</td></tr><tr><td><code>NONE</code></td><td>启动一个非web的ApplicationContext，既不提供mock环境，也不提供真是的web服务。</td></tr></tbody></table><h2 id="2-相互之间的搭配组合"><a href="#2-相互之间的搭配组合" class="headerlink" title="2. 相互之间的搭配组合"></a>2. 相互之间的搭配组合</h2><p>典型的搭配如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">sample<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token class-name">Before</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token class-name">Test</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>runner<span class="token punctuation">.</span></span><span class="token class-name">RunWith</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">sample<span class="token punctuation">.</span>test<span class="token punctuation">.</span>domain<span class="token punctuation">.</span></span><span class="token class-name">VehicleIdentificationNumber</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">sample<span class="token punctuation">.</span>test<span class="token punctuation">.</span>service<span class="token punctuation">.</span></span><span class="token class-name">VehicleDetails</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">sample<span class="token punctuation">.</span>test<span class="token punctuation">.</span>service<span class="token punctuation">.</span></span><span class="token class-name">VehicleDetailsService</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Autowired</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span></span><span class="token class-name">AutoConfigureTestDatabase</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span><span class="token class-name">SpringBootTest</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span><span class="token class-name">SpringBootTest</span><span class="token punctuation">.</span><span class="token class-name">WebEnvironment</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>mock<span class="token punctuation">.</span>mockito<span class="token punctuation">.</span></span><span class="token class-name">MockBean</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>web<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">TestRestTemplate</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>junit4<span class="token punctuation">.</span></span><span class="token class-name">SpringRunner</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token import static"><span class="token namespace">org<span class="token punctuation">.</span>mockito<span class="token punctuation">.</span></span><span class="token class-name">BDDMockito</span><span class="token punctuation">.</span><span class="token static">given</span></span><span class="token punctuation">;</span><span class="token comment">/** * &#123;@code @SpringBootTest&#125; with a random port for &#123;@link SampleTestApplication&#125;. * * @author Phillip Webb */</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token punctuation">(</span>webEnvironment <span class="token operator">=</span> <span class="token class-name">WebEnvironment</span><span class="token punctuation">.</span><span class="token constant">RANDOM_PORT</span><span class="token punctuation">)</span><span class="token annotation punctuation">@AutoConfigureTestDatabase</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SampleTestApplicationWebIntegrationTests</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">VehicleIdentificationNumber</span> <span class="token constant">VIN</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VehicleIdentificationNumber</span><span class="token punctuation">(</span><span class="token string">"01234567890123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">TestRestTemplate</span> restTemplate<span class="token punctuation">;</span><span class="token annotation punctuation">@MockBean</span><span class="token keyword">private</span> <span class="token class-name">VehicleDetailsService</span> vehicleDetailsService<span class="token punctuation">;</span><span class="token annotation punctuation">@Before</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">given</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vehicleDetailsService<span class="token punctuation">.</span><span class="token function">getVehicleDetails</span><span class="token punctuation">(</span><span class="token constant">VIN</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">willReturn</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">VehicleDetails</span><span class="token punctuation">(</span><span class="token string">"Honda"</span><span class="token punctuation">,</span> <span class="token string">"Civic"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>restTemplate<span class="token punctuation">.</span><span class="token function">getForEntity</span><span class="token punctuation">(</span><span class="token string">"/&#123;username&#125;/vehicle"</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"sframework"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>@RunWith(SpringRunner.class)是JUnit的注解，作用是关联Spring Boot Test，使运行JUnit时同时启动Spring</li><li>@SpringBootTest(webEnvironment &#x3D; WebEnvironment.RANDOM_PORT) 作用是启动Spring的ApplicationContext，参数webEnvironment指定了运行的web环境</li><li>@AutoConfigureTestDatabase 作用是启动一个内存数据库，不使用真实的数据库</li></ul><p>其中@RunWith和@*Test必须存在，@AutoConfigure*可以同时配置任意多个，而配置类型的注解可以在需要时添加。</p><h2 id="3-相似注解的区别和联系"><a href="#3-相似注解的区别和联系" class="headerlink" title="3. 相似注解的区别和联系"></a>3. 相似注解的区别和联系</h2><h3 id="3-1-TestComment-vs-Comment"><a href="#3-1-TestComment-vs-Comment" class="headerlink" title="3.1 @TestComment vs @Comment"></a>3.1 @TestComment vs @Comment</h3><ul><li><code>@TestComponent</code>是另一种<code>@Component</code>，在语义上用来指定某个Bean是专门用于测试的</li><li>使用@SpringBootApplication服务时，<code>@TestComponent</code>会被自动排除</li></ul><h3 id="3-2-TestConfiguration-vs-Configuration"><a href="#3-2-TestConfiguration-vs-Configuration" class="headerlink" title="3.2 @TestConfiguration vs @Configuration"></a>3.2 @TestConfiguration vs @Configuration</h3><ul><li><code>@TestConfiguration</code>是Spring Boot Boot Test提供的，<code>@Configuration</code>是Spring Framework提供的。</li><li><code>@TestConfiguration</code>实际上是也是一种<code>@TestComponent</code>，只是这个<code>@TestComponent</code>专门用来做配置用。</li><li><code>@TestConfiguration</code>和<code>@Configuration</code>不同，它不会阻止<code>@SpringBootTest</code>的查找机制，相当于是对既有配置的补充或覆盖。</li></ul><h3 id="3-3-SpringBootTest-vs-WebMvcTest-或-Test"><a href="#3-3-SpringBootTest-vs-WebMvcTest-或-Test" class="headerlink" title="3.3 @SpringBootTest vs @WebMvcTest(或@*Test)"></a>3.3 @SpringBootTest vs @WebMvcTest(或@*Test)</h3><ul><li>都可以启动Spring的ApplicationContext</li><li><code>@SpringBootTest</code>自动侦测并加载<code>@SpringBootApplication</code>或<code>@SpringBootConfiguration</code>中的配置，<code>@WebMvcTest</code>不侦测配置，只是默认加载一些自动配置。</li><li><code>@SpringBootTest</code>测试范围一般比<code>@WebMvcTest</code>大。</li></ul><h3 id="3-4-MockBean-vs-SpyBean"><a href="#3-4-MockBean-vs-SpyBean" class="headerlink" title="3.4 @MockBean vs @SpyBean"></a>3.4 @MockBean vs @SpyBean</h3><p>详见<a href="#1-2-mock%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B3%A8%E8%A7%A3">1.2 mock类型的注解</a></p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>本文主要介绍了Spring Boot Test中新增的注解，笔者将这些注解分为这几个类型：配置类型、mock类型、启动测试类型、自动配置类型。</p><ol><li>“配置类型”中的<code>@TestComponent</code>、<code>@TestConfiguration</code>、<code>@OverrideAutoConfiguration</code>使配置更加灵活。</li><li>封装了<code>mockito</code>的<code>@MockBean</code>和<code>@SpyBean</code>，使其可以自然的注入到Spring容器中。</li><li>每个测试类必须包含一个“启动测试类型”的注解(<code>@\*Test</code>)，同时可以根据需要添加”自动配置类型”的注解(<code>@AutoConfigure*</code>)。</li><li><code>@SpringBootTest</code>是最常用的“启动测试类型”注解</li></ol><p>参考：<br><a href="https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/#boot-features-testing">Spring Boot Reference Guide</a><br><a href="https://segmentfault.com/a/1190000010854811">Spring、Spring Boot和TestNG测试指南 - @TestConfiguration - 颇忒脱 - SegmentFault 思否</a><br><a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/autoconfigure/OverrideAutoConfiguration.html">OverrideAutoConfiguration (Spring Boot Docs 2.1.0.RELEASE API)</a><br><a href="https://gooroo.io/GoorooTHINK/Article/16943/Spring-Boot-14--MockBean-and-SpyBean/24301#.W_UcsZN3hEI">Spring Boot 1.4: @MockBean and @SpyBean | GoorooThink Tech News | Articles | Skills Analytics | Gooroo</a></p>]]></content>
      
      
      <categories>
          
          <category> spring-boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> spring-boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Test （一、快速入门）</title>
      <link href="/2018/11/17/spring-boot/spring-boot-test-1/"/>
      <url>/2018/11/17/spring-boot/spring-boot-test-1/</url>
      
        <content type="html"><![CDATA[<p>提起“单元测试”这几个字，一般开发者会条件反射般想起：“工作忙，没时间”，这是一个客观上的事实，在急于求成的大环境下，规范的单元测试却需要一些明确的代码产出及覆盖率指标，这的确很让人头疼。早几年的关于单元测试的文章，不停的鼓吹其好处，却对时间问题视而不见。</p><p>而与此相对: 对于开发者而言，其编写的代码是否需要经过测试，经过几轮测试才能让开发者安心？相信大多数开发者会说需要，且测试次数越多越好，毕竟上线时求神拜佛的滋味其实并不好受。</p><p>所以这其实是自相矛盾的，我们身处其中，有时候只能抱测试哥哥的大腿以求生路。但是仅仅靠测试人员把关，有些细节和异常流程不可避免会被漏掉。</p><span id="more"></span><h2 id="1-单元测试的缺点（抛砖引玉之言，不喜勿喷）"><a href="#1-单元测试的缺点（抛砖引玉之言，不喜勿喷）" class="headerlink" title="1. 单元测试的缺点（抛砖引玉之言，不喜勿喷）"></a>1. 单元测试的缺点（抛砖引玉之言，不喜勿喷）</h2><p>回到单元测试本身的概念上来，单元测试强调剥离所有外部依赖的影响，对类中的每个方法都写一个测试case，这里面本身存在一些现实问题：</p><ol><li>为每个方法写测试case，时间成本太高</li><li>有些方法的操作本身非常简单，只是一些简单的赋值等操作，没有必要写测试</li><li>团队开发能力参差不齐，解耦做的不好的情况下，单元测试越发困难</li><li>有些依赖非常难以剥离（进行mock），或者剥离的代价比较大，比如mvc中Controller需要web容器，数据库访问需要真实数据库（使用内存数据库，初始化的工作量也非常大），Redis等</li></ol><p>单元测试，仅适合那些逻辑复杂，逻辑分叉较多且较少依赖外部环境的方法，这些方法使用unit test再合适不过。除此之外的其他业务场景，建议舍弃单元测试，投入到“功能测试”的怀抱。</p><h2 id="2-功能测试"><a href="#2-功能测试" class="headerlink" title="2. 功能测试"></a>2. 功能测试</h2><p>在本文中，我们对功能测试做一下约定：在单个java虚拟机内部的，mock大部分外部依赖的影响，针对业务功能（通常是Controller或对外公开的Service）的测试，称之为“功能测试”，把单个服务内部的业务功能综合在一起，每一个测试case都是一个小业务流程。</p><p><img src="/images/2018/11/%E6%B5%8B%E8%AF%95%E9%87%91%E5%AD%97%E5%A1%94.png" alt="测试金字塔"></p><p>测试金字塔中的第二层是我们重点关注的，unit test虽好，但常规的业务开发中用的不多。</p><p>功能测试不同于集成测试（UI测试），集成测试原意是强调端到端的完整链路测试，期望环境尽可能是真实的，每一个测试case都是一个完整的业务流程，本文不讨论集成测试相关内容。</p><p>用测试代码安安心心的写出一条功能测试case，确保它能够正确执行，每个核心业务功能一条测试case。这样仍需做一些mock工作，但mock工作量变小了很多，再加上Spring框架支持，进一步减轻了测试工作量。</p><h2 id="3-Spring-Boot-Test-简介"><a href="#3-Spring-Boot-Test-简介" class="headerlink" title="3. Spring Boot Test 简介"></a>3. Spring Boot Test 简介</h2><p>Spring Test与JUnit等其他测试框架结合起来，提供了便捷高效的测试手段。而Spring Boot Test 是在Spring Test之上的再次封装，增加了切片测试，增强了mock能力。</p><p>整体上，Spring Boot Test支持的测试种类，大致可以分为如下三类：</p><table><thead><tr><th>类别</th><th>描述</th><th>涉及的注解</th></tr></thead><tbody><tr><td>单元测试</td><td>一般面向方法，编写一般业务代码时，测试成本较大（理由见上文）</td><td>@Test</td></tr><tr><td>切片测试</td><td>一般面向难于测试的边界功能，介于单元测试和功能测试之间</td><td>@RunWith @WebMvcTest等</td></tr><tr><td>功能测试</td><td>一般面向某个完整的业务功能，同时也可以使用切面测试中的mock能力，推荐使用</td><td>@RunWith @SpringBootTest等</td></tr></tbody></table><p>功能测试过程中的几个关键要素及支撑方式如下：</p><table><thead><tr><th>要素</th><th>实现方式</th></tr></thead><tbody><tr><td>测试运行环境</td><td>通过@RunWith 和 @SpringBootTest启动spring容器</td></tr><tr><td>mock能力</td><td>Mockito提供了强大mock功能</td></tr><tr><td>断言能力</td><td>AssertJ、Hamcrest、JsonPath提供了强大的断言能力</td></tr></tbody></table><h2 id="4-快速开始"><a href="#4-快速开始" class="headerlink" title="4. 快速开始"></a>4. 快速开始</h2><p>增加spring-boot-starter-test依赖，使用@RunWith和@SpringBootTest注解，即可开始测试。</p><h3 id="4-1-添加依赖"><a href="#4-1-添加依赖" class="headerlink" title="4.1 添加依赖"></a>4.1 添加依赖</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一旦依赖了spring-boot-starter-test，下面这些类库将被一同依赖进去：</p><table><thead><tr><th>名称</th><th>简介</th></tr></thead><tbody><tr><td>JUnit</td><td>java测试事实上的标准，默认依赖版本是4.12（JUnit5和JUnit4差别比较大，集成方式有不同）</td></tr><tr><td>Spring Test &amp; Spring Boot Test</td><td>Spring的测试支持</td></tr><tr><td>AssertJ</td><td>提供了流式的断言方式</td></tr><tr><td>Hamcrest</td><td>提供了丰富的matcher</td></tr><tr><td>Mockito</td><td>mock框架，可以按类型创建mock对象，可以根据方法参数指定特定的响应，也支持对于mock调用过程的断言</td></tr><tr><td>JSONassert</td><td>为JSON提供了断言功能</td></tr><tr><td>JsonPath</td><td>为JSON提供了XPATH功能</td></tr></tbody></table><h3 id="4-2-测试类"><a href="#4-2-测试类" class="headerlink" title="4.2 测试类"></a>4.2 测试类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>learn<span class="token punctuation">.</span>springboottestlearn<span class="token punctuation">.</span>ttt</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>learn<span class="token punctuation">.</span>springboottestlearn<span class="token punctuation">.</span>entity<span class="token punctuation">.</span></span><span class="token class-name">User</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>learn<span class="token punctuation">.</span>springboottestlearn<span class="token punctuation">.</span>service<span class="token punctuation">.</span></span><span class="token class-name">UserService</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token class-name">Test</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>runner<span class="token punctuation">.</span></span><span class="token class-name">RunWith</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Autowired</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span><span class="token class-name">SpringBootTest</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>junit4<span class="token punctuation">.</span></span><span class="token class-name">SpringRunner</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringBootTestLearnApplicationTests</span> <span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testAddUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"john"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">"earth"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>userService<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@RunWith是Junit4提供的注解，将Spring和Junit链接了起来。</p><blockquote><p>假如使用Junit5，不再需要使用@ExtendWith注解，@SpringBootTest和其它@*Test默认已经包含了该注解。</p></blockquote><p>@SpringBootTest替代了spring-test中的@ContextConfiguration注解，目的是加载ApplicationContext，启动spring容器。</p><p>使用@SpringBootTest时并没有像@ContextConfiguration一样显示指定locations或classes属性，原因在于@SpringBootTest注解会自动检索程序的配置文件，检索顺序是从当前包开始，逐级向上查找被@SpringBootApplication或@SpringBootConfiguration注解的类。</p><h2 id="5-功能测试"><a href="#5-功能测试" class="headerlink" title="5. 功能测试"></a>5. 功能测试</h2><p>一般情况下，使用@SpringBootTest后，Spring将加载所有被管理的bean，基本等同于启动了整个服务，此时便可以开始功能测试。</p><p>由于web服务是最常见的服务，且我们对于web服务的测试有一些特殊的期望，所以@SpringBootTest注解中，给出了webEnvironment参数指定了web的environment，该参数的值一共有四个可选值：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>MOCK</td><td>此值为默认值，该类型提供一个mock环境，可以和@AutoConfigureMockMvc或@AutoConfigureWebTestClient搭配使用，开启Mock相关的功能。注意此时内嵌的服务（servlet容器）并没有真正启动，也不会监听web服务端口。</td></tr><tr><td>RANDOM_PORT</td><td>启动一个真实的web服务，监听一个随机端口。</td></tr><tr><td>DEFINED_PORT</td><td>启动一个真实的web服务，监听一个定义好的端口（从application.properties读取）。</td></tr><tr><td>NONE</td><td>启动一个非web的ApplicationContext，既不提供mock环境，也不提供真实的web服务。</td></tr></tbody></table><blockquote><p>另外，如果当前服务的classpath中没有包含web相关的依赖，spring将启动一个非web的ApplicationContext，此时的webEnvironment就没有什么意义了</p></blockquote><h2 id="6-切片测试"><a href="#6-切片测试" class="headerlink" title="6. 切片测试"></a>6. 切片测试</h2><p>所谓切片测试，官网文档称为 “slice” of your application，实际上是对一些特定组件的称呼。这里的slice并非单独的类（毕竟普通类只需要基于JUnit的单元测试即可），而是介于单元测试和集成测试中间的范围。</p><p>slice是指一些在特定环境下才能执行的模块，比如MVC中的Controller、JDBC数据库访问、Redis客户端等，这些模块大多脱离特定环境后不能独立运行，假如spring没有为此提供测试支持，开发者只能启动完整服务对这些模块进行测试，这在一些复杂的系统中非常不方便，所以spring为这些模块提供了测试支持，使开发者有能力单独对这些模块进行测试。</p><p>通过@*Test开启具体模块的测试支持，开启后spring仅加载相关的bean，无关内容不会被加载。</p><p>使用@WebMvcTest用来校验controllers是否正常工作的示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>runner<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>mock<span class="token punctuation">.</span>mockito<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token import static"><span class="token namespace">org<span class="token punctuation">.</span>assertj<span class="token punctuation">.</span>core<span class="token punctuation">.</span>api<span class="token punctuation">.</span></span><span class="token class-name">Assertions</span><span class="token punctuation">.</span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token import static"><span class="token namespace">org<span class="token punctuation">.</span>mockito<span class="token punctuation">.</span></span><span class="token class-name">BDDMockito</span><span class="token punctuation">.</span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token import static"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>request<span class="token punctuation">.</span></span><span class="token class-name">MockMvcRequestBuilders</span><span class="token punctuation">.</span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token import static"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>result<span class="token punctuation">.</span></span><span class="token class-name">MockMvcResultMatchers</span><span class="token punctuation">.</span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@WebMvcTest</span><span class="token punctuation">(</span><span class="token class-name">UserVehicleController</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyControllerTests</span> <span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">MockMvc</span> mvc<span class="token punctuation">;</span><span class="token annotation punctuation">@MockBean</span><span class="token keyword">private</span> <span class="token class-name">UserVehicleService</span> userVehicleService<span class="token punctuation">;</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span><span class="token function">given</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>userVehicleService<span class="token punctuation">.</span><span class="token function">getVehicleDetails</span><span class="token punctuation">(</span><span class="token string">"sboot"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">willReturn</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">VehicleDetails</span><span class="token punctuation">(</span><span class="token string">"Honda"</span><span class="token punctuation">,</span> <span class="token string">"Civic"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>mvc<span class="token punctuation">.</span><span class="token function">perform</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/sboot/vehicle"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token class-name">MediaType</span><span class="token punctuation">.</span><span class="token constant">TEXT_PLAIN</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isOk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span><span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"Honda Civic"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用@WebMvcTest和MockMvc搭配使用，可以在不启动web容器的情况下，对Controller进行测试。</p><h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a>7. 小结</h2><p>本文主要介绍了如下几点内容：</p><ol><li>测试可以分为单元测试、功能测试、以及介于两者之间的切片测试</li><li>建议放弃不必要的单元测试，拥抱功能测试、切片测试。</li><li>Spring Boot Test在spring-test基础上，增强了mock能力，增加了测试的自动配置、切片测试。</li><li>@SpringBootTest、@WebMvcTest等其他@*Test注解， 作为开启测试的注解，都可以启动一个ApplicationContext。</li></ol>]]></content>
      
      
      <categories>
          
          <category> spring-boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> spring-boot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
